package compiler

import (
	"fmt"
	"go/ast"
	"go/constant"
	"go/parser"
	"go/token"
	"go/types"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/NERVsystems/infernode/tools/godis/dis"
	"golang.org/x/tools/go/ssa"
	"golang.org/x/tools/go/ssa/ssautil"
)

// ifaceImpl records one concrete implementation of an interface method.
type ifaceImpl struct {
	tag int32         // type tag ID for the concrete type
	fn  *ssa.Function // the concrete method
}

// Compiler compiles Go source to Dis bytecode.
type Compiler struct {
	strings      map[string]int32        // string literal → MP offset (deduplicating)
	reals        map[float64]int32       // float literal → MP offset (deduplicating)
	globals      map[string]int32        // global variable name → MP offset
	sysUsed      map[string]int          // Sys function name → LDT index
	mod          *ModuleData
	sysMPOff     int32
	errors       []string
	closureMap   map[ssa.Value]*ssa.Function // MakeClosure result → inner function
	closureRetFn map[*ssa.Function]*ssa.Function // func that returns a closure → inner fn
	// Interface dispatch: method name → concrete method function.
	methodMap    map[string]*ssa.Function // "TypeName.MethodName" → *ssa.Function
	// Type tag registry for tagged interface dispatch.
	typeTagMap    map[string]int32   // concrete type name → tag ID (starts at 1)
	typeTagNext   int32              // next tag to allocate
	ifaceDispatch map[string][]ifaceImpl // method name → [{tag, fn}, ...]
	excGlobalOff int32 // MP offset for exception bridge slot (lazy-allocated, 0 = not allocated)
	initFuncs    []*ssa.Function // user-defined init functions (init#1, init#2, ...) to call before main
	closureFuncTags    map[*ssa.Function]int32 // inner function → unique tag for dynamic dispatch
	closureFuncTagNext int32                   // next tag to allocate (starts at 1)
	BaseDir      string // directory containing main package (for resolving local imports)
}

// New creates a new Compiler.
func New() *Compiler {
	return &Compiler{
		strings:       make(map[string]int32),
		reals:         make(map[float64]int32),
		globals:       make(map[string]int32),
		sysUsed:       make(map[string]int),
		closureMap:    make(map[ssa.Value]*ssa.Function),
		closureRetFn:  make(map[*ssa.Function]*ssa.Function),
		methodMap:     make(map[string]*ssa.Function),
		typeTagMap:    make(map[string]int32),
		typeTagNext:   1, // tag 0 = nil interface
		ifaceDispatch:      make(map[string][]ifaceImpl),
		closureFuncTags:    make(map[*ssa.Function]int32),
		closureFuncTagNext: 1, // tag 0 = reserved
	}
}

// AllocTypeTag returns (or allocates) a unique integer tag for a concrete type name.
// Tag 0 is reserved for nil interfaces.
func (c *Compiler) AllocTypeTag(typeName string) int32 {
	if tag, ok := c.typeTagMap[typeName]; ok {
		return tag
	}
	tag := c.typeTagNext
	c.typeTagNext++
	c.typeTagMap[typeName] = tag
	return tag
}

// AllocClosureTag returns (or allocates) a unique integer tag for an inner function.
// Used for dynamic closure dispatch.
func (c *Compiler) AllocClosureTag(fn *ssa.Function) int32 {
	if tag, ok := c.closureFuncTags[fn]; ok {
		return tag
	}
	tag := c.closureFuncTagNext
	c.closureFuncTagNext++
	c.closureFuncTags[fn] = tag
	return tag
}

// registerClosure records that a MakeClosure instruction creates a closure for innerFn.
func (c *Compiler) registerClosure(mc *ssa.MakeClosure, innerFn *ssa.Function) {
	c.closureMap[mc] = innerFn
	// Also track the parent function's return: if this MakeClosure is returned,
	// callers of the parent can resolve the closure target.
	if mc.Parent() != nil {
		c.closureRetFn[mc.Parent()] = innerFn
	}
}

// resolveClosureTarget traces an SSA value back to determine which inner function
// a closure refers to. Returns nil if it cannot be statically resolved.
func (c *Compiler) resolveClosureTarget(v ssa.Value) *ssa.Function {
	// Direct MakeClosure result
	if fn, ok := c.closureMap[v]; ok {
		return fn
	}
	// Return value of a function that always returns a specific closure
	if call, ok := v.(*ssa.Call); ok {
		if callee, ok := call.Call.Value.(*ssa.Function); ok {
			if fn, ok := c.closureRetFn[callee]; ok {
				return fn
			}
		}
	}
	return nil
}

// ResolveInterfaceMethods finds all concrete implementations for a method name
// called on an interface. Returns a list of {tag, fn} pairs — one per concrete type.
func (c *Compiler) ResolveInterfaceMethods(methodName string) []ifaceImpl {
	if impls, ok := c.ifaceDispatch[methodName]; ok && len(impls) > 0 {
		return impls
	}
	return nil
}

// AllocGlobal allocates storage for a global variable in the module data section.
// Returns the MP offset. Pointer-typed globals are tracked for GC.
func (c *Compiler) AllocGlobal(name string, isPtr bool) int32 {
	if off, ok := c.globals[name]; ok {
		return off
	}
	var off int32
	if isPtr {
		off = c.mod.AllocPointer("global:" + name)
	} else {
		off = c.mod.AllocWord("global:" + name)
	}
	c.globals[name] = off
	return off
}

// GlobalOffset returns the MP offset for a global variable, or -1 if not allocated.
func (c *Compiler) GlobalOffset(name string) (int32, bool) {
	off, ok := c.globals[name]
	return off, ok
}

// AllocString allocates a string literal in the module data section,
// deduplicating identical strings. Returns the MP offset.
func (c *Compiler) AllocString(s string) int32 {
	if off, ok := c.strings[s]; ok {
		return off
	}
	off := c.mod.AllocPointer("str")
	c.strings[s] = off
	return off
}

// AllocReal allocates a float64 literal in the module data section,
// deduplicating identical values. Returns the MP offset.
func (c *Compiler) AllocReal(val float64) int32 {
	if off, ok := c.reals[val]; ok {
		return off
	}
	off := c.mod.AllocWord("real")
	c.reals[val] = off
	return off
}

// AllocExcGlobal lazily allocates the exception bridge slot in module data.
// This is a WORD (not pointer) used to pass exception values from handler to deferred closures.
func (c *Compiler) AllocExcGlobal() int32 {
	if c.excGlobalOff == 0 {
		c.excGlobalOff = c.mod.AllocWord("excval")
	}
	return c.excGlobalOff
}

// compiledFunc holds the compilation result for a single function.
type compiledFunc struct {
	fn     *ssa.Function
	result *lowerResult
}

// CompileFile compiles a single Go source file to a Dis module.
func (c *Compiler) CompileFile(filename string, src []byte) (*dis.Module, error) {
	return c.CompileFiles([]string{filename}, [][]byte{src})
}

// importResult holds the parsed/type-checked result of a local package import.
type importResult struct {
	pkg   *types.Package
	files []*ast.File
	info  *types.Info
}

// localImporter resolves imports: first checking known stubs, then looking for
// local package directories relative to baseDir.
type localImporter struct {
	stub    stubImporter
	baseDir string              // directory containing main package source
	fset    *token.FileSet      // shared fileset
	cache   map[string]*importResult // import path → result
	errors  *[]string           // shared error list
}

func (li *localImporter) Import(path string) (*types.Package, error) {
	// Try stub first (fmt, strings, math, etc.)
	pkg, err := li.stub.Import(path)
	if err == nil {
		return pkg, nil
	}

	// Check cache
	if result, ok := li.cache[path]; ok {
		return result.pkg, nil
	}

	// Resolve from disk: baseDir/path/
	dir := filepath.Join(li.baseDir, path)
	entries, dirErr := os.ReadDir(dir)
	if dirErr != nil {
		return nil, fmt.Errorf("unsupported import: %q (not a stub and directory %s not found)", path, dir)
	}

	// Parse all .go files in the directory
	var files []*ast.File
	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".go") {
			continue
		}
		// Skip test files
		if strings.HasSuffix(entry.Name(), "_test.go") {
			continue
		}
		filePath := filepath.Join(dir, entry.Name())
		src, readErr := os.ReadFile(filePath)
		if readErr != nil {
			return nil, fmt.Errorf("read %s: %w", filePath, readErr)
		}
		f, parseErr := parser.ParseFile(li.fset, entry.Name(), src, parser.AllErrors)
		if parseErr != nil {
			return nil, fmt.Errorf("parse %s: %w", filePath, parseErr)
		}
		files = append(files, f)
	}
	if len(files) == 0 {
		return nil, fmt.Errorf("no .go files in %s", dir)
	}

	// Type-check with recursive import resolution
	info := &types.Info{
		Types:      make(map[ast.Expr]types.TypeAndValue),
		Defs:       make(map[*ast.Ident]types.Object),
		Uses:       make(map[*ast.Ident]types.Object),
		Implicits:  make(map[ast.Node]types.Object),
		Selections: make(map[*ast.SelectorExpr]*types.Selection),
	}
	conf := &types.Config{
		Importer: li, // recursive: local packages can import other local packages
		Error: func(err error) {
			*li.errors = append(*li.errors, err.Error())
		},
	}
	// Determine package name from first file
	pkgName := files[0].Name.Name
	typePkg, checkErr := conf.Check(path, li.fset, files, info)
	if checkErr != nil {
		return nil, fmt.Errorf("typecheck %s: %w", pkgName, checkErr)
	}

	li.cache[path] = &importResult{pkg: typePkg, files: files, info: info}
	return typePkg, nil
}

// localPackages returns all locally-resolved packages (not stubs) in dependency order.
func (li *localImporter) localPackages() []*importResult {
	// Return in sorted order for determinism
	var paths []string
	for path := range li.cache {
		paths = append(paths, path)
	}
	sort.Strings(paths)
	var results []*importResult
	for _, p := range paths {
		results = append(results, li.cache[p])
	}
	return results
}

// CompileFiles compiles one or more Go source files to a Dis module.
// All files must declare the same package (typically "main").
func (c *Compiler) CompileFiles(filenames []string, sources [][]byte) (*dis.Module, error) {
	fset := token.NewFileSet()

	// Parse all files
	var files []*ast.File
	for i, filename := range filenames {
		file, err := parser.ParseFile(fset, filename, sources[i], parser.AllErrors)
		if err != nil {
			return nil, fmt.Errorf("parse %s: %w", filename, err)
		}
		files = append(files, file)
	}

	// Verify all files declare the same package
	if len(files) > 1 {
		pkgName := files[0].Name.Name
		for i := 1; i < len(files); i++ {
			if files[i].Name.Name != pkgName {
				return nil, fmt.Errorf("multiple packages: %s and %s", pkgName, files[i].Name.Name)
			}
		}
	}

	// Set up importer
	importer := &localImporter{
		baseDir: c.BaseDir,
		fset:    fset,
		cache:   make(map[string]*importResult),
		errors:  &c.errors,
	}

	// Type-check
	conf := &types.Config{
		Importer: importer,
		Error: func(err error) {
			c.errors = append(c.errors, err.Error())
		},
	}
	info := &types.Info{
		Types:      make(map[ast.Expr]types.TypeAndValue),
		Defs:       make(map[*ast.Ident]types.Object),
		Uses:       make(map[*ast.Ident]types.Object),
		Implicits:  make(map[ast.Node]types.Object),
		Selections: make(map[*ast.SelectorExpr]*types.Selection),
	}

	pkg, err := conf.Check("main", fset, files, info)
	if err != nil {
		return nil, fmt.Errorf("typecheck: %w", err)
	}

	// Build SSA
	ssaProg := ssa.NewProgram(fset, ssa.BuilderMode(0))

	// Create SSA packages for all imports
	localPkgs := make(map[string]*importResult) // path → result for local packages
	for _, imp := range pkg.Imports() {
		if result, ok := importer.cache[imp.Path()]; ok {
			// Local package — build with real AST
			ssaProg.CreatePackage(imp, result.files, result.info, true)
			localPkgs[imp.Path()] = result
		} else {
			// Stub package — no AST needed
			ssaProg.CreatePackage(imp, nil, nil, true)
		}
	}

	// Also create SSA packages for transitive local imports
	// (local packages may import other local packages)
	for path, result := range importer.cache {
		if _, ok := localPkgs[path]; ok {
			continue // already handled
		}
		// This is a transitively imported local package
		ssaProg.CreatePackage(result.pkg, result.files, result.info, true)
		localPkgs[path] = result
		// Also create SSA packages for ITS imports
		for _, transImp := range result.pkg.Imports() {
			if _, ok2 := importer.cache[transImp.Path()]; ok2 {
				continue // will be handled by outer loop or already done
			}
			// Stub import from a local package
			if ssaProg.Package(transImp) == nil {
				ssaProg.CreatePackage(transImp, nil, nil, true)
			}
		}
	}

	ssaPkg := ssaProg.CreatePackage(pkg, files, info, true)
	ssaPkg.Build()

	// Build local packages too
	for _, result := range localPkgs {
		ssaImpPkg := ssaProg.Package(result.pkg)
		if ssaImpPkg != nil {
			ssaImpPkg.Build()
		}
	}

	// Find the main function
	mainFn := ssaPkg.Func("main")
	if mainFn == nil {
		return nil, fmt.Errorf("no main function found")
	}

	// Set up module data
	c.mod = NewModuleData()
	c.sysMPOff = c.mod.AllocPointer("sys") // Sys module ref at MP+0

	// Pre-register Sys functions (scan all user packages)
	userPkgs := map[*ssa.Package]bool{ssaPkg: true}
	for _, result := range localPkgs {
		ssaImpPkg := ssaProg.Package(result.pkg)
		if ssaImpPkg != nil {
			userPkgs[ssaImpPkg] = true
		}
	}
	c.scanSysCallsMulti(ssaProg, userPkgs)

	// Allocate "$Sys" path string in module data
	sysPathOff := c.AllocString("$Sys")

	// Allocate storage for package-level global variables in MP (main package)
	for _, mem := range ssaPkg.Members {
		if g, ok := mem.(*ssa.Global); ok {
			elemType := g.Type().(*types.Pointer).Elem()
			dt := GoTypeToDis(elemType)
			c.AllocGlobal(g.Name(), dt.IsPtr)
		}
	}

	// Allocate globals from local imported packages (prefixed to avoid collisions)
	for path, result := range localPkgs {
		ssaImpPkg := ssaProg.Package(result.pkg)
		if ssaImpPkg == nil {
			continue
		}
		for _, mem := range ssaImpPkg.Members {
			if g, ok := mem.(*ssa.Global); ok {
				elemType := g.Type().(*types.Pointer).Elem()
				dt := GoTypeToDis(elemType)
				globalName := path + "." + g.Name()
				c.AllocGlobal(globalName, dt.IsPtr)
			}
		}
	}

	// Collect all functions to compile: main first, then others alphabetically.
	// This includes both package-level functions and methods on named types.
	allFuncs := []*ssa.Function{mainFn}
	seen := map[*ssa.Function]bool{mainFn: true}

	// Collect from main package
	c.collectPackageFuncs(ssaProg, ssaPkg, &allFuncs, seen)

	// Collect from local imported packages (dependency order: imports first)
	for _, result := range importer.localPackages() {
		ssaImpPkg := ssaProg.Package(result.pkg)
		if ssaImpPkg != nil {
			c.collectPackageFuncs(ssaProg, ssaImpPkg, &allFuncs, seen)
		}
	}

	// Register synthetic errorString type for error interface dispatch.
	// Must happen after named type method scanning so it doesn't conflict.
	c.RegisterErrorString()

	// Recursively discover anonymous/inner functions (closures)
	for i := 0; i < len(allFuncs); i++ {
		for _, anon := range allFuncs[i].AnonFuncs {
			if !seen[anon] && len(anon.Blocks) > 0 {
				allFuncs = append(allFuncs, anon)
				seen[anon] = true
			}
		}
	}

	sort.Slice(allFuncs[1:], func(i, j int) bool {
		return allFuncs[1+i].Name() < allFuncs[1+j].Name()
	})

	// Pre-scan: discover closure relationships before compilation
	// This is needed because main is compiled first but may call closures
	// created by functions compiled later.
	c.scanClosures(allFuncs)

	// Discover bound method wrappers (e.g. (*T).Method$bound) from MakeClosure targets.
	// These are synthetic functions created by SSA that aren't package members or AnonFuncs.
	for _, innerFn := range c.closureMap {
		if !seen[innerFn] && len(innerFn.Blocks) > 0 {
			allFuncs = append(allFuncs, innerFn)
			seen[innerFn] = true
			// Also discover their anonymous functions recursively
			for i := len(allFuncs) - 1; i < len(allFuncs); i++ {
				for _, anon := range allFuncs[i].AnonFuncs {
					if !seen[anon] && len(anon.Blocks) > 0 {
						allFuncs = append(allFuncs, anon)
						seen[anon] = true
					}
				}
			}
		}
	}

	// Phase 1: Compile all functions
	var compiled []compiledFunc
	for _, fn := range allFuncs {
		fl := newFuncLowerer(fn, c, c.sysMPOff, c.sysUsed)
		result, err := fl.lower()
		if err != nil {
			return nil, fmt.Errorf("compile %s: %w", fn.Name(), err)
		}
		compiled = append(compiled, compiledFunc{fn, result})
	}

	// Phase 2: Assign type descriptor IDs
	// TD 0 = module data (MP)
	// TD 1..N = function frame type descriptors (main=1, then others)
	// TD N+1.. = call-site type descriptors
	funcTDID := make(map[*ssa.Function]int)
	nextTD := 1
	for _, cf := range compiled {
		funcTDID[cf.fn] = nextTD
		nextTD++
	}
	callTDBase := nextTD

	// Phase 3: Compute function start PCs
	// Layout: [LOAD preamble] [main insts] [func1 insts] [func2 insts] ...
	entryLen := int32(1) // just the LOAD instruction
	funcStartPC := make(map[*ssa.Function]int32)
	offset := entryLen
	for _, cf := range compiled {
		funcStartPC[cf.fn] = offset
		offset += int32(len(cf.result.insts))
	}

	// Phase 4: Patch all instructions
	callTDOffset := callTDBase
	for _, cf := range compiled {
		startPC := funcStartPC[cf.fn]

		// Build set of instruction indices that have funcCallPatches
		patchedInsts := make(map[int]bool)
		for _, p := range cf.result.funcCallPatches {
			patchedInsts[p.instIdx] = true
			inst := &cf.result.insts[p.instIdx]
			switch p.patchKind {
			case patchIFRAME:
				inst.Src = dis.Imm(int32(funcTDID[p.callee]))
			case patchICALL:
				inst.Dst = dis.Imm(funcStartPC[p.callee])
			}
		}

		for i := range cf.result.insts {
			if patchedInsts[i] {
				continue // already patched above
			}
			inst := &cf.result.insts[i]

			// Patch call-site type descriptor IDs
			// IFRAME/INEW: TD ID is in src operand
			if (inst.Op == dis.IFRAME || inst.Op == dis.INEW) && inst.Src.Mode == dis.AIMM {
				inst.Src.Val += int32(callTDOffset)
			}
			// NEWA: element TD ID is in mid operand
			if inst.Op == dis.INEWA && inst.Mid.Mode == dis.AIMM {
				inst.Mid.Val += int32(callTDOffset)
			}

			// Patch intra-function branch targets to global PCs
			if inst.Op.IsBranch() && inst.Dst.Mode == dis.AIMM {
				inst.Dst.Val += startPC
			}
		}

		callTDOffset += len(cf.result.callTypeDescs)
	}

	// Phase 5: Build type descriptor array
	var allTypeDescs []dis.TypeDesc
	allTypeDescs = append(allTypeDescs, dis.TypeDesc{}) // TD 0 = MP (filled in later)

	for _, cf := range compiled {
		allTypeDescs = append(allTypeDescs, cf.result.frame.TypeDesc(funcTDID[cf.fn]))
	}

	// Add call-site type descriptors
	tdID := callTDBase
	for _, cf := range compiled {
		for i := range cf.result.callTypeDescs {
			cf.result.callTypeDescs[i].ID = tdID + i
		}
		allTypeDescs = append(allTypeDescs, cf.result.callTypeDescs...)
		tdID += len(cf.result.callTypeDescs)
	}

	allTypeDescs[0] = c.mod.TypeDesc(0)

	// Phase 5.5: Collect exception handlers from all functions
	var allHandlers []dis.Handler
	for _, cf := range compiled {
		startPC := funcStartPC[cf.fn]
		for _, h := range cf.result.handlers {
			allHandlers = append(allHandlers, dis.Handler{
				EOffset: h.eoff,
				PC1:     h.pc1 + startPC,
				PC2:     h.pc2 + startPC,
				DescID:  -1, // string-only exceptions
				NE:      0,
				Etab:    nil,
				WildPC:  h.wildPC + startPC,
			})
		}
	}

	// Phase 6: Concatenate instructions
	var allInsts []dis.Inst
	allInsts = append(allInsts,
		dis.NewInst(dis.ILOAD, dis.MP(sysPathOff), dis.Imm(0), dis.MP(c.sysMPOff)),
	)
	for _, cf := range compiled {
		allInsts = append(allInsts, cf.result.insts...)
	}

	// Ensure last instruction is RET
	if len(allInsts) == 0 || allInsts[len(allInsts)-1].Op != dis.IRET {
		allInsts = append(allInsts, dis.Inst0(dis.IRET))
	}

	// Build module name from first filename
	moduleName := strings.TrimSuffix(filenames[0], ".go")
	if len(moduleName) > 0 {
		moduleName = strings.ToUpper(moduleName[:1]) + moduleName[1:]
	}

	mainTDID := int32(funcTDID[mainFn])

	m := dis.NewModule(moduleName)
	m.RuntimeFlags = dis.HASLDT
	if len(allHandlers) > 0 {
		m.RuntimeFlags |= dis.HASEXCEPT
		m.Handlers = allHandlers
	}
	m.Instructions = allInsts
	m.TypeDescs = allTypeDescs
	m.DataSize = c.mod.Size()
	m.EntryPC = 0
	m.EntryType = mainTDID

	// Build data section with all string literals
	m.Data = c.buildDataSection()

	// Build links (exported functions)
	// Signature 0x4244b354 is for init(ctxt: ref Draw->Context, args: list of string)
	m.Links = []dis.Link{
		{PC: 0, DescID: mainTDID, Sig: 0x4244b354, Name: "init"},
	}

	// Build LDT
	m.LDT = c.buildLDT()

	m.SrcPath = filenames[0]

	_ = ssautil.AllFunctions(ssaProg) // for future use

	return m, nil
}

// collectPackageFuncs collects functions, methods, and init funcs from an SSA package.
func (c *Compiler) collectPackageFuncs(ssaProg *ssa.Program, ssaPkg *ssa.Package, allFuncs *[]*ssa.Function, seen map[*ssa.Function]bool) {
	for _, mem := range ssaPkg.Members {
		switch m := mem.(type) {
		case *ssa.Function:
			if !seen[m] && m.Name() != "init" && len(m.Blocks) > 0 {
				*allFuncs = append(*allFuncs, m)
				seen[m] = true
				// User-defined init functions appear as init#1, init#2, etc.
				if strings.HasPrefix(m.Name(), "init#") {
					c.initFuncs = append(c.initFuncs, m)
				}
			}
		case *ssa.Type:
			// Collect methods on named types
			nt, ok := m.Type().(*types.Named)
			if !ok {
				continue
			}
			for i := 0; i < nt.NumMethods(); i++ {
				method := ssaProg.FuncValue(nt.Method(i))
				if method != nil && !seen[method] && len(method.Blocks) > 0 {
					*allFuncs = append(*allFuncs, method)
					seen[method] = true
					// Register in methodMap for interface dispatch
					typeName := nt.Obj().Name()
					key := typeName + "." + method.Name()
					c.methodMap[key] = method
					// Register in ifaceDispatch with type tag
					tag := c.AllocTypeTag(typeName)
					c.ifaceDispatch[method.Name()] = append(
						c.ifaceDispatch[method.Name()],
						ifaceImpl{tag: tag, fn: method})
				}
			}
		}
	}
}

// scanClosures pre-scans all functions to discover closure relationships.
// For each function that contains a MakeClosure instruction, record:
// 1. The MakeClosure value → inner function mapping
// 2. If the function returns a MakeClosure, record parent → inner function
// 3. Allocate function tags for dynamic dispatch
func (c *Compiler) scanClosures(allFuncs []*ssa.Function) {
	for _, fn := range allFuncs {
		for _, block := range fn.Blocks {
			for _, instr := range block.Instrs {
				if mc, ok := instr.(*ssa.MakeClosure); ok {
					innerFn := mc.Fn.(*ssa.Function)
					c.closureMap[mc] = innerFn
					c.closureRetFn[fn] = innerFn
					// Pre-allocate function tag for dynamic dispatch
					c.AllocClosureTag(innerFn)
				}
			}
		}
	}
}

func (c *Compiler) scanSysCalls(ssaProg *ssa.Program, pkg *ssa.Package) {
	c.scanSysCallsMulti(ssaProg, map[*ssa.Package]bool{pkg: true})
}

// scanSysCallsMulti scans all functions in the given user packages for Sys module calls.
func (c *Compiler) scanSysCallsMulti(ssaProg *ssa.Program, userPkgs map[*ssa.Package]bool) {
	// Always register print at index 0 (used by println builtin)
	c.sysUsed["print"] = 0

	// Scan all functions (including methods) for sys module calls
	allFns := ssautil.AllFunctions(ssaProg)
	for fn := range allFns {
		if fn.Package() == nil || !userPkgs[fn.Package()] {
			continue
		}
		for _, block := range fn.Blocks {
			for _, instr := range block.Instrs {
				call, ok := instr.(*ssa.Call)
				if !ok {
					continue
				}
				callee, ok := call.Call.Value.(*ssa.Function)
				if !ok {
					continue
				}
				if callee.Package() != nil && callee.Package().Pkg.Path() == "inferno/sys" {
					disName, ok := sysGoToDisName[callee.Name()]
					if ok {
						if _, exists := c.sysUsed[disName]; !exists {
							c.sysUsed[disName] = len(c.sysUsed)
						}
					}
				}
			}
		}
	}
}

func (c *Compiler) buildDataSection() []dis.DataItem {
	var items []dis.DataItem

	type strEntry struct {
		s   string
		off int32
	}
	var entries []strEntry
	for s, off := range c.strings {
		entries = append(entries, strEntry{s, off})
	}
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].off < entries[j].off
	})

	for _, e := range entries {
		items = append(items, dis.DefString(e.off, e.s))
	}

	// Float constants
	type realEntry struct {
		val float64
		off int32
	}
	var realEntries []realEntry
	for val, off := range c.reals {
		realEntries = append(realEntries, realEntry{val, off})
	}
	sort.Slice(realEntries, func(i, j int) bool {
		return realEntries[i].off < realEntries[j].off
	})
	for _, e := range realEntries {
		items = append(items, dis.DefReal(e.off, e.val))
	}

	return items
}

func (c *Compiler) buildLDT() [][]dis.Import {
	if len(c.sysUsed) == 0 {
		return nil
	}

	type entry struct {
		name string
		idx  int
	}
	var entries []entry
	for name, idx := range c.sysUsed {
		entries = append(entries, entry{name, idx})
	}
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].idx < entries[j].idx
	})

	var imports []dis.Import
	for _, e := range entries {
		sf := LookupSysFunc(e.name)
		if sf != nil {
			imports = append(imports, dis.Import{
				Sig:  sf.Sig,
				Name: sf.Name,
			})
		}
	}
	return [][]dis.Import{imports}
}

type stubImporter struct {
	sysPackage *types.Package // cached sys package
}

func (si *stubImporter) Import(path string) (*types.Package, error) {
	switch path {
	case "fmt":
		return buildFmtPackage(), nil
	case "strconv":
		return buildStrconvPackage(), nil
	case "errors":
		return buildErrorsPackage(), nil
	case "strings":
		return buildStringsPackage(), nil
	case "math":
		return buildMathPackage(), nil
	case "os":
		return buildOsPackage(), nil
	case "time":
		return buildTimePackage(), nil
	case "sync":
		return buildSyncPackage(), nil
	case "sort":
		return buildSortPackage(), nil
	case "io":
		return buildIOPackage(), nil
	case "log":
		return buildLogPackage(), nil
	case "unicode":
		return buildUnicodePackage(), nil
	case "unicode/utf8":
		return buildUTF8Package(), nil
	case "path":
		return buildPathPackage(), nil
	case "math/bits":
		return buildMathBitsPackage(), nil
	case "math/rand":
		return buildMathRandPackage(), nil
	case "bytes":
		return buildBytesPackage(), nil
	case "encoding/hex":
		return buildEncodingHexPackage(), nil
	case "encoding/base64":
		return buildEncodingBase64Package(), nil
	case "path/filepath":
		return buildFilepathPackage(), nil
	case "slices":
		return buildSlicesPackage(), nil
	case "maps":
		return buildMapsPackage(), nil
	case "cmp":
		return buildCmpPackage(), nil
	case "context":
		return buildContextPackage(), nil
	case "sync/atomic":
		return buildSyncAtomicPackage(), nil
	case "sync/errgroup":
		return buildSyncErrgroupPackage(), nil
	case "bufio":
		return buildBufioPackage(), nil
	case "net/url":
		return buildNetURLPackage(), nil
	case "encoding/json":
		return buildEncodingJSONPackage(), nil
	case "runtime":
		return buildRuntimePackage(), nil
	case "reflect":
		return buildReflectPackage(), nil
	case "testing":
		return buildTestingPackage(), nil
	case "os/exec":
		return buildOsExecPackage(), nil
	case "os/signal":
		return buildOsSignalPackage(), nil
	case "io/ioutil":
		return buildIOUtilPackage(), nil
	case "io/fs":
		return buildIOFSPackage(), nil
	case "regexp":
		return buildRegexpPackage(), nil
	case "net/http":
		return buildNetHTTPPackage(), nil
	case "log/slog":
		return buildLogSlogPackage(), nil
	case "flag":
		return buildFlagPackage(), nil
	case "crypto/sha256":
		return buildCryptoSHA256Package(), nil
	case "crypto/md5":
		return buildCryptoMD5Package(), nil
	case "encoding/binary":
		return buildEncodingBinaryPackage(), nil
	case "encoding/csv":
		return buildEncodingCSVPackage(), nil
	case "math/big":
		return buildMathBigPackage(), nil
	case "text/template":
		return buildTextTemplatePackage(), nil
	case "embed":
		return buildEmbedPackage(), nil
	case "hash":
		return buildHashPackage(), nil
	case "hash/crc32":
		return buildHashCRC32Package(), nil
	case "net":
		return buildNetPackage(), nil
	case "crypto/rand":
		return buildCryptoRandPackage(), nil
	case "crypto/hmac":
		return buildCryptoHMACPackage(), nil
	case "crypto/aes":
		return buildCryptoAESPackage(), nil
	case "crypto/cipher":
		return buildCryptoCipherPackage(), nil
	case "unicode/utf16":
		return buildUnicodeUTF16Package(), nil
	case "encoding/xml":
		return buildEncodingXMLPackage(), nil
	case "encoding/pem":
		return buildEncodingPEMPackage(), nil
	case "crypto/tls":
		return buildCryptoTLSPackage(), nil
	case "crypto/x509":
		return buildCryptoX509Package(), nil
	case "database/sql":
		return buildDatabaseSQLPackage(), nil
	case "archive/zip":
		return buildArchiveZipPackage(), nil
	case "archive/tar":
		return buildArchiveTarPackage(), nil
	case "compress/gzip":
		return buildCompressGzipPackage(), nil
	case "compress/flate":
		return buildCompressFlatePackage(), nil
	case "html":
		return buildHTMLPackage(), nil
	case "html/template":
		return buildHTMLTemplatePackage(), nil
	case "mime":
		return buildMIMEPackage(), nil
	case "mime/multipart":
		return buildMIMEMultipartPackage(), nil
	case "net/mail":
		return buildNetMailPackage(), nil
	case "net/textproto":
		return buildNetTextprotoPackage(), nil
	case "net/http/httputil":
		return buildNetHTTPUtilPackage(), nil
	case "crypto/elliptic":
		return buildCryptoEllipticPackage(), nil
	case "crypto/ecdsa":
		return buildCryptoECDSAPackage(), nil
	case "crypto/rsa":
		return buildCryptoRSAPackage(), nil
	case "crypto/ed25519":
		return buildCryptoEd25519Package(), nil
	case "crypto/sha512":
		return buildCryptoSHA512Package(), nil
	case "crypto/subtle":
		return buildCryptoSubtlePackage(), nil
	case "encoding/gob":
		return buildEncodingGobPackage(), nil
	case "encoding/ascii85":
		return buildEncodingASCII85Package(), nil
	case "container/list":
		return buildContainerListPackage(), nil
	case "container/ring":
		return buildContainerRingPackage(), nil
	case "container/heap":
		return buildContainerHeapPackage(), nil
	case "image":
		return buildImagePackage(), nil
	case "image/color":
		return buildImageColorPackage(), nil
	case "image/png":
		return buildImagePNGPackage(), nil
	case "image/jpeg":
		return buildImageJPEGPackage(), nil
	case "debug/buildinfo":
		return buildDebugBuildInfoPackage(), nil
	case "go/ast":
		return buildGoASTPackage(), nil
	case "go/token":
		return buildGoTokenPackage(), nil
	case "go/parser":
		return buildGoParserPackage(), nil
	case "go/format":
		return buildGoFormatPackage(), nil
	case "net/http/cookiejar":
		return buildNetHTTPCookiejarPackage(), nil
	case "net/http/pprof":
		return buildNetHTTPPprofPackage(), nil
	case "os/user":
		return buildOsUserPackage(), nil
	case "regexp/syntax":
		return buildRegexpSyntaxPackage(), nil
	case "runtime/debug":
		return buildRuntimeDebugPackage(), nil
	case "runtime/pprof":
		return buildRuntimePprofPackage(), nil
	case "text/scanner":
		return buildTextScannerPackage(), nil
	case "text/tabwriter":
		return buildTextTabwriterPackage(), nil
	case "crypto/sha1":
		return buildCryptoSHA1Package(), nil
	case "compress/zlib":
		return buildCompressZlibPackage(), nil
	case "compress/bzip2":
		return buildCompressBzip2Package(), nil
	case "compress/lzw":
		return buildCompressLzwPackage(), nil
	case "hash/fnv":
		return buildHashFNVPackage(), nil
	case "hash/maphash":
		return buildHashMaphashPackage(), nil
	case "image/draw":
		return buildImageDrawPackage(), nil
	case "image/gif":
		return buildImageGIFPackage(), nil
	case "expvar":
		return buildExpvarPackage(), nil
	case "log/syslog":
		return buildLogSyslogPackage(), nil
	case "index/suffixarray":
		return buildIndexSuffixarrayPackage(), nil
	case "go/printer":
		return buildGoPrinterPackage(), nil
	case "go/build":
		return buildGoBuildPackage(), nil
	case "go/types":
		return buildGoTypesPackage(), nil
	case "net/http/httptest":
		return buildNetHTTPTestPackage(), nil
	case "testing/fstest":
		return buildTestingFstestPackage(), nil
	case "testing/iotest":
		return buildTestingIotestPackage(), nil
	case "debug/elf":
		return buildDebugElfPackage(), nil
	case "debug/dwarf":
		return buildDebugDwarfPackage(), nil
	case "debug/pe":
		return buildDebugPEPackage(), nil
	case "debug/macho":
		return buildDebugMachoPackage(), nil
	case "debug/gosym":
		return buildDebugGosymPackage(), nil
	case "debug/plan9obj":
		return buildDebugPlan9objPackage(), nil
	case "encoding/base32":
		return buildEncodingBase32Package(), nil
	case "crypto/des":
		return buildCryptoDESPackage(), nil
	case "crypto/rc4":
		return buildCryptoRC4Package(), nil
	case "syscall":
		return buildSyscallPackage(), nil
	case "unsafe":
		return buildUnsafePackage(), nil
	case "math/cmplx":
		return buildMathCmplxPackage(), nil
	case "net/smtp":
		return buildNetSMTPPackage(), nil
	case "net/rpc":
		return buildNetRPCPackage(), nil
	case "text/template/parse":
		return buildTextTemplateParsePackage(), nil
	case "encoding/asn1":
		return buildEncodingASN1Package(), nil
	case "crypto/x509/pkix":
		return buildCryptoX509PkixPackage(), nil
	case "crypto/dsa":
		return buildCryptoDSAPackage(), nil
	case "net/rpc/jsonrpc":
		return buildNetRPCJSONRPCPackage(), nil
	case "crypto":
		return buildCryptoPackage(), nil
	case "hash/adler32":
		return buildHashAdler32Package(), nil
	case "hash/crc64":
		return buildHashCRC64Package(), nil
	case "encoding":
		return buildEncodingPackage(), nil
	case "go/constant":
		return buildGoConstantPackage(), nil
	case "go/scanner":
		return buildGoScannerPackage(), nil
	case "runtime/trace":
		return buildRuntimeTracePackage(), nil
	case "crypto/ecdh":
		return buildCryptoECDHPackage(), nil
	case "math/rand/v2":
		return buildMathRandV2Package(), nil
	case "database/sql/driver":
		return buildDatabaseSQLDriverPackage(), nil
	case "go/doc":
		return buildGoDocPackage(), nil
	case "net/netip":
		return buildNetNetipPackage(), nil
	case "iter":
		return buildIterPackage(), nil
	case "unique":
		return buildUniquePackage(), nil
	case "testing/quick":
		return buildTestingQuickPackage(), nil
	case "testing/slogtest":
		return buildTestingSlogtestPackage(), nil
	case "go/build/constraint":
		return buildGoBuildConstraintPackage(), nil
	case "go/doc/comment":
		return buildGoDocCommentPackage(), nil
	case "go/importer":
		return buildGoImporterPackage(), nil
	case "mime/quotedprintable":
		return buildMimeQuotedprintablePackage(), nil
	case "net/http/httptrace":
		return buildNetHTTPHttptracePackage(), nil
	case "net/http/cgi":
		return buildNetHTTPCgiPackage(), nil
	case "net/http/fcgi":
		return buildNetHTTPFcgiPackage(), nil
	case "image/color/palette":
		return buildImageColorPalettePackage(), nil
	case "runtime/metrics":
		return buildRuntimeMetricsPackage(), nil
	case "runtime/coverage":
		return buildRuntimeCoveragePackage(), nil
	case "plugin":
		return buildPluginPackage(), nil
	case "time/tzdata":
		return buildTimeTzdataPackage(), nil
	case "inferno/sys":
		if si.sysPackage != nil {
			return si.sysPackage, nil
		}
		si.sysPackage = buildSysPackage()
		return si.sysPackage, nil
	default:
		return nil, fmt.Errorf("unsupported import: %q", path)
	}
}

// buildErrorsPackage creates the type-checked errors package stub
// with the signature for New(text string) error.
func buildErrorsPackage() *types.Package {
	pkg := types.NewPackage("errors", "errors")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// func New(text string) error
	newSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, pkg, "text", types.Typ[types.String])),
		types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
		false)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "New", newSig))

	// func Is(err, target error) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Is",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "err", errType),
				types.NewVar(token.NoPos, pkg, "target", errType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Unwrap(err error) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Unwrap",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "err", errType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func As(err error, target any) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "As",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "err", errType),
				types.NewVar(token.NoPos, pkg, "target", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Join(errs ...error) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Join",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "errs",
				types.NewSlice(errType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	pkg.MarkComplete()
	return pkg
}

// RegisterErrorString registers the synthetic errorString type in the
// interface dispatch table. errorString.Error() is handled inline (fn=nil)
// rather than calling a real function.
func (c *Compiler) RegisterErrorString() {
	tag := c.AllocTypeTag("errorString")
	c.ifaceDispatch["Error"] = append(
		c.ifaceDispatch["Error"],
		ifaceImpl{tag: tag, fn: nil})
}

// buildStrconvPackage creates the type-checked strconv package stub
// with signatures for Itoa, Atoi, FormatInt, FormatBool, ParseBool, etc.
func buildStrconvPackage() *types.Package {
	pkg := types.NewPackage("strconv", "strconv")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// func Itoa(i int) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Itoa",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "i", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Atoi(s string) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Atoi",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func FormatInt(i int64, base int) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatInt",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "i", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "base", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func FormatBool(b bool) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatBool",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "b", types.Typ[types.Bool])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func ParseBool(str string) (bool, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseBool",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "str", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func FormatFloat(f float64, fmt byte, prec, bitSize int) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatFloat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "f", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "fmt", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "prec", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "bitSize", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func ParseInt(s string, base int, bitSize int) (int64, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseInt",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "base", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "bitSize", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ParseUint(s string, base int, bitSize int) (uint64, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseUint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "base", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "bitSize", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint64]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func FormatUint(i uint64, base int) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatUint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "i", types.Typ[types.Uint64]),
				types.NewVar(token.NoPos, pkg, "base", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Quote(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Quote",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Unquote(s string) (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Unquote",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func AppendInt(dst []byte, i int64, base int) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendInt",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "i", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "base", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			false)))

	// func ParseFloat(s string, bitSize int) (float64, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseFloat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "bitSize", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	byteSlice := types.NewSlice(types.Typ[types.Byte])
	strToStr := func(name string) {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
				false)))
	}
	strToStr("QuoteToASCII")
	strToStr("QuoteToGraphic")

	// func QuoteRune(r rune) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "QuoteRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func QuoteRuneToASCII(r rune) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "QuoteRuneToASCII",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func QuoteRuneToGraphic(r rune) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "QuoteRuneToGraphic",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func CanBackquote(s string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CanBackquote",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func IsPrint(r rune) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsPrint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func IsGraphic(r rune) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsGraphic",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "UnquoteChar",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "quote", types.Typ[types.Byte])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Rune]),
				types.NewVar(token.NoPos, pkg, "multibyte", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, pkg, "tail", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Append functions
	// func AppendBool(dst []byte, b bool) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendBool",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", byteSlice),
				types.NewVar(token.NoPos, pkg, "b", types.Typ[types.Bool])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendFloat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", byteSlice),
				types.NewVar(token.NoPos, pkg, "f", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "fmt", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "prec", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "bitSize", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func AppendQuote(dst []byte, s string) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendQuote",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", byteSlice),
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func AppendQuoteRune(dst []byte, r rune) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendQuoteRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", byteSlice),
				types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func AppendQuoteToASCII(dst []byte, s string) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendQuoteToASCII",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", byteSlice),
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func AppendQuoteRuneToASCII(dst []byte, r rune) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendQuoteRuneToASCII",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", byteSlice),
				types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func AppendQuoteToGraphic(dst []byte, s string) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendQuoteToGraphic",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", byteSlice),
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendQuoteRuneToGraphic",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", byteSlice),
				types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func AppendUint(dst []byte, i uint64, base int) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendUint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", byteSlice),
				types.NewVar(token.NoPos, pkg, "i", types.Typ[types.Uint64]),
				types.NewVar(token.NoPos, pkg, "base", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func FormatComplex(c complex128, fmt byte, prec, bitSize int) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatComplex",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "c", types.Typ[types.Complex128]),
				types.NewVar(token.NoPos, pkg, "fmt", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "prec", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "bitSize", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func ParseComplex(s string, bitSize int) (complex128, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseComplex",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "bitSize", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Complex128]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Error types
	numErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Func", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Num", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Err", errType, false),
	}, nil)
	numErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "NumError", nil),
		numErrStruct, nil)
	scope.Insert(numErrType.Obj())
	numErrPtr := types.NewPointer(numErrType)
	numErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "e", numErrPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	numErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Unwrap",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "e", numErrPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// Sentinel errors
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrRange", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrSyntax", errType))

	// Constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "IntSize", types.Typ[types.UntypedInt], constant.MakeInt64(64)))

	pkg.MarkComplete()
	return pkg
}

// buildFmtPackage creates the type-checked fmt package stub
// with signatures for Sprintf, Printf, and Println.
func buildFmtPackage() *types.Package {
	pkg := types.NewPackage("fmt", "fmt")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	anySlice := types.NewSlice(types.NewInterfaceType(nil, nil))

	// func Sprintf(format string, a ...any) string
	sprintfSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "format", types.Typ[types.String]),
			types.NewVar(token.NoPos, pkg, "a", anySlice),
		),
		types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sprintf", sprintfSig))

	// func Printf(format string, a ...any) (int, error)
	printfSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "format", types.Typ[types.String]),
			types.NewVar(token.NoPos, pkg, "a", anySlice),
		),
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
			types.NewVar(token.NoPos, pkg, "", errType),
		),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Printf", printfSig))

	// func Println(a ...any) (int, error)
	printlnSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, pkg, "a", anySlice)),
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
			types.NewVar(token.NoPos, pkg, "", errType),
		),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Println", printlnSig))

	// func Errorf(format string, a ...any) error
	errorfSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "format", types.Typ[types.String]),
			types.NewVar(token.NoPos, pkg, "a", anySlice),
		),
		types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Errorf", errorfSig))

	// func Sprint(a ...any) string
	sprintSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, pkg, "a", anySlice)),
		types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sprint", sprintSig))

	// func Print(a ...any) (int, error)
	printSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, pkg, "a", anySlice)),
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
			types.NewVar(token.NoPos, pkg, "", errType),
		),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Print", printSig))

	// io.Writer interface for Fprint/Fprintf/Fprintln
	writerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte]))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	writerIface.Complete()

	// func Fprintf(w io.Writer, format string, a ...any) (int, error)
	fprintfSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "w", writerIface),
			types.NewVar(token.NoPos, pkg, "format", types.Typ[types.String]),
			types.NewVar(token.NoPos, pkg, "a", anySlice),
		),
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
			types.NewVar(token.NoPos, pkg, "", errType),
		),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fprintf", fprintfSig))

	// func Fprintln(w io.Writer, a ...any) (int, error)
	fprintlnSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "w", writerIface),
			types.NewVar(token.NoPos, pkg, "a", anySlice),
		),
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
			types.NewVar(token.NoPos, pkg, "", errType),
		),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fprintln", fprintlnSig))

	// func Fprint(w io.Writer, a ...any) (int, error)
	fprintSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "w", writerIface),
			types.NewVar(token.NoPos, pkg, "a", anySlice),
		),
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
			types.NewVar(token.NoPos, pkg, "", errType),
		),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fprint", fprintSig))

	// func Sprintln(a ...any) string
	sprintlnSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, pkg, "a", anySlice)),
		types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sprintln", sprintlnSig))

	// func Sscan(str string, a ...any) (int, error)
	sscanSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "str", types.Typ[types.String]),
			types.NewVar(token.NoPos, pkg, "a", anySlice)),
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
			types.NewVar(token.NoPos, pkg, "", errType)),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sscan", sscanSig))

	// func Sscanf(str string, format string, a ...any) (int, error)
	sscanfSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "str", types.Typ[types.String]),
			types.NewVar(token.NoPos, pkg, "format", types.Typ[types.String]),
			types.NewVar(token.NoPos, pkg, "a", anySlice)),
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
			types.NewVar(token.NoPos, pkg, "", errType)),
		true)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sscanf", sscanfSig))

	// type Stringer interface { String() string }
	stringerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "String",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
				false)),
	}, nil)
	stringerIface.Complete()
	stringerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Stringer", nil),
		stringerIface, nil)
	scope.Insert(stringerType.Obj())

	// type GoStringer interface { GoString() string }
	goStringerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "GoString",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
				false)),
	}, nil)
	goStringerIface.Complete()
	goStringerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "GoStringer", nil),
		goStringerIface, nil)
	scope.Insert(goStringerType.Obj())

	// type State interface { Write, Width, Precision, Flag }
	byteSliceForState := types.NewSlice(types.Typ[types.Byte])
	stateIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSliceForState)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "", errType)), false)),
		types.NewFunc(token.NoPos, pkg, "Width",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "wid", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "ok", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Precision",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "prec", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "ok", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Flag",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "c", types.Typ[types.Int])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
	}, nil)
	stateIface.Complete()
	stateType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "State", nil), stateIface, nil)
	scope.Insert(stateType.Obj())

	// type Formatter interface { Format(f State, verb rune) }
	formatterIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Format",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "f", stateType),
					types.NewVar(token.NoPos, nil, "verb", types.Typ[types.Rune])),
				nil, false)),
	}, nil)
	formatterIface.Complete()
	formatterType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Formatter", nil), formatterIface, nil)
	scope.Insert(formatterType.Obj())

	// type ScanState interface { ReadRune, UnreadRune, SkipSpace, Token, Width, Read }
	scanStateIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadRune",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "r", types.Typ[types.Rune]),
					types.NewVar(token.NoPos, nil, "size", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)), false)),
		types.NewFunc(token.NoPos, pkg, "UnreadRune",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)), false)),
		types.NewFunc(token.NoPos, pkg, "SkipSpace",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, pkg, "Token",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "skipSpace", types.Typ[types.Bool]),
					types.NewVar(token.NoPos, nil, "f",
						types.NewSignatureType(nil, nil, nil,
							types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Rune])),
							types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "token", types.NewSlice(types.Typ[types.Byte])),
					types.NewVar(token.NoPos, nil, "err", errType)), false)),
		types.NewFunc(token.NoPos, pkg, "Width",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "wid", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "ok", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "buf", types.NewSlice(types.Typ[types.Byte]))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)), false)),
	}, nil)
	scanStateIface.Complete()
	scanStateType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "ScanState", nil), scanStateIface, nil)
	scope.Insert(scanStateType.Obj())

	// type Scanner interface { Scan(state ScanState, verb rune) error }
	scannerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Scan",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "state", scanStateType),
					types.NewVar(token.NoPos, nil, "verb", types.Typ[types.Rune])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)), false)),
	}, nil)
	scannerIface.Complete()
	scannerType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Scanner", nil), scannerIface, nil)
	scope.Insert(scannerType.Obj())

	// io.Reader interface for Fscan/Fscanf/Fscanln
	readerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte]))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	readerIface.Complete()

	// func Scan(a ...any) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Scan",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "a", anySlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// func Scanf(format string, a ...any) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Scanf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "a", anySlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// func Scanln(a ...any) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Scanln",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "a", anySlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// func Sscanln(str string, a ...any) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sscanln",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "str", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "a", anySlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// func Fscan(r io.Reader, a ...any) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fscan",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", readerIface),
				types.NewVar(token.NoPos, pkg, "a", anySlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// func Fscanf(r io.Reader, format string, a ...any) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fscanf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", readerIface),
				types.NewVar(token.NoPos, pkg, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "a", anySlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// func Fscanln(r io.Reader, a ...any) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fscanln",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", readerIface),
				types.NewVar(token.NoPos, pkg, "a", anySlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// func Appendf(b []byte, format string, a ...any) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Appendf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "a", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			true)))

	// func Append(b []byte, a ...any) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Append",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "a", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			true)))

	// func Appendln(b []byte, a ...any) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Appendln",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "a", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			true)))

	// FormatString(state State, verb rune) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "state", stateType),
				types.NewVar(token.NoPos, pkg, "verb", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildSysPackage creates the type-checked inferno/sys package with
// FD type and function signatures matching the Inferno Sys module.
func buildSysPackage() *types.Package {
	pkg := types.NewPackage("inferno/sys", "sys")

	// FD type: opaque struct wrapping a file descriptor
	fdStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "fd", types.Typ[types.Int], false),
	}, nil)
	fdNamed := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "FD", nil), fdStruct, nil)
	fdPtr := types.NewPointer(fdNamed)

	scope := pkg.Scope()
	scope.Insert(fdNamed.Obj())

	// Fildes(fd int) *FD
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fildes",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "fd", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", fdPtr)),
			false)))

	// Open(name string, mode int) *FD
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Open",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "mode", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", fdPtr)),
			false)))

	// Write(fd *FD, buf []byte, n int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "fd", fdPtr),
				types.NewVar(token.NoPos, nil, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Read(fd *FD, buf []byte, n int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "fd", fdPtr),
				types.NewVar(token.NoPos, nil, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Fprint(fd *FD, s string, args ...any) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fprint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "fd", fdPtr),
				types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Sleep(ms int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sleep",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "ms", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Millisec() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Millisec",
		types.NewSignatureType(nil, nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Create(name string, mode int, perm int) *FD
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Create",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "mode", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "perm", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", fdPtr)),
			false)))

	// Seek(fd *FD, off int, start int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Seek",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "fd", fdPtr),
				types.NewVar(token.NoPos, nil, "off", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "start", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Bind(name string, old string, flags int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Bind",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "old", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "flags", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Chdir(path string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Chdir",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Remove(name string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Remove",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Pipe(fds []FD) int — simplified: takes slice of *FD, returns int
	// In Limbo: pipe(fds: array of ref FD): int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Pipe",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "fds", types.NewSlice(fdPtr))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Dup(old int, new int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Dup",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "old", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "new_", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Pctl(flags int, movefd []int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Pctl",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "flags", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "movefd", types.NewSlice(types.Typ[types.Int]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Constants: OREAD=0, OWRITE=1, ORDWR=2, OTRUNC=16, ORCLOSE=64, OEXCL=4096
	scope.Insert(types.NewConst(token.NoPos, pkg, "OREAD", types.Typ[types.Int], constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "OWRITE", types.Typ[types.Int], constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ORDWR", types.Typ[types.Int], constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "OTRUNC", types.Typ[types.Int], constant.MakeInt64(16)))

	// Bind flags
	scope.Insert(types.NewConst(token.NoPos, pkg, "MREPL", types.Typ[types.Int], constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MBEFORE", types.Typ[types.Int], constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MAFTER", types.Typ[types.Int], constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MCREATE", types.Typ[types.Int], constant.MakeInt64(4)))

	// Pctl flags
	scope.Insert(types.NewConst(token.NoPos, pkg, "NEWPGRP", types.Typ[types.Int], constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "FORKNS", types.Typ[types.Int], constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "FORKFD", types.Typ[types.Int], constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "NEWFD", types.Typ[types.Int], constant.MakeInt64(8)))

	// Seek constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "SEEKSTART", types.Typ[types.Int], constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SEEKRELA", types.Typ[types.Int], constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SEEKEND", types.Typ[types.Int], constant.MakeInt64(2)))

	pkg.MarkComplete()
	return pkg
}

// buildStringsPackage creates the type-checked strings package stub.
func buildStringsPackage() *types.Package {
	pkg := types.NewPackage("strings", "strings")
	scope := pkg.Scope()

	// func Contains(s, substr string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Contains",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "substr", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func HasPrefix(s, prefix string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "HasPrefix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "prefix", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func HasSuffix(s, suffix string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "HasSuffix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "suffix", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Index(s, substr string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Index",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "substr", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func TrimSpace(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimSpace",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Split(s, sep string) []string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Split",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "sep", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// func Join(elems []string, sep string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Join",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "elems", types.NewSlice(types.Typ[types.String])),
				types.NewVar(token.NoPos, pkg, "sep", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Replace(s, old, new string, n int) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Replace",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "old", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "new", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func ToUpper(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ToUpper",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func ToLower(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ToLower",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Repeat(s string, count int) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Repeat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "count", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Count(s, substr string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Count",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "substr", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func EqualFold(s, t string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EqualFold",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "t", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Fields(s string) []string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fields",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// func Trim(s string, cutset string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Trim",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "cutset", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func TrimLeft(s string, cutset string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimLeft",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "cutset", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func TrimRight(s string, cutset string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimRight",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "cutset", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func TrimPrefix(s, prefix string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimPrefix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "prefix", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func TrimSuffix(s, suffix string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimSuffix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "suffix", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func ReplaceAll(s, old, new string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReplaceAll",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "old", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "new", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func ContainsRune(s string, r rune) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ContainsRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func ContainsAny(s, chars string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ContainsAny",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "chars", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func IndexByte(s string, c byte) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IndexByte",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "c", types.Typ[types.Byte])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func IndexRune(s string, r rune) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IndexRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func LastIndex(s, substr string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LastIndex",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "substr", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Title(s string) string (deprecated but still used)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Title",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Map(mapping func(rune) rune, s string) string
	mapFuncSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
		types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Rune])),
		false)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Map",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "mapping", mapFuncSig),
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func NewReader(s string) *Reader
	readerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "s", types.Typ[types.String], false),
	}, nil)
	readerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Reader", nil),
		readerStruct, nil)
	scope.Insert(readerType.Obj())
	readerPtr := types.NewPointer(readerType)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", readerPtr)),
			false)))

	// type Builder struct { ... }
	builderStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "buf", types.Typ[types.String], false),
	}, nil)
	builderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Builder", nil),
		builderStruct, nil)
	scope.Insert(builderType.Obj())
	builderPtr := types.NewPointer(builderType)
	builderType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteString",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "b", builderPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))
	builderType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "b", builderPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	builderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Len",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "b", builderPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	builderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "b", builderPtr),
			nil, nil, nil, nil, false)))
	builderType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteByte",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "b", builderPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "c", types.Typ[types.Byte])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))
	builderType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteRune",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "b", builderPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "r", types.Typ[types.Rune])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))

	// func NewReplacer(oldnew ...string) *Replacer
	replacerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "r", types.Typ[types.Int], false),
	}, nil)
	replacerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Replacer", nil),
		replacerStruct, nil)
	scope.Insert(replacerType.Obj())
	replacerPtr := types.NewPointer(replacerType)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReplacer",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "oldnew",
				types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", replacerPtr)),
			true)))

	// func Cut(s, sep string) (before, after string, found bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Cut",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "sep", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "before", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "after", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "found", types.Typ[types.Bool])),
			false)))

	// func CutPrefix(s, prefix string) (after string, found bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CutPrefix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "prefix", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "after", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "found", types.Typ[types.Bool])),
			false)))

	// func CutSuffix(s, suffix string) (before string, found bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CutSuffix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "suffix", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "before", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "found", types.Typ[types.Bool])),
			false)))

	// func Clone(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Clone",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func SplitN(s, sep string, n int) []string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SplitN",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "sep", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// func SplitAfter(s, sep string) []string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SplitAfter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "sep", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// func SplitAfterN(s, sep string, n int) []string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SplitAfterN",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "sep", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// func ToTitle(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ToTitle",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func ToValidUTF8(s, replacement string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ToValidUTF8",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "replacement", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func IndexAny(s, chars string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IndexAny",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "chars", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func LastIndexByte(s string, c byte) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LastIndexByte",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "c", types.Typ[types.Byte])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func LastIndexAny(s, chars string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LastIndexAny",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "chars", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func IndexFunc(s string, f func(rune) bool) int
	runePredSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, nil, "r", types.Typ[types.Rune])),
		types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
		false)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IndexFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "f", runePredSig)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func LastIndexFunc(s string, f func(rune) bool) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LastIndexFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "f", runePredSig)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func FieldsFunc(s string, f func(rune) bool) []string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FieldsFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "f", runePredSig)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// func ContainsFunc(s string, f func(rune) bool) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ContainsFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "f", runePredSig)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Compare(a, b string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Compare",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "a", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "b", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func TrimFunc(s string, f func(rune) bool) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "f", runePredSig)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func TrimLeftFunc(s string, f func(rune) bool) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimLeftFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "f", runePredSig)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func TrimRightFunc(s string, f func(rune) bool) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimRightFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "f", runePredSig)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// Builder additional methods: Write, Grow, Cap
	builderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "b", builderPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))
	builderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Grow",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "b", builderPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			nil, false)))
	builderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cap",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "b", builderPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Replacer methods: Replace, WriteString
	replacerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Replace",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", replacerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	// io.Writer interface for WriteString
	strWriterIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte]))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", types.Universe.Lookup("error").Type())),
				false)),
	}, nil)
	strWriterIface.Complete()
	replacerType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteString",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", replacerPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "w", strWriterIface),
				types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))

	// Reader methods: Read, ReadByte, ReadRune, UnreadByte, UnreadRune, Len, Size, Reset, Seek, WriteTo, ReadAt
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadByte",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadRune",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Rune]),
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnreadByte",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnreadRune",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Len",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Size",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			nil, false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Seek",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "offset", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "whence", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteTo",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "w", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadAt",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "b", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "off", types.Typ[types.Int64])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildMathPackage creates the type-checked math package stub.
func buildMathPackage() *types.Package {
	pkg := types.NewPackage("math", "math")
	scope := pkg.Scope()

	// func Abs(x float64) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Abs",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func Sqrt(x float64) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sqrt",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func Min(x, y float64) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Min",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "y", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func Max(x, y float64) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Max",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "y", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	f64f64 := func(name string) {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
				false)))
	}
	f64f64("Floor")
	f64f64("Ceil")
	f64f64("Round")
	f64f64("Trunc")
	f64f64("Log")
	f64f64("Log2")
	f64f64("Log10")
	f64f64("Exp")
	f64f64("Sin")
	f64f64("Cos")
	f64f64("Tan")

	f64f64f64 := func(name string) {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64]),
					types.NewVar(token.NoPos, pkg, "y", types.Typ[types.Float64])),
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
				false)))
	}
	f64f64f64("Pow")
	f64f64f64("Mod")
	f64f64f64("Remainder")
	f64f64f64("Dim")
	f64f64f64("Copysign")
	f64f64f64("Atan2")
	f64f64f64("Hypot")
	f64f64f64("Nextafter")

	// More unary float64 → float64 functions
	f64f64("Asin")
	f64f64("Acos")
	f64f64("Atan")
	f64f64("Sinh")
	f64f64("Cosh")
	f64f64("Tanh")
	f64f64("Asinh")
	f64f64("Acosh")
	f64f64("Atanh")
	f64f64("Exp2")
	f64f64("Expm1")
	f64f64("Log1p")
	f64f64("Logb")
	f64f64("Cbrt")
	f64f64("Erf")
	f64f64("Erfc")
	f64f64("Erfcinv")
	f64f64("Erfinv")
	f64f64("Gamma")
	f64f64("J0")
	f64f64("J1")
	f64f64("Y0")
	f64f64("Y1")
	f64f64("RoundToEven")

	// func Pow10(n int) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Pow10",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func Ilogb(x float64) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Ilogb",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Ldexp(frac float64, exp int) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Ldexp",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "frac", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "exp", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func Frexp(f float64) (frac float64, exp int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Frexp",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "f", types.Typ[types.Float64])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "frac", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "exp", types.Typ[types.Int])),
			false)))

	// func Modf(f float64) (int float64, frac float64)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Modf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "f", types.Typ[types.Float64])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "i", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "frac", types.Typ[types.Float64])),
			false)))

	// func Sincos(x float64) (sin, cos float64)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sincos",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "sin", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "cos", types.Typ[types.Float64])),
			false)))

	// func Lgamma(x float64) (lgamma float64, sign int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Lgamma",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "lgamma", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "sign", types.Typ[types.Int])),
			false)))

	// func Jn(n int, x float64) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Jn",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func Yn(n int, x float64) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Yn",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func FMA(x, y, z float64) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FMA",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "y", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "z", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func Float32bits(f float32) uint32
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Float32bits",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "f", types.Typ[types.Float32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint32])),
			false)))

	// func Float32frombits(b uint32) float32
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Float32frombits",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "b", types.Typ[types.Uint32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float32])),
			false)))

	// func Inf(sign int) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Inf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "sign", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func NaN() float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NaN",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func IsNaN(f float64) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsNaN",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "f", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func IsInf(f float64, sign int) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsInf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "f", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "sign", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Signbit(x float64) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Signbit",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Float64bits(f float64) uint64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Float64bits",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "f", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint64])),
			false)))

	// func Float64frombits(b uint64) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Float64frombits",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "b", types.Typ[types.Uint64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// Constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "Pi", types.Typ[types.UntypedFloat], constant.MakeFloat64(3.141592653589793)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "E", types.Typ[types.UntypedFloat], constant.MakeFloat64(2.718281828459045)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Phi", types.Typ[types.UntypedFloat], constant.MakeFloat64(1.618033988749895)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Ln2", types.Typ[types.UntypedFloat], constant.MakeFloat64(0.6931471805599453)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Ln10", types.Typ[types.UntypedFloat], constant.MakeFloat64(2.302585092994046)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Log2E", types.Typ[types.UntypedFloat], constant.MakeFloat64(1.4426950408889634)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Log10E", types.Typ[types.UntypedFloat], constant.MakeFloat64(0.4342944819032518)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxFloat64", types.Typ[types.UntypedFloat], constant.MakeFloat64(1.7976931348623157e+308)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SmallestNonzeroFloat64", types.Typ[types.UntypedFloat], constant.MakeFloat64(5e-324)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxFloat32", types.Typ[types.UntypedFloat], constant.MakeFloat64(3.4028234663852886e+38)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SmallestNonzeroFloat32", types.Typ[types.UntypedFloat], constant.MakeFloat64(1.401298464324817e-45)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxInt", types.Typ[types.UntypedInt], constant.MakeInt64(9223372036854775807)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MinInt", types.Typ[types.UntypedInt], constant.MakeInt64(-9223372036854775808)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxInt8", types.Typ[types.UntypedInt], constant.MakeInt64(127)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MinInt8", types.Typ[types.UntypedInt], constant.MakeInt64(-128)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxInt16", types.Typ[types.UntypedInt], constant.MakeInt64(32767)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MinInt16", types.Typ[types.UntypedInt], constant.MakeInt64(-32768)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxInt32", types.Typ[types.UntypedInt], constant.MakeInt64(2147483647)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MinInt32", types.Typ[types.UntypedInt], constant.MakeInt64(-2147483648)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxInt64", types.Typ[types.UntypedInt], constant.MakeInt64(9223372036854775807)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxUint8", types.Typ[types.UntypedInt], constant.MakeInt64(255)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxUint16", types.Typ[types.UntypedInt], constant.MakeInt64(65535)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxUint32", types.Typ[types.UntypedInt], constant.MakeInt64(4294967295)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Sqrt2", types.Typ[types.UntypedFloat], constant.MakeFloat64(1.4142135623730951)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SqrtE", types.Typ[types.UntypedFloat], constant.MakeFloat64(1.6487212707001282)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SqrtPi", types.Typ[types.UntypedFloat], constant.MakeFloat64(1.7724538509055159)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SqrtPhi", types.Typ[types.UntypedFloat], constant.MakeFloat64(1.272019649514069)))

	pkg.MarkComplete()
	return pkg
}

// buildOsPackage creates the type-checked os package stub.
func buildOsPackage() *types.Package {
	pkg := types.NewPackage("os", "os")
	scope := pkg.Scope()

	// func Exit(code int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Exit",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "code", types.Typ[types.Int])),
			nil,
			false)))

	// func Getenv(key string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Getenv",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Getwd() (string, error)
	errType := types.Universe.Lookup("error").Type()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Getwd",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// var Args []string
	scope.Insert(types.NewVar(token.NoPos, pkg, "Args", types.NewSlice(types.Typ[types.String])))

	// var Stdin, Stdout, Stderr *File (simplified as int for now)
	fileStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "fd", types.Typ[types.Int], false),
	}, nil)
	fileType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "File", nil),
		fileStruct, nil)
	scope.Insert(fileType.Obj())
	filePtr := types.NewPointer(fileType)
	scope.Insert(types.NewVar(token.NoPos, pkg, "Stdin", filePtr))
	scope.Insert(types.NewVar(token.NoPos, pkg, "Stdout", filePtr))
	scope.Insert(types.NewVar(token.NoPos, pkg, "Stderr", filePtr))

	// func Mkdir(name string, perm uint32) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Mkdir",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "perm", types.Typ[types.Uint32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Remove(name string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Remove",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ReadFile(name string) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadFile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func WriteFile(name string, data []byte, perm uint32) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WriteFile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "perm", types.Typ[types.Uint32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Chdir(dir string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Chdir",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "dir", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Rename(oldpath, newpath string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Rename",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "oldpath", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "newpath", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func MkdirAll(path string, perm uint32) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MkdirAll",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "perm", types.Typ[types.Uint32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func RemoveAll(path string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "RemoveAll",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func TempDir() string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TempDir",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func UserHomeDir() (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "UserHomeDir",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Environ() []string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Environ",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// func Setenv(key, value string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Setenv",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func IsNotExist(err error) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsNotExist",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "err", errType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func IsExist(err error) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsExist",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "err", errType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func IsPermission(err error) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsPermission",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "err", errType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// type FileMode uint32
	fileModeType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FileMode", nil),
		types.Typ[types.Uint32], nil)
	scope.Insert(fileModeType.Obj())

	// FileMode constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeDir", fileModeType, constant.MakeInt64(1<<31)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModePerm", fileModeType, constant.MakeInt64(0777)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeAppend", fileModeType, constant.MakeInt64(1<<30)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeExclusive", fileModeType, constant.MakeInt64(1<<29)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeTemporary", fileModeType, constant.MakeInt64(1<<28)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeSymlink", fileModeType, constant.MakeInt64(1<<27)))

	// Open flags
	scope.Insert(types.NewConst(token.NoPos, pkg, "O_RDONLY", types.Typ[types.Int], constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "O_WRONLY", types.Typ[types.Int], constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "O_RDWR", types.Typ[types.Int], constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "O_APPEND", types.Typ[types.Int], constant.MakeInt64(1024)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "O_CREATE", types.Typ[types.Int], constant.MakeInt64(64)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "O_EXCL", types.Typ[types.Int], constant.MakeInt64(128)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "O_SYNC", types.Typ[types.Int], constant.MakeInt64(4096)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "O_TRUNC", types.Typ[types.Int], constant.MakeInt64(512)))

	// Seek constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "SEEK_SET", types.Typ[types.Int], constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SEEK_CUR", types.Typ[types.Int], constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SEEK_END", types.Typ[types.Int], constant.MakeInt64(2)))

	// type FileInfo interface (fs.FileInfo compatible)
	anyTypeOs := types.NewInterfaceType(nil, nil)
	anyTypeOs.Complete()
	fileInfoIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Name",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)),
		types.NewFunc(token.NoPos, pkg, "Size",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])), false)),
		types.NewFunc(token.NoPos, pkg, "Mode",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", fileModeType)), false)),
		types.NewFunc(token.NoPos, pkg, "ModTime",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])), false)),
		types.NewFunc(token.NoPos, pkg, "IsDir",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Sys",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", anyTypeOs)), false)),
	}, nil)
	fileInfoIface.Complete()
	fileInfoType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FileInfo", nil),
		fileInfoIface, nil)
	scope.Insert(fileInfoType.Obj())

	// type DirEntry interface
	dirEntryIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Name",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)),
		types.NewFunc(token.NoPos, pkg, "IsDir",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Type",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", fileModeType)), false)),
		types.NewFunc(token.NoPos, pkg, "Info",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", fileInfoIface),
					types.NewVar(token.NoPos, nil, "", errType)), false)),
	}, nil)
	dirEntryIface.Complete()
	dirEntryType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "DirEntry", nil),
		dirEntryIface, nil)
	scope.Insert(dirEntryType.Obj())

	// type PathError struct
	pathErrorType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "PathError", nil),
		types.NewStruct([]*types.Var{
			types.NewField(token.NoPos, pkg, "Op", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "Path", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "Err", errType, false),
		}, nil), nil)
	scope.Insert(pathErrorType.Obj())
	pathErrorPtr := types.NewPointer(pathErrorType)

	// PathError.Error() string
	pathErrorType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(
			types.NewVar(token.NoPos, pkg, "e", pathErrorPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// PathError.Unwrap() error
	pathErrorType.AddMethod(types.NewFunc(token.NoPos, pkg, "Unwrap",
		types.NewSignatureType(
			types.NewVar(token.NoPos, pkg, "e", pathErrorPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// PathError.Timeout() bool
	pathErrorType.AddMethod(types.NewFunc(token.NoPos, pkg, "Timeout",
		types.NewSignatureType(
			types.NewVar(token.NoPos, pkg, "e", pathErrorPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// type LinkError struct
	linkErrorType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "LinkError", nil),
		types.NewStruct([]*types.Var{
			types.NewField(token.NoPos, pkg, "Op", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "Old", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "New", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "Err", errType, false),
		}, nil), nil)
	scope.Insert(linkErrorType.Obj())
	linkErrorPtr := types.NewPointer(linkErrorType)

	// LinkError.Error() string
	linkErrorType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(
			types.NewVar(token.NoPos, pkg, "e", linkErrorPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// LinkError.Unwrap() error
	linkErrorType.AddMethod(types.NewFunc(token.NoPos, pkg, "Unwrap",
		types.NewSignatureType(
			types.NewVar(token.NoPos, pkg, "e", linkErrorPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// type Signal interface { String, Signal }
	signalIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "String",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)),
		types.NewFunc(token.NoPos, pkg, "Signal",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
	}, nil)
	signalIface.Complete()
	signalType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Signal", nil),
		signalIface, nil)
	scope.Insert(signalType.Obj())

	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// func Open(name string) (*File, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Open",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", filePtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Create(name string) (*File, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Create",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", filePtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func OpenFile(name string, flag int, perm FileMode) (*File, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "OpenFile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "flag", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "perm", fileModeType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", filePtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Stat(name string) (FileInfo, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Stat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", fileInfoType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Lstat(name string) (FileInfo, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Lstat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", fileInfoType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ReadDir(name string) ([]DirEntry, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadDir",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(dirEntryType)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Hostname() (name string, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Hostname",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func LookupEnv(key string) (string, bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LookupEnv",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Executable() (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Executable",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func CreateTemp(dir, pattern string) (*File, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CreateTemp",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dir", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", filePtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func MkdirTemp(dir, pattern string) (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MkdirTemp",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dir", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Unsetenv(key string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Unsetenv",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Getpid() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Getpid",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Getuid() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Getuid",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Getgid() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Getgid",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Getppid() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Getppid",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Getegid() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Getegid",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Geteuid() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Geteuid",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Getgroups() ([]int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Getgroups",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Int])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Clearenv()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Clearenv",
		types.NewSignatureType(nil, nil, nil, nil, nil, false)))

	// var ErrNotExist, ErrExist, ErrPermission, ErrClosed error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrNotExist", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrExist", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrPermission", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrClosed", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrInvalid", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrDeadlineExceeded", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrProcessDone", errType))

	// const DevNull = "/dev/null"
	scope.Insert(types.NewConst(token.NoPos, pkg, "DevNull", types.Typ[types.String], constant.MakeString("/dev/null")))
	// const PathSeparator = '/'
	scope.Insert(types.NewConst(token.NoPos, pkg, "PathSeparator", types.Typ[types.Rune], constant.MakeInt64('/')))
	// const PathListSeparator = ':'
	scope.Insert(types.NewConst(token.NoPos, pkg, "PathListSeparator", types.Typ[types.Rune], constant.MakeInt64(':')))

	// File methods
	fileRecv := types.NewVar(token.NoPos, pkg, "f", filePtr)

	// (*File).Read(b []byte) (n int, err error)
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))

	// (*File).Write(b []byte) (n int, err error)
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))

	// (*File).WriteString(s string) (n int, err error)
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteString",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))

	// (*File).Close() error
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(fileRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*File).Name() string
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Name",
		types.NewSignatureType(fileRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// (*File).Stat() (FileInfo, error)
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Stat",
		types.NewSignatureType(fileRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", fileInfoType),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*File).Seek(offset int64, whence int) (int64, error)
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Seek",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "offset", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "whence", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*File).Sync() error
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Sync",
		types.NewSignatureType(fileRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*File).Chmod(mode FileMode) error
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Chmod",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "mode", fileModeType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*File).ReadDir(n int) ([]DirEntry, error)
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadDir",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(dirEntryType)),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*File).Fd() uintptr
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fd",
		types.NewSignatureType(fileRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uintptr])),
			false)))

	// (*File).Truncate(size int64) error
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Truncate",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "size", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*File).WriteAt(b []byte, off int64) (n int, err error)
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteAt",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "b", byteSlice),
				types.NewVar(token.NoPos, nil, "off", types.Typ[types.Int64])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))

	// (*File).ReadAt(b []byte, off int64) (n int, err error)
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadAt",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "b", byteSlice),
				types.NewVar(token.NoPos, nil, "off", types.Typ[types.Int64])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))

	// --- Additional os functions ---

	// func UserCacheDir() (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "UserCacheDir",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func UserConfigDir() (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "UserConfigDir",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Chmod(name string, mode FileMode) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Chmod",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "mode", fileModeType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Chown(name string, uid, gid int) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Chown",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "uid", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "gid", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Link(oldname, newname string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Link",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "oldname", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "newname", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Symlink(oldname, newname string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Symlink",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "oldname", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "newname", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Readlink(name string) (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Readlink",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func SameFile(fi1, fi2 FileInfo) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SameFile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fi1", fileInfoType),
				types.NewVar(token.NoPos, pkg, "fi2", fileInfoType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Pipe() (r *File, w *File, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Pipe",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", filePtr),
				types.NewVar(token.NoPos, pkg, "w", filePtr),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func Truncate(name string, size int64) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Truncate",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "size", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// (*File).Fd() uintptr
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fd",
		types.NewSignatureType(fileRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uintptr])),
			false)))

	// (*File).Readdir(n int) ([]FileInfo, error)
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Readdir",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(fileInfoType)),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*File).Readdirnames(n int) ([]string, error)
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Readdirnames",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String])),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*File).SetDeadline(t time.Time) error
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetDeadline",
		types.NewSignatureType(fileRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "t", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// func Expand(s string, mapping func(string) string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Expand",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "mapping",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
						false))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func ExpandEnv(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ExpandEnv",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func DirFS(dir string) fs.FS — simplified as interface
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DirFS",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "dir", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewInterfaceType(nil, nil))),
			false)))

	// func NewFile(fd uintptr, name string) *File
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewFile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fd", types.Typ[types.Uintptr]),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", filePtr)),
			false)))

	// func IsTimeout(err error) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsTimeout",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "err", errType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// var ErrNoDeadline error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrNoDeadline", errType))

	pkg.MarkComplete()
	return pkg
}

// buildTimePackage creates the type-checked time package stub.
// Duration is int64 (nanoseconds). Time is a struct wrapping milliseconds.
func buildTimePackage() *types.Package {
	pkg := types.NewPackage("time", "time")
	scope := pkg.Scope()

	// type Duration int64 (nanoseconds)
	durationType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Duration", nil),
		types.Typ[types.Int64], nil)
	scope.Insert(durationType.Obj())

	// type Time struct { msec int }
	timeStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "msec", types.Typ[types.Int], false),
	}, nil)
	timeType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Time", nil),
		timeStruct, nil)
	scope.Insert(timeType.Obj())

	// func Now() Time
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Now",
		types.NewSignatureType(nil, nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timeType)),
			false)))

	// func Since(t Time) Duration
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Since",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "t", timeType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", durationType)),
			false)))

	// func Sleep(d Duration)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sleep",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "d", durationType)),
			nil,
			false)))

	// func After(d Duration) <-chan Time
	chanType := types.NewChan(types.RecvOnly, timeType)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "After",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "d", durationType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", chanType)),
			false)))

	// Duration constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "Nanosecond", durationType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Microsecond", durationType, constant.MakeInt64(1000)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Millisecond", durationType, constant.MakeInt64(1000000)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Second", durationType, constant.MakeInt64(1000000000)))

	// func (d Duration) Milliseconds() int64
	durationType.AddMethod(types.NewFunc(token.NoPos, pkg, "Milliseconds",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "d", durationType),
			nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))

	// func (t Time) Sub(u Time) Duration
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Sub",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "u", timeType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", durationType)),
			false)))

	// Additional Duration constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "Minute", durationType, constant.MakeInt64(60000000000)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Hour", durationType, constant.MakeInt64(3600000000000)))

	// func (t Time) Unix() int64
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Unix",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))

	// func (t Time) UnixMilli() int64
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnixMilli",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))

	// func (t Time) Format(layout string) string
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Format",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "layout", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// func (t Time) String() string
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// func (t Time) IsZero() bool
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsZero",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func (t Time) Before(u Time) bool
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Before",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "u", timeType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func (t Time) After(u Time) bool
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "After",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "u", timeType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func (t Time) Equal(u Time) bool
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "u", timeType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func (t Time) Add(d Duration) Time
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Add",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "d", durationType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timeType)),
			false)))

	// func (d Duration) String() string
	durationType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "d", durationType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// func (d Duration) Seconds() float64
	durationType.AddMethod(types.NewFunc(token.NoPos, pkg, "Seconds",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "d", durationType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Float64])),
			false)))

	// func NewTimer(d Duration) *Timer — simplified as returning Time
	// func NewTicker(d Duration) *Ticker — simplified
	// We'll provide Tick as a channel-returning function
	// func Tick(d Duration) <-chan Time
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Tick",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "d", durationType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", chanType)),
			false)))

	// func Parse(layout, value string) (Time, error)
	errType := types.Universe.Lookup("error").Type()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Parse",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "layout", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", timeType),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// func ParseInLocation(layout, value string, loc *Location) (Time, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseInLocation",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "layout", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "loc", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", timeType),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// func Date(year int, month int, day, hour, min, sec, nsec int, loc *Location) Time
	// Simplified — we just take ints
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Date",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "year", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "month", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "day", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "hour", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "min", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "sec", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "nsec", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "loc", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timeType)),
			false)))

	// Layout constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "RFC3339", types.Typ[types.String],
		constant.MakeString("2006-01-02T15:04:05Z07:00")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RFC1123", types.Typ[types.String],
		constant.MakeString("Mon, 02 Jan 2006 15:04:05 MST")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Kitchen", types.Typ[types.String],
		constant.MakeString("3:04PM")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RFC822", types.Typ[types.String],
		constant.MakeString("02 Jan 06 15:04 MST")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RFC850", types.Typ[types.String],
		constant.MakeString("Monday, 02-Jan-06 15:04:05 MST")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ANSIC", types.Typ[types.String],
		constant.MakeString("Mon Jan _2 15:04:05 2006")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "UnixDate", types.Typ[types.String],
		constant.MakeString("Mon Jan _2 15:04:05 MST 2006")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RubyDate", types.Typ[types.String],
		constant.MakeString("Mon Jan 02 15:04:05 -0700 2006")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RFC3339Nano", types.Typ[types.String],
		constant.MakeString("2006-01-02T15:04:05.999999999Z07:00")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "DateTime", types.Typ[types.String],
		constant.MakeString("2006-01-02 15:04:05")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "DateOnly", types.Typ[types.String],
		constant.MakeString("2006-01-02")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "TimeOnly", types.Typ[types.String],
		constant.MakeString("15:04:05")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Stamp", types.Typ[types.String],
		constant.MakeString("Jan _2 15:04:05")))

	// type Month int
	monthType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Month", nil),
		types.Typ[types.Int], nil)
	scope.Insert(monthType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "January", monthType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "February", monthType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "March", monthType, constant.MakeInt64(3)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "April", monthType, constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "May", monthType, constant.MakeInt64(5)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "June", monthType, constant.MakeInt64(6)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "July", monthType, constant.MakeInt64(7)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "August", monthType, constant.MakeInt64(8)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "September", monthType, constant.MakeInt64(9)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "October", monthType, constant.MakeInt64(10)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "November", monthType, constant.MakeInt64(11)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "December", monthType, constant.MakeInt64(12)))
	monthType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "m", monthType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// type Weekday int
	weekdayType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Weekday", nil),
		types.Typ[types.Int], nil)
	scope.Insert(weekdayType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "Sunday", weekdayType, constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Monday", weekdayType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Tuesday", weekdayType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Wednesday", weekdayType, constant.MakeInt64(3)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Thursday", weekdayType, constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Friday", weekdayType, constant.MakeInt64(5)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Saturday", weekdayType, constant.MakeInt64(6)))

	// type Location struct { name string }
	locStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "name", types.Typ[types.String], false),
	}, nil)
	locType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Location", nil),
		locStruct, nil)
	scope.Insert(locType.Obj())
	locPtr := types.NewPointer(locType)

	// var UTC, Local *Location
	scope.Insert(types.NewVar(token.NoPos, pkg, "UTC", locPtr))
	scope.Insert(types.NewVar(token.NoPos, pkg, "Local", locPtr))

	// func LoadLocation(name string) (*Location, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LoadLocation",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", locPtr),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// func FixedZone(name string, offset int) *Location
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FixedZone",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "offset", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", locPtr)),
			false)))

	// func Until(t Time) Duration
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Until",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "t", timeType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", durationType)),
			false)))

	// func ParseDuration(s string) (Duration, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseDuration",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", durationType),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// func NewTicker(d Duration) *Ticker
	tickerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "C", chanType, false),
	}, nil)
	tickerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Ticker", nil),
		tickerStruct, nil)
	scope.Insert(tickerType.Obj())
	tickerPtr := types.NewPointer(tickerType)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewTicker",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "d", durationType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", tickerPtr)),
			false)))
	tickerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Stop",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", tickerPtr),
			nil, nil, nil, nil, false)))
	tickerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", tickerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "d", durationType)),
			nil, false)))

	// func NewTimer(d Duration) *Timer
	timerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "C", chanType, false),
	}, nil)
	timerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Timer", nil),
		timerStruct, nil)
	scope.Insert(timerType.Obj())
	timerPtr := types.NewPointer(timerType)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewTimer",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "d", durationType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timerPtr)),
			false)))
	timerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Stop",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	timerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "d", durationType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func AfterFunc(d Duration, f func()) *Timer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AfterFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "d", durationType),
				types.NewVar(token.NoPos, nil, "f",
					types.NewSignatureType(nil, nil, nil, nil, nil, false))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timerPtr)),
			false)))

	// func Unix(sec int64, nsec int64) Time
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Unix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "sec", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "nsec", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timeType)),
			false)))

	// func UnixMilli(msec int64) Time
	scope.Insert(types.NewFunc(token.NoPos, pkg, "UnixMilli",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "msec", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timeType)),
			false)))

	// Time additional methods
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Year",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Month",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", monthType)),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Day",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Hour",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Minute",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Second",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Nanosecond",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Weekday",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", weekdayType)),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Location",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", locPtr)),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "In",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "loc", locPtr)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timeType)),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "UTC",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timeType)),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Local",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timeType)),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnixNano",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnixMicro",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Round",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "d", durationType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timeType)),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Truncate",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "d", durationType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", timeType)),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "AppendFormat",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "b", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "layout", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Byte]))),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "MarshalJSON",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "MarshalText",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// Duration additional methods
	durationType.AddMethod(types.NewFunc(token.NoPos, pkg, "Hours",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "d", durationType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Float64])),
			false)))
	durationType.AddMethod(types.NewFunc(token.NoPos, pkg, "Minutes",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "d", durationType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Float64])),
			false)))
	durationType.AddMethod(types.NewFunc(token.NoPos, pkg, "Microseconds",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "d", durationType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	durationType.AddMethod(types.NewFunc(token.NoPos, pkg, "Nanoseconds",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "d", durationType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	durationType.AddMethod(types.NewFunc(token.NoPos, pkg, "Abs",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "d", durationType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", durationType)),
			false)))
	durationType.AddMethod(types.NewFunc(token.NoPos, pkg, "Truncate",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "d", durationType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "m", durationType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", durationType)),
			false)))
	durationType.AddMethod(types.NewFunc(token.NoPos, pkg, "Round",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "d", durationType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "m", durationType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", durationType)),
			false)))

	// func (t Time) Compare(u Time) int — Go 1.20+
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Compare",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "u", timeType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// func (t Time) Clock() (hour, min, sec int)
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Clock",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "hour", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "min", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "sec", types.Typ[types.Int])),
			false)))

	// func (t Time) Date() (year int, month Month, day int)
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Date",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "year", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "month", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "day", types.Typ[types.Int])),
			false)))

	// func (t Time) YearDay() int
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "YearDay",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// func (t Time) Zone() (name string, offset int)
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Zone",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "offset", types.Typ[types.Int])),
			false)))

	// func (t Time) ZoneBounds() (start, end Time)
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "ZoneBounds",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "start", timeType),
				types.NewVar(token.NoPos, nil, "end", timeType)),
			false)))

	// func (t Time) IsDST() bool
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsDST",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func (t Time) GoString() string
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "GoString",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// func (t Time) MarshalBinary() ([]byte, error)
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "MarshalBinary",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// func (t *Time) UnmarshalJSON(data []byte) error
	timePtrRecv := types.NewVar(token.NoPos, nil, "t", types.NewPointer(timeType))
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnmarshalJSON",
		types.NewSignatureType(timePtrRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "data", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// func (t *Time) UnmarshalText(data []byte) error
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnmarshalText",
		types.NewSignatureType(timePtrRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "data", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// func (t *Time) UnmarshalBinary(data []byte) error
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnmarshalBinary",
		types.NewSignatureType(timePtrRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "data", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// func (t *Time) GobDecode(data []byte) error
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "GobDecode",
		types.NewSignatureType(timePtrRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "data", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// func (t Time) GobEncode() ([]byte, error)
	timeType.AddMethod(types.NewFunc(token.NoPos, pkg, "GobEncode",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "t", timeType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

func buildSyncPackage() *types.Package {
	pkg := types.NewPackage("sync", "sync")
	scope := pkg.Scope()

	// type Mutex struct{ locked int }
	mutexStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "locked", types.Typ[types.Int], false),
	}, nil)
	mutexType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Mutex", nil),
		mutexStruct, nil)
	scope.Insert(mutexType.Obj())

	mutexPtr := types.NewPointer(mutexType)
	mutexType.AddMethod(types.NewFunc(token.NoPos, pkg, "Lock",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "m", mutexPtr),
			nil, nil, nil, nil, false)))
	mutexType.AddMethod(types.NewFunc(token.NoPos, pkg, "Unlock",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "m", mutexPtr),
			nil, nil, nil, nil, false)))

	// type WaitGroup struct{ count int; ch chan int }
	wgStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "count", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "ch", types.NewChan(types.SendRecv, types.Typ[types.Int]), false),
	}, nil)
	wgType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "WaitGroup", nil),
		wgStruct, nil)
	scope.Insert(wgType.Obj())

	wgPtr := types.NewPointer(wgType)
	wgType.AddMethod(types.NewFunc(token.NoPos, pkg, "Add",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "wg", wgPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "delta", types.Typ[types.Int])),
			nil, false)))
	wgType.AddMethod(types.NewFunc(token.NoPos, pkg, "Done",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "wg", wgPtr),
			nil, nil, nil, nil, false)))
	wgType.AddMethod(types.NewFunc(token.NoPos, pkg, "Wait",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "wg", wgPtr),
			nil, nil, nil, nil, false)))

	// type Once struct{ done int }
	onceStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "done", types.Typ[types.Int], false),
	}, nil)
	onceType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Once", nil),
		onceStruct, nil)
	scope.Insert(onceType.Obj())

	oncePtr := types.NewPointer(onceType)
	onceType.AddMethod(types.NewFunc(token.NoPos, pkg, "Do",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "o", oncePtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "f",
				types.NewSignatureType(nil, nil, nil, nil, nil, false))),
			nil, false)))

	// type RWMutex struct{ locked int }
	rwMutexStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "locked", types.Typ[types.Int], false),
	}, nil)
	rwMutexType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "RWMutex", nil),
		rwMutexStruct, nil)
	scope.Insert(rwMutexType.Obj())

	rwMutexPtr := types.NewPointer(rwMutexType)
	rwMutexType.AddMethod(types.NewFunc(token.NoPos, pkg, "Lock",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "rw", rwMutexPtr),
			nil, nil, nil, nil, false)))
	rwMutexType.AddMethod(types.NewFunc(token.NoPos, pkg, "Unlock",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "rw", rwMutexPtr),
			nil, nil, nil, nil, false)))
	rwMutexType.AddMethod(types.NewFunc(token.NoPos, pkg, "RLock",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "rw", rwMutexPtr),
			nil, nil, nil, nil, false)))
	rwMutexType.AddMethod(types.NewFunc(token.NoPos, pkg, "RUnlock",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "rw", rwMutexPtr),
			nil, nil, nil, nil, false)))

	// type Map struct{ data int } — simplified
	mapStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "data", types.Typ[types.Int], false),
	}, nil)
	mapType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Map", nil),
		mapStruct, nil)
	scope.Insert(mapType.Obj())

	anyType := types.Universe.Lookup("any").Type()
	mapPtr := types.NewPointer(mapType)
	// func (m *Map) Store(key, value any)
	mapType.AddMethod(types.NewFunc(token.NoPos, pkg, "Store",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", mapPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", anyType),
				types.NewVar(token.NoPos, nil, "value", anyType)),
			nil, false)))
	// func (m *Map) Load(key any) (value any, ok bool)
	mapType.AddMethod(types.NewFunc(token.NoPos, pkg, "Load",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", mapPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", anyType)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "value", anyType),
				types.NewVar(token.NoPos, nil, "ok", types.Typ[types.Bool])),
			false)))
	// func (m *Map) Delete(key any)
	mapType.AddMethod(types.NewFunc(token.NoPos, pkg, "Delete",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", mapPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", anyType)),
			nil, false)))

	// type Pool struct{ New func() any }
	poolStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "New",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", anyType)), false), false),
	}, nil)
	poolType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Pool", nil),
		poolStruct, nil)
	scope.Insert(poolType.Obj())

	poolPtr := types.NewPointer(poolType)
	// func (p *Pool) Get() any
	poolType.AddMethod(types.NewFunc(token.NoPos, pkg, "Get",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "p", poolPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", anyType)),
			false)))
	// func (p *Pool) Put(x any)
	poolType.AddMethod(types.NewFunc(token.NoPos, pkg, "Put",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "p", poolPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", anyType)),
			nil, false)))

	// Map additional methods
	// func (m *Map) LoadOrStore(key, value any) (actual any, loaded bool)
	mapType.AddMethod(types.NewFunc(token.NoPos, pkg, "LoadOrStore",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", mapPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", anyType),
				types.NewVar(token.NoPos, nil, "value", anyType)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "actual", anyType),
				types.NewVar(token.NoPos, nil, "loaded", types.Typ[types.Bool])),
			false)))
	// func (m *Map) LoadAndDelete(key any) (value any, loaded bool)
	mapType.AddMethod(types.NewFunc(token.NoPos, pkg, "LoadAndDelete",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", mapPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", anyType)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "value", anyType),
				types.NewVar(token.NoPos, nil, "loaded", types.Typ[types.Bool])),
			false)))
	// func (m *Map) Range(f func(key, value any) bool)
	mapType.AddMethod(types.NewFunc(token.NoPos, pkg, "Range",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", mapPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "f",
				types.NewSignatureType(nil, nil, nil,
					types.NewTuple(
						types.NewVar(token.NoPos, nil, "key", anyType),
						types.NewVar(token.NoPos, nil, "value", anyType)),
					types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
					false))),
			nil, false)))
	// func (m *Map) Swap(key, value any) (previous any, loaded bool)
	mapType.AddMethod(types.NewFunc(token.NoPos, pkg, "Swap",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", mapPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", anyType),
				types.NewVar(token.NoPos, nil, "value", anyType)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "previous", anyType),
				types.NewVar(token.NoPos, nil, "loaded", types.Typ[types.Bool])),
			false)))
	// func (m *Map) CompareAndSwap(key, old, new any) bool
	mapType.AddMethod(types.NewFunc(token.NoPos, pkg, "CompareAndSwap",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", mapPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", anyType),
				types.NewVar(token.NoPos, nil, "old", anyType),
				types.NewVar(token.NoPos, nil, "new", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	// func (m *Map) CompareAndDelete(key, old any) bool
	mapType.AddMethod(types.NewFunc(token.NoPos, pkg, "CompareAndDelete",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", mapPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", anyType),
				types.NewVar(token.NoPos, nil, "old", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// Mutex.TryLock
	mutexType.AddMethod(types.NewFunc(token.NoPos, pkg, "TryLock",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "m", mutexPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// RWMutex.TryLock, TryRLock, RLocker
	rwMutexType.AddMethod(types.NewFunc(token.NoPos, pkg, "TryLock",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "rw", rwMutexPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	rwMutexType.AddMethod(types.NewFunc(token.NoPos, pkg, "TryRLock",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "rw", rwMutexPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// type Locker interface { Lock(); Unlock() }
	// (define early so RLocker can reference it)
	lockerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Lock",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, pkg, "Unlock",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
	}, nil)
	lockerIface.Complete()
	lockerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Locker", nil),
		lockerIface, nil)
	scope.Insert(lockerType.Obj())

	// func (rw *RWMutex) RLocker() Locker
	rwMutexType.AddMethod(types.NewFunc(token.NoPos, pkg, "RLocker",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "rw", rwMutexPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", lockerType)),
			false)))

	// type Cond struct { L Locker }
	condStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "L", lockerType, false),
	}, nil)
	condType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Cond", nil),
		condStruct, nil)
	scope.Insert(condType.Obj())
	condPtr := types.NewPointer(condType)

	// func NewCond(l Locker) *Cond
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewCond",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "l", lockerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", condPtr)),
			false)))
	condType.AddMethod(types.NewFunc(token.NoPos, pkg, "Wait",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", condPtr),
			nil, nil, nil, nil, false)))
	condType.AddMethod(types.NewFunc(token.NoPos, pkg, "Signal",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", condPtr),
			nil, nil, nil, nil, false)))
	condType.AddMethod(types.NewFunc(token.NoPos, pkg, "Broadcast",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", condPtr),
			nil, nil, nil, nil, false)))

	// type OnceFunc — not a type, but a function
	// func OnceFunc(f func()) func()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "OnceFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "f",
				types.NewSignatureType(nil, nil, nil, nil, nil, false))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "",
				types.NewSignatureType(nil, nil, nil, nil, nil, false))),
			false)))
	// func OnceValue[T any](f func() T) func() T — simplified as func(func() any) func() any
	scope.Insert(types.NewFunc(token.NoPos, pkg, "OnceValue",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "f",
				types.NewSignatureType(nil, nil, nil, nil,
					types.NewTuple(types.NewVar(token.NoPos, nil, "", anyType)), false))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "",
				types.NewSignatureType(nil, nil, nil, nil,
					types.NewTuple(types.NewVar(token.NoPos, nil, "", anyType)), false))),
			false)))

	// func OnceValues[T1, T2 any](f func() (T1, T2)) func() (T1, T2) — simplified as func(func() (any, any)) func() (any, any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "OnceValues",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "f",
				types.NewSignatureType(nil, nil, nil, nil,
					types.NewTuple(
						types.NewVar(token.NoPos, nil, "", anyType),
						types.NewVar(token.NoPos, nil, "", anyType)), false))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "",
				types.NewSignatureType(nil, nil, nil, nil,
					types.NewTuple(
						types.NewVar(token.NoPos, nil, "", anyType),
						types.NewVar(token.NoPos, nil, "", anyType)), false))),
			false)))

	pkg.MarkComplete()
	return pkg
}

func buildSortPackage() *types.Package {
	pkg := types.NewPackage("sort", "sort")
	scope := pkg.Scope()

	// func Ints(x []int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Ints",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x",
				types.NewSlice(types.Typ[types.Int]))),
			nil, false)))

	// func Strings(x []string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Strings",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x",
				types.NewSlice(types.Typ[types.String]))),
			nil, false)))

	// func Slice(x any, less func(i, j int) bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Slice",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "x", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "less",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(
							types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int]),
							types.NewVar(token.NoPos, nil, "j", types.Typ[types.Int])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
						false))),
			nil, false)))

	// func IntsAreSorted(x []int) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IntsAreSorted",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x",
				types.NewSlice(types.Typ[types.Int]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func Float64s(x []float64)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Float64s",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x",
				types.NewSlice(types.Typ[types.Float64]))),
			nil, false)))

	// func Search(n int, f func(int) bool) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Search",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "f",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
						false))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// func SearchInts(a []int, x int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SearchInts",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "a", types.NewSlice(types.Typ[types.Int])),
				types.NewVar(token.NoPos, nil, "x", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// func SearchStrings(a []string, x string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SearchStrings",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "a", types.NewSlice(types.Typ[types.String])),
				types.NewVar(token.NoPos, nil, "x", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// func SliceIsSorted(x any, less func(i, j int) bool) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SliceIsSorted",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "x", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "less",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(
							types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int]),
							types.NewVar(token.NoPos, nil, "j", types.Typ[types.Int])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
						false))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func Reverse(data Interface) Interface — simplified
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Reverse",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "data", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))),
			false)))

	// func SliceStable(x any, less func(i, j int) bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SliceStable",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "x", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "less",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(
							types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int]),
							types.NewVar(token.NoPos, nil, "j", types.Typ[types.Int])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
						false))),
			nil, false)))

	// func Sort(data Interface) — simplified to any
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sort",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "data", types.NewInterfaceType(nil, nil))),
			nil, false)))

	// func Stable(data Interface)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Stable",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "data", types.NewInterfaceType(nil, nil))),
			nil, false)))

	// func Find(n int, cmp func(int) int) (i int, found bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Find",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "cmp",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
						false))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "found", types.Typ[types.Bool])),
			false)))

	// func Float64sAreSorted(x []float64) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Float64sAreSorted",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x",
				types.NewSlice(types.Typ[types.Float64]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func StringsAreSorted(x []string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "StringsAreSorted",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x",
				types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func SearchFloat64s(a []float64, x float64) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SearchFloat64s",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "a", types.NewSlice(types.Typ[types.Float64])),
				types.NewVar(token.NoPos, nil, "x", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// func IsSorted(data Interface) bool — simplified
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsSorted",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "data", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// type Interface interface { Len() int; Less(i, j int) bool; Swap(i, j int) }
	sortIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Len",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "Less",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "j", types.Typ[types.Int])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Swap",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "j", types.Typ[types.Int])),
				nil, false)),
	}, nil)
	sortIface.Complete()
	ifaceType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Interface", nil),
		sortIface, nil)
	scope.Insert(ifaceType.Obj())

	// type IntSlice []int
	intSliceType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "IntSlice", nil),
		types.NewSlice(types.Typ[types.Int]), nil)
	scope.Insert(intSliceType.Obj())

	// type Float64Slice []float64
	float64SliceType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Float64Slice", nil),
		types.NewSlice(types.Typ[types.Float64]), nil)
	scope.Insert(float64SliceType.Obj())

	// type StringSlice []string
	stringSliceType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "StringSlice", nil),
		types.NewSlice(types.Typ[types.String]), nil)
	scope.Insert(stringSliceType.Obj())

	pkg.MarkComplete()
	return pkg
}

func buildIOPackage() *types.Package {
	pkg := types.NewPackage("io", "io")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// type Reader interface { Read(p []byte) (n int, err error) }
	readerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte]))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	readerIface.Complete()
	readerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Reader", nil),
		readerIface, nil)
	scope.Insert(readerType.Obj())

	// type Writer interface { Write(p []byte) (n int, err error) }
	writerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte]))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	writerIface.Complete()
	writerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Writer", nil),
		writerIface, nil)
	scope.Insert(writerType.Obj())

	// var EOF error
	scope.Insert(types.NewVar(token.NoPos, pkg, "EOF", errType))

	// var Discard Writer
	scope.Insert(types.NewVar(token.NoPos, pkg, "Discard", writerType))

	// func ReadAll(r Reader) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadAll",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", readerType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func WriteString(w Writer, s string) (n int, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WriteString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", writerType),
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func Copy(dst Writer, src Reader) (written int64, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Copy",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", writerType),
				types.NewVar(token.NoPos, pkg, "src", readerType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "written", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// type Closer interface { Close() error }
	closerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	closerIface.Complete()
	closerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Closer", nil),
		closerIface, nil)
	scope.Insert(closerType.Obj())

	// type ReadCloser interface
	rcIface := types.NewInterfaceType(nil, []types.Type{readerIface, closerIface})
	rcIface.Complete()
	readCloserType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReadCloser", nil),
		rcIface, nil)
	scope.Insert(readCloserType.Obj())

	// func NopCloser(r Reader) ReadCloser
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NopCloser",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", readerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", readCloserType)),
			false)))

	// type WriteCloser interface
	wcIface := types.NewInterfaceType(nil, []types.Type{writerIface, closerIface})
	wcIface.Complete()
	writeCloserType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "WriteCloser", nil),
		wcIface, nil)
	scope.Insert(writeCloserType.Obj())

	// type ReadWriter interface
	rwIface := types.NewInterfaceType(nil, []types.Type{readerIface, writerIface})
	rwIface.Complete()
	readWriterType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReadWriter", nil),
		rwIface, nil)
	scope.Insert(readWriterType.Obj())

	// type ReadWriteCloser interface
	rwcIface := types.NewInterfaceType(nil, []types.Type{readerIface, writerIface, closerIface})
	rwcIface.Complete()
	readWriteCloserType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReadWriteCloser", nil),
		rwcIface, nil)
	scope.Insert(readWriteCloserType.Obj())

	// type Seeker interface { Seek(offset int64, whence int) (int64, error) }
	seekerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Seek",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "offset", types.Typ[types.Int64]),
					types.NewVar(token.NoPos, nil, "whence", types.Typ[types.Int])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64]),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	seekerIface.Complete()
	seekerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Seeker", nil),
		seekerIface, nil)
	scope.Insert(seekerType.Obj())

	// type ReadSeeker interface
	rsIface := types.NewInterfaceType(nil, []types.Type{readerIface, seekerIface})
	rsIface.Complete()
	readSeekerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReadSeeker", nil),
		rsIface, nil)
	scope.Insert(readSeekerType.Obj())

	// type ReaderAt interface
	readerAtIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadAt",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte])),
					types.NewVar(token.NoPos, nil, "off", types.Typ[types.Int64])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	readerAtIface.Complete()
	readerAtType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReaderAt", nil),
		readerAtIface, nil)
	scope.Insert(readerAtType.Obj())

	// type WriterAt interface
	writerAtIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "WriteAt",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte])),
					types.NewVar(token.NoPos, nil, "off", types.Typ[types.Int64])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	writerAtIface.Complete()
	writerAtType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "WriterAt", nil),
		writerAtIface, nil)
	scope.Insert(writerAtType.Obj())

	// type ByteReader interface { ReadByte() (byte, error) }
	byteReaderIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadByte",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", types.Typ[types.Byte]),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	byteReaderIface.Complete()
	byteReaderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ByteReader", nil),
		byteReaderIface, nil)
	scope.Insert(byteReaderType.Obj())

	// type ByteWriter interface { WriteByte(c byte) error }
	byteWriterIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "WriteByte",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "c", types.Typ[types.Byte])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	byteWriterIface.Complete()
	byteWriterType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ByteWriter", nil),
		byteWriterIface, nil)
	scope.Insert(byteWriterType.Obj())

	// type StringWriter interface { WriteString(s string) (n int, err error) }
	stringWriterIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "WriteString",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	stringWriterIface.Complete()
	stringWriterType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "StringWriter", nil),
		stringWriterIface, nil)
	scope.Insert(stringWriterType.Obj())

	// Seek whence constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "SeekStart", types.Typ[types.Int], constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SeekCurrent", types.Typ[types.Int], constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SeekEnd", types.Typ[types.Int], constant.MakeInt64(2)))

	// var ErrUnexpectedEOF error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrUnexpectedEOF", errType))
	// var ErrClosedPipe error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrClosedPipe", errType))
	// var ErrShortWrite error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrShortWrite", errType))
	// var ErrShortBuffer error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrShortBuffer", errType))
	// var ErrNoProgress error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrNoProgress", errType))

	// func Pipe() (*PipeReader, *PipeWriter)
	pipeReaderType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "PipeReader", nil), types.NewStruct(nil, nil), nil)
	pipeWriterType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "PipeWriter", nil), types.NewStruct(nil, nil), nil)
	scope.Insert(pipeReaderType.Obj())
	scope.Insert(pipeWriterType.Obj())
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Pipe",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewPointer(pipeReaderType)),
				types.NewVar(token.NoPos, pkg, "", types.NewPointer(pipeWriterType))),
			false)))

	// func LimitReader(r Reader, n int64) Reader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LimitReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", readerType),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", readerType)),
			false)))

	// func TeeReader(r Reader, w Writer) Reader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TeeReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", readerType),
				types.NewVar(token.NoPos, pkg, "w", writerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", readerType)),
			false)))

	// func MultiReader(readers ...Reader) Reader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MultiReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "readers", readerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", readerType)),
			true)))

	// func MultiWriter(writers ...Writer) Writer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MultiWriter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "writers", writerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", writerType)),
			true)))

	// func CopyN(dst Writer, src Reader, n int64) (written int64, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CopyN",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", writerType),
				types.NewVar(token.NoPos, pkg, "src", readerType),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int64])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "written", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CopyBuffer",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", writerType),
				types.NewVar(token.NoPos, pkg, "src", readerType),
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "written", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func ReadFull(r Reader, buf []byte) (n int, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadFull",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", readerType),
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadAtLeast",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", readerType),
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "min", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// type LimitedReader struct
	limitedReaderType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "LimitedReader", nil), types.NewStruct(nil, nil), nil)
	scope.Insert(limitedReaderType.Obj())

	// type SectionReader struct
	sectionReaderType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "SectionReader", nil), types.NewStruct(nil, nil), nil)
	scope.Insert(sectionReaderType.Obj())

	// func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewSectionReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", readerAtType),
				types.NewVar(token.NoPos, pkg, "off", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewPointer(sectionReaderType))),
			false)))

	_ = readCloserType
	_ = writeCloserType
	_ = readWriterType
	_ = readWriteCloserType
	_ = readSeekerType
	_ = writerAtType
	_ = byteReaderType
	_ = byteWriterType
	_ = stringWriterType

	// type RuneReader interface { ReadRune() (r rune, size int, err error) }
	runeReaderIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadRune",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "r", types.Typ[types.Rune]),
					types.NewVar(token.NoPos, nil, "size", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	runeReaderIface.Complete()
	runeReaderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "RuneReader", nil),
		runeReaderIface, nil)
	scope.Insert(runeReaderType.Obj())

	// type RuneScanner interface { ReadRune + UnreadRune }
	runeScannerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadRune",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "r", types.Typ[types.Rune]),
					types.NewVar(token.NoPos, nil, "size", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "UnreadRune",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	runeScannerIface.Complete()
	runeScannerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "RuneScanner", nil),
		runeScannerIface, nil)
	scope.Insert(runeScannerType.Obj())

	// type ByteScanner interface { ReadByte + UnreadByte }
	byteScannerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadByte",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", types.Typ[types.Byte]),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "UnreadByte",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	byteScannerIface.Complete()
	byteScannerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ByteScanner", nil),
		byteScannerIface, nil)
	scope.Insert(byteScannerType.Obj())

	// type WriterTo interface { WriteTo(w Writer) (n int64, err error) }
	writerToIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "WriteTo",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "w", writerType)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int64]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	writerToIface.Complete()
	writerToType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "WriterTo", nil),
		writerToIface, nil)
	scope.Insert(writerToType.Obj())

	// type ReaderFrom interface { ReadFrom(r Reader) (n int64, err error) }
	readerFromIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadFrom",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "r", readerType)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int64]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	readerFromIface.Complete()
	readerFromType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReaderFrom", nil),
		readerFromIface, nil)
	scope.Insert(readerFromType.Obj())

	// type ReadWriteSeeker interface
	rwsIface := types.NewInterfaceType(nil, []types.Type{readerIface, writerIface, seekerIface})
	rwsIface.Complete()
	readWriteSeekerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReadWriteSeeker", nil),
		rwsIface, nil)
	scope.Insert(readWriteSeekerType.Obj())

	_ = runeReaderType
	_ = runeScannerType
	_ = byteScannerType
	_ = writerToType
	_ = readerFromType
	_ = readWriteSeekerType

	pkg.MarkComplete()
	return pkg
}

func buildLogPackage() *types.Package {
	pkg := types.NewPackage("log", "log")
	scope := pkg.Scope()

	// func Println(v ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Println",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v",
				types.NewSlice(types.NewInterfaceType(nil, nil)))),
			nil, true)))

	// func Printf(format string, v ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Printf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "v",
					types.NewSlice(types.NewInterfaceType(nil, nil)))),
			nil, true)))

	// func Fatal(v ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fatal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v",
				types.NewSlice(types.NewInterfaceType(nil, nil)))),
			nil, true)))

	// func Fatalf(format string, v ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fatalf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "v",
					types.NewSlice(types.NewInterfaceType(nil, nil)))),
			nil, true)))

	anySlice := types.NewSlice(types.NewInterfaceType(nil, nil))
	errType := types.Universe.Lookup("error").Type()

	// func Print(v ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Print",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))

	// func Fatalln(v ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fatalln",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))

	// func Panic(v ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Panic",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))

	// func Panicln(v ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Panicln",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))

	// func Panicf(format string, v ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Panicf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))

	// func SetFlags(flag int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SetFlags",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "flag", types.Typ[types.Int])),
			nil, false)))

	// func Flags() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Flags",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// func SetPrefix(prefix string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SetPrefix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "prefix", types.Typ[types.String])),
			nil, false)))

	// func Prefix() string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Prefix",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// func SetOutput(w io.Writer)
	logByteSlice := types.NewSlice(types.Typ[types.Byte])
	writerType := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", logByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	writerType.Complete()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SetOutput",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "w", writerType)),
			nil, false)))

	// func Writer() io.Writer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Writer",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", writerType)),
			false)))

	// func Output(calldepth int, s string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Output",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "calldepth", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// Logger type
	loggerType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Logger", nil), types.NewStruct(nil, nil), nil)
	loggerPtr := types.NewPointer(loggerType)
	scope.Insert(loggerType.Obj())

	// func New(out io.Writer, prefix string, flag int) *Logger
	scope.Insert(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "out", writerType),
				types.NewVar(token.NoPos, nil, "prefix", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "flag", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", loggerPtr)),
			false)))

	// func Default() *Logger
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Default",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", loggerPtr)),
			false)))

	logRecv := types.NewVar(token.NoPos, pkg, "l", loggerPtr)

	// (*Logger).Println, Printf, Print, Fatal, Fatalf, Fatalln, Panic, Panicln, Panicf
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Println",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Printf",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Print",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fatal",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fatalf",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fatalln",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Panic",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Panicf",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Panicln",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "v", anySlice)),
			nil, true)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Output",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "calldepth", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetPrefix",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "prefix", types.Typ[types.String])),
			nil, false)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Prefix",
		types.NewSignatureType(logRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetFlags",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "flag", types.Typ[types.Int])),
			nil, false)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Flags",
		types.NewSignatureType(logRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetOutput",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "w", writerType)),
			nil, false)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Writer",
		types.NewSignatureType(logRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", writerType)),
			false)))

	// Log flag constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "Ldate", types.Typ[types.Int], constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Ltime", types.Typ[types.Int], constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Lmicroseconds", types.Typ[types.Int], constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Llongfile", types.Typ[types.Int], constant.MakeInt64(8)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Lshortfile", types.Typ[types.Int], constant.MakeInt64(16)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LUTC", types.Typ[types.Int], constant.MakeInt64(32)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Lmsgprefix", types.Typ[types.Int], constant.MakeInt64(64)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LstdFlags", types.Typ[types.Int], constant.MakeInt64(3)))

	pkg.MarkComplete()
	return pkg
}

func buildUnicodePackage() *types.Package {
	pkg := types.NewPackage("unicode", "unicode")
	scope := pkg.Scope()

	runeBool := func(name string) {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
				false)))
	}
	runeBool("IsLetter")
	runeBool("IsDigit")
	runeBool("IsSpace")
	runeBool("IsUpper")
	runeBool("IsLower")
	runeBool("IsPunct")
	runeBool("IsControl")
	runeBool("IsGraphic")
	runeBool("IsPrint")
	runeBool("IsNumber")

	runeRune := func(name string) {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Rune])),
				false)))
	}
	runeRune("ToUpper")
	runeRune("ToLower")
	runeRune("ToTitle")

	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxRune", types.Typ[types.Rune], constant.MakeInt64(0x10FFFF)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxASCII", types.Typ[types.Rune], constant.MakeInt64(0x7F)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxLatin1", types.Typ[types.Rune], constant.MakeInt64(0xFF)))

	pkg.MarkComplete()
	return pkg
}

func buildUTF8Package() *types.Package {
	pkg := types.NewPackage("unicode/utf8", "utf8")
	scope := pkg.Scope()

	// func RuneLen(r rune) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "RuneLen",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func RuneCountInString(s string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "RuneCountInString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func RuneCount(p []byte) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "RuneCount",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "p", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func ValidString(s string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ValidString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Valid(p []byte) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Valid",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "p", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func DecodeRuneInString(s string) (rune, int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DecodeRuneInString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Rune]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func EncodeRune(p []byte, r rune) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EncodeRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func DecodeRune(p []byte) (rune, int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DecodeRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "p", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Rune]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func DecodeLastRune(p []byte) (rune, int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DecodeLastRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "p", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Rune]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func DecodeLastRuneInString(s string) (rune, int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DecodeLastRuneInString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Rune]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func ValidRune(r rune) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ValidRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func FullRune(p []byte) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FullRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "p", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func FullRuneInString(s string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FullRuneInString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func AppendRune(p []byte, r rune) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			false)))

	// Constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "RuneSelf", types.Typ[types.Int], constant.MakeInt64(0x80)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxRune", types.Typ[types.Rune], constant.MakeInt64(0x10FFFF)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "UTFMax", types.Typ[types.Int], constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RuneError", types.Typ[types.Rune], constant.MakeInt64(0xFFFD)))

	pkg.MarkComplete()
	return pkg
}

func buildPathPackage() *types.Package {
	pkg := types.NewPackage("path", "path")
	scope := pkg.Scope()

	ss := func(name string) {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
				false)))
	}
	ss("Base")
	ss("Dir")
	ss("Ext")
	ss("Clean")

	// func IsAbs(path string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsAbs",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Join(elem ...string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Join",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "elem", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			true)))

	// func Split(path string) (dir, file string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Split",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dir", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "file", types.Typ[types.String])),
			false)))

	// func Match(pattern, name string) (bool, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Match",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, pkg, "", types.Universe.Lookup("error").Type())),
			false)))

	pkg.MarkComplete()
	return pkg
}

func buildMathBitsPackage() *types.Package {
	pkg := types.NewPackage("math/bits", "bits")
	scope := pkg.Scope()

	uintInt := func(name string) {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Uint])),
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
				false)))
	}
	uintInt("OnesCount")
	uintInt("LeadingZeros")
	uintInt("TrailingZeros")
	uintInt("Len")

	uint64Int := func(name string) {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Uint64])),
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
				false)))
	}
	uint64Int("OnesCount64")
	uint64Int("LeadingZeros64")
	uint64Int("TrailingZeros64")
	uint64Int("Len64")

	// func RotateLeft(x uint, k int) uint
	scope.Insert(types.NewFunc(token.NoPos, pkg, "RotateLeft",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Uint]),
				types.NewVar(token.NoPos, pkg, "k", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint])),
			false)))

	// func RotateLeft64(x uint64, k int) uint64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "RotateLeft64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Uint64]),
				types.NewVar(token.NoPos, pkg, "k", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint64])),
			false)))

	// func ReverseBytes64(x uint64) uint64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReverseBytes64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Uint64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint64])),
			false)))

	// func Reverse64(x uint64) uint64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Reverse64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Uint64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint64])),
			false)))

	// Constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "UintSize", types.Typ[types.Int], constant.MakeInt64(64)))

	pkg.MarkComplete()
	return pkg
}

func buildMathRandPackage() *types.Package {
	pkg := types.NewPackage("math/rand", "rand")
	scope := pkg.Scope()

	// func Intn(n int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Intn",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Int() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Int",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Float64() float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Float64",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func Seed(seed int64)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Seed",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "seed", types.Typ[types.Int64])),
			nil, false)))

	// func Intn31() int32
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Int31",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int32])),
			false)))

	// func Int63() int64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Int63",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64])),
			false)))

	pkg.MarkComplete()
	return pkg
}

func buildBytesPackage() *types.Package {
	pkg := types.NewPackage("bytes", "bytes")
	scope := pkg.Scope()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// func Contains(b, subslice []byte) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Contains",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", byteSlice),
				types.NewVar(token.NoPos, pkg, "subslice", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Equal(a, b []byte) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "a", byteSlice),
				types.NewVar(token.NoPos, pkg, "b", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Compare(a, b []byte) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Compare",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "a", byteSlice),
				types.NewVar(token.NoPos, pkg, "b", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	bbBool := func(name string) {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, pkg, "s", byteSlice),
					types.NewVar(token.NoPos, pkg, "prefix", byteSlice)),
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
				false)))
	}
	bbBool("HasPrefix")
	bbBool("HasSuffix")

	// func Index(s, sep []byte) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Index",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "sep", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func IndexByte(b []byte, c byte) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IndexByte",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", byteSlice),
				types.NewVar(token.NoPos, pkg, "c", types.Typ[types.Byte])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Count(s, sep []byte) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Count",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "sep", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	bbs := func(name string) {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, pkg, "s", byteSlice)),
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
				false)))
	}
	bbs("TrimSpace")
	bbs("ToLower")
	bbs("ToUpper")

	// func Repeat(b []byte, count int) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Repeat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", byteSlice),
				types.NewVar(token.NoPos, pkg, "count", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func Join(s [][]byte, sep []byte) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Join",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.NewSlice(byteSlice)),
				types.NewVar(token.NoPos, pkg, "sep", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func Split(s, sep []byte) [][]byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Split",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "sep", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(byteSlice))),
			false)))

	// func Replace(s, old, new []byte, n int) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Replace",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "old", byteSlice),
				types.NewVar(token.NoPos, pkg, "new", byteSlice),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func ReplaceAll(s, old, new []byte) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReplaceAll",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "old", byteSlice),
				types.NewVar(token.NoPos, pkg, "new", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func Trim(s []byte, cutset string) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Trim",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "cutset", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func TrimLeft(s []byte, cutset string) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimLeft",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "cutset", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func TrimRight(s []byte, cutset string) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimRight",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "cutset", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func TrimPrefix(s, prefix []byte) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimPrefix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "prefix", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func TrimSuffix(s, suffix []byte) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimSuffix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "suffix", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func LastIndex(s, sep []byte) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LastIndex",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "sep", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func SplitN(s, sep []byte, n int) [][]byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SplitN",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "sep", byteSlice),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(byteSlice))),
			false)))

	// func Fields(s []byte) [][]byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Fields",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(byteSlice))),
			false)))

	// func EqualFold(s, t []byte) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EqualFold",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "t", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func ContainsRune(b []byte, r rune) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ContainsRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", byteSlice),
				types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func ContainsAny(b []byte, chars string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ContainsAny",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", byteSlice),
				types.NewVar(token.NoPos, pkg, "chars", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Map(mapping func(r rune) rune, s []byte) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Map",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "mapping", types.NewSignatureType(nil, nil, nil,
					types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
					types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Rune])),
					false)),
				types.NewVar(token.NoPos, pkg, "s", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// Buffer type
	bufType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Buffer", nil), types.NewStruct(nil, nil), nil)
	bufPtr := types.NewPointer(bufType)
	scope.Insert(bufType.Obj())

	// func NewBuffer(buf []byte) *Buffer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewBuffer",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "buf", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", bufPtr)),
			false)))

	// func NewBufferString(s string) *Buffer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewBufferString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", bufPtr)),
			false)))

	// Buffer methods
	bufRecv := types.NewVar(token.NoPos, pkg, "b", bufPtr)

	// func (b *Buffer) Write(p []byte) (n int, err error)
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "p", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", types.Universe.Lookup("error").Type())),
			false)))

	// func (b *Buffer) WriteString(s string) (n int, err error)
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteString",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", types.Universe.Lookup("error").Type())),
			false)))

	// func (b *Buffer) WriteByte(c byte) error
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteByte",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "c", types.Typ[types.Byte])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Universe.Lookup("error").Type())),
			false)))

	// func (b *Buffer) String() string
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(bufRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (b *Buffer) Bytes() []byte
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "Bytes",
		types.NewSignatureType(bufRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func (b *Buffer) Len() int
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "Len",
		types.NewSignatureType(bufRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func (b *Buffer) Reset()
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(bufRecv, nil, nil, nil, nil, false)))

	// func (b *Buffer) Read(p []byte) (n int, err error)
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "p", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", types.Universe.Lookup("error").Type())),
			false)))

	// func (b *Buffer) ReadByte() (byte, error)
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadByte",
		types.NewSignatureType(bufRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "", types.Universe.Lookup("error").Type())),
			false)))

	// func (b *Buffer) ReadString(delim byte) (line string, err error)
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadString",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "delim", types.Typ[types.Byte])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "line", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "err", types.Universe.Lookup("error").Type())),
			false)))

	// More bytes functions
	errType := types.Universe.Lookup("error").Type()
	funcPred := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
		types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
		false)

	bbs("ToTitle")
	bbs("Title")
	bbs("ToValidUTF8")
	bbs("Runes")

	// func IndexAny(s []byte, chars string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IndexAny",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "chars", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func LastIndexByte(s []byte, c byte) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LastIndexByte",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "c", types.Typ[types.Byte])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func LastIndexAny(s []byte, chars string) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LastIndexAny",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "chars", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func IndexRune(s []byte, r rune) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IndexRune",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func IndexFunc(s []byte, f func(rune) bool) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IndexFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "f", funcPred)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func LastIndexFunc(s []byte, f func(rune) bool) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LastIndexFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "f", funcPred)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func SplitAfter(s, sep []byte) [][]byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SplitAfter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "sep", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(byteSlice))),
			false)))

	// func SplitAfterN(s, sep []byte, n int) [][]byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SplitAfterN",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "sep", byteSlice),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(byteSlice))),
			false)))

	// func FieldsFunc(s []byte, f func(rune) bool) [][]byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FieldsFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "f", funcPred)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(byteSlice))),
			false)))

	// func ContainsFunc(b []byte, f func(rune) bool) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ContainsFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", byteSlice),
				types.NewVar(token.NoPos, pkg, "f", funcPred)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func TrimFunc(s []byte, f func(rune) bool) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "f", funcPred)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func TrimLeftFunc(s []byte, f func(rune) bool) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimLeftFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "f", funcPred)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func TrimRightFunc(s []byte, f func(rune) bool) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimRightFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "f", funcPred)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func Clone(b []byte) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Clone",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "b", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func CutPrefix(s, prefix []byte) (after []byte, found bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CutPrefix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "prefix", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "after", byteSlice),
				types.NewVar(token.NoPos, pkg, "found", types.Typ[types.Bool])),
			false)))

	// func CutSuffix(s, suffix []byte) (before []byte, found bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CutSuffix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "suffix", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "before", byteSlice),
				types.NewVar(token.NoPos, pkg, "found", types.Typ[types.Bool])),
			false)))

	// func Cut(s, sep []byte) (before, after []byte, found bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Cut",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", byteSlice),
				types.NewVar(token.NoPos, pkg, "sep", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "before", byteSlice),
				types.NewVar(token.NoPos, pkg, "after", byteSlice),
				types.NewVar(token.NoPos, pkg, "found", types.Typ[types.Bool])),
			false)))

	// Additional Buffer methods
	// func (b *Buffer) Cap() int
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cap",
		types.NewSignatureType(bufRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func (b *Buffer) Grow(n int)
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "Grow",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			nil, false)))

	// func (b *Buffer) WriteRune(r rune) (n int, err error)
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteRune",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func (b *Buffer) ReadRune() (r rune, size int, err error)
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadRune",
		types.NewSignatureType(bufRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune]),
				types.NewVar(token.NoPos, pkg, "size", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func (b *Buffer) UnreadByte() error
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnreadByte",
		types.NewSignatureType(bufRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func (b *Buffer) UnreadRune() error
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnreadRune",
		types.NewSignatureType(bufRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadBytes",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "delim", types.Typ[types.Byte])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "line", byteSlice),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func (b *Buffer) Next(n int) []byte
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "Next",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func (b *Buffer) Truncate(n int)
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "Truncate",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			nil, false)))

	// func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)
	ioWriterIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioWriterIface.Complete()
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteTo",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriterIface)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)
	ioReaderIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioReaderIface.Complete()
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadFrom",
		types.NewSignatureType(bufRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", ioReaderIface)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func (b *Buffer) Available() int — Go 1.21+
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "Available",
		types.NewSignatureType(bufRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func (b *Buffer) AvailableBuffer() []byte — Go 1.21+
	bufType.AddMethod(types.NewFunc(token.NoPos, pkg, "AvailableBuffer",
		types.NewSignatureType(bufRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func NewReader(b []byte) *Reader — stub
	readerType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Reader", nil), types.NewStruct(nil, nil), nil)
	scope.Insert(readerType.Obj())
	readerPtr := types.NewPointer(readerType)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "b", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", readerPtr)),
			false)))

	// Reader methods
	rRecv := types.NewVar(token.NoPos, pkg, "r", readerPtr)
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(rRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "p", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadByte",
		types.NewSignatureType(rRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Len",
		types.NewSignatureType(rRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(rRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "b", byteSlice)),
			nil, false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Size",
		types.NewSignatureType(rRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64])),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadAt",
		types.NewSignatureType(rRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", byteSlice),
				types.NewVar(token.NoPos, pkg, "off", types.Typ[types.Int64])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Seek",
		types.NewSignatureType(rRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "offset", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "whence", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteTo",
		types.NewSignatureType(rRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriterIface)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnreadByte",
		types.NewSignatureType(rRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadRune",
		types.NewSignatureType(rRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ch", types.Typ[types.Rune]),
				types.NewVar(token.NoPos, pkg, "size", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnreadRune",
		types.NewSignatureType(rRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

func buildEncodingHexPackage() *types.Package {
	pkg := types.NewPackage("encoding/hex", "hex")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// func EncodeToString(src []byte) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EncodeToString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "src", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func DecodeString(s string) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DecodeString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func EncodedLen(n int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EncodedLen",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func DecodedLen(x int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DecodedLen",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Encode(dst, src []byte) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Encode",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "src", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Decode(dst, src []byte) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Decode",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "src", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Dump(data []byte) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Dump",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// io interfaces for hex functions
	hexByteSlice := types.NewSlice(types.Typ[types.Byte])
	ioWriterHex := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", hexByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioWriterHex.Complete()

	ioReaderHex := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", hexByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioReaderHex.Complete()

	ioWriteCloserHex := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", hexByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, nil, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	ioWriteCloserHex.Complete()

	// func NewEncoder(w io.Writer) io.Writer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewEncoder",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriterHex)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ioWriterHex)),
			false)))

	// func NewDecoder(r io.Reader) io.Reader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewDecoder",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", ioReaderHex)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ioReaderHex)),
			false)))

	// func Dumper(w io.Writer) io.WriteCloser
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Dumper",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriterHex)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ioWriteCloserHex)),
			false)))

	// type InvalidByteError byte (satisfies error)
	invalidByteType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "InvalidByteError", nil),
		types.Typ[types.Byte], nil)
	invalidByteType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", invalidByteType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(invalidByteType.Obj())

	// var ErrLength error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrLength", errType))

	// func AppendEncode(dst, src []byte) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendEncode",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "src", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			false)))

	// func AppendDecode(dst, src []byte) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendDecode",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "src", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

func buildEncodingBase64Package() *types.Package {
	pkg := types.NewPackage("encoding/base64", "base64")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// type Encoding struct{ ... } (opaque)
	encStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "alphabet", types.Typ[types.String], false),
	}, nil)
	encType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Encoding", nil),
		encStruct, nil)
	scope.Insert(encType.Obj())
	encPtr := types.NewPointer(encType)

	// Methods
	encType.AddMethod(types.NewFunc(token.NoPos, pkg, "EncodeToString",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "enc", encPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "src", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	encType.AddMethod(types.NewFunc(token.NoPos, pkg, "DecodeString",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "enc", encPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	encType.AddMethod(types.NewFunc(token.NoPos, pkg, "EncodedLen",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "enc", encPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	encType.AddMethod(types.NewFunc(token.NoPos, pkg, "DecodedLen",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "enc", encPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Encode/Decode raw methods
	encRecv := types.NewVar(token.NoPos, nil, "enc", encPtr)
	encType.AddMethod(types.NewFunc(token.NoPos, pkg, "Encode",
		types.NewSignatureType(encRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "dst", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "src", types.NewSlice(types.Typ[types.Byte]))),
			nil, false)))
	encType.AddMethod(types.NewFunc(token.NoPos, pkg, "Decode",
		types.NewSignatureType(encRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "dst", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "src", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	encType.AddMethod(types.NewFunc(token.NoPos, pkg, "Strict",
		types.NewSignatureType(encRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", encPtr)),
			false)))
	encType.AddMethod(types.NewFunc(token.NoPos, pkg, "WithPadding",
		types.NewSignatureType(encRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "padding", types.Typ[types.Int32])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", encPtr)),
			false)))

	// func NewEncoding(encoder string) *Encoding
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewEncoding",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "encoder", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", encPtr)),
			false)))

	// io interfaces for base64 functions
	b64ByteSlice := types.NewSlice(types.Typ[types.Byte])
	ioWriterType := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", b64ByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioWriterType.Complete()

	ioWriteCloserType := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", b64ByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, nil, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	ioWriteCloserType.Complete()

	ioReaderType := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", b64ByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioReaderType.Complete()

	// func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewEncoder",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "enc", encPtr),
				types.NewVar(token.NoPos, nil, "w", ioWriterType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", ioWriteCloserType)),
			false)))
	// func NewDecoder(enc *Encoding, r io.Reader) io.Reader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewDecoder",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "enc", encPtr),
				types.NewVar(token.NoPos, nil, "r", ioReaderType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", ioReaderType)),
			false)))

	// NoPadding and StdPadding constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "NoPadding", types.Typ[types.Int32], constant.MakeInt64(-1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StdPadding", types.Typ[types.Int32], constant.MakeInt64(int64('='))))

	// CorruptInputError type
	corruptType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CorruptInputError", nil),
		types.Typ[types.Int64], nil)
	corruptType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", corruptType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(corruptType.Obj())

	// var StdEncoding *Encoding
	scope.Insert(types.NewVar(token.NoPos, pkg, "StdEncoding", encPtr))
	scope.Insert(types.NewVar(token.NoPos, pkg, "URLEncoding", encPtr))
	scope.Insert(types.NewVar(token.NoPos, pkg, "RawStdEncoding", encPtr))
	scope.Insert(types.NewVar(token.NoPos, pkg, "RawURLEncoding", encPtr))

	pkg.MarkComplete()
	return pkg
}

// buildFilepathPackage creates the type-checked path/filepath package stub.
func buildFilepathPackage() *types.Package {
	pkg := types.NewPackage("path/filepath", "filepath")
	scope := pkg.Scope()

	// func Join(elem ...string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Join",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "elem",
				types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			true)))

	// func Base(path string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Base",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Dir(path string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Dir",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Ext(path string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Ext",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Clean(path string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Clean",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Abs(path string) (string, error)
	errType := types.Universe.Lookup("error").Type()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Abs",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Rel(basepath, targpath string) (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Rel",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "basepath", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "targpath", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func IsAbs(path string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsAbs",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// const Separator = '/'
	scope.Insert(types.NewConst(token.NoPos, pkg, "Separator", types.Typ[types.UntypedRune],
		constant.MakeInt64('/')))

	// const ListSeparator = ':'
	scope.Insert(types.NewConst(token.NoPos, pkg, "ListSeparator", types.Typ[types.UntypedRune],
		constant.MakeInt64(':')))

	// func Split(path string) (dir, file string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Split",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dir", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "file", types.Typ[types.String])),
			false)))

	// func ToSlash(path string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ToSlash",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func FromSlash(path string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FromSlash",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Match(pattern, name string) (matched bool, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Match",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "matched", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func Glob(pattern string) (matches []string, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Glob",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "matches", types.NewSlice(types.Typ[types.String])),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func EvalSymlinks(path string) (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EvalSymlinks",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func VolumeName(path string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "VolumeName",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func SplitList(path string) []string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SplitList",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// type WalkFunc func(path string, info os.FileInfo, err error) error
	walkFuncSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String]),
			types.NewVar(token.NoPos, pkg, "info", types.NewInterfaceType(nil, nil)),
			types.NewVar(token.NoPos, pkg, "err", errType)),
		types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
		false)
	walkFuncType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "WalkFunc", nil),
		walkFuncSig, nil)
	scope.Insert(walkFuncType.Obj())

	// func Walk(root string, fn WalkFunc) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Walk",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "root", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "fn", walkFuncType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func WalkDir(root string, fn fs.WalkDirFunc) error
	walkDirFuncSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String]),
			types.NewVar(token.NoPos, pkg, "d", types.NewInterfaceType(nil, nil)),
			types.NewVar(token.NoPos, pkg, "err", errType)),
		types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
		false)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WalkDir",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "root", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "fn", walkDirFuncSig)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// var ErrBadPattern error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrBadPattern", errType))

	// var SkipDir error
	scope.Insert(types.NewVar(token.NoPos, pkg, "SkipDir", errType))

	// var SkipAll error
	scope.Insert(types.NewVar(token.NoPos, pkg, "SkipAll", errType))

	// func HasPrefix(p, prefix string) bool — deprecated but still used
	scope.Insert(types.NewFunc(token.NoPos, pkg, "HasPrefix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "prefix", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func IsLocal(path string) bool — Go 1.20+
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsLocal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "path", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildSlicesPackage creates the type-checked slices package stub (Go 1.21+).
func buildSlicesPackage() *types.Package {
	pkg := types.NewPackage("slices", "slices")
	scope := pkg.Scope()

	// Note: slices functions are generic in real Go, but we stub them with
	// concrete types. The compiler handles type specialization at call sites.

	// func Contains[S ~[]E, E comparable](s S, v E) bool
	// Stubbed as Contains([]any, any) bool
	anySlice := types.NewSlice(types.NewInterfaceType(nil, nil))
	anyType := types.NewInterfaceType(nil, nil)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Contains",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "v", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Index[S ~[]E, E comparable](s S, v E) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Index",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "v", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Reverse[S ~[]E, E any](s S)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Reverse",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			nil, false)))

	// func Sort[S ~[]E, E cmp.Ordered](s S)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sort",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			nil, false)))

	// func Compact[S ~[]E, E comparable](s S) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Compact",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func Equal[S ~[]E, E comparable](s1, s2 S) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s1", anySlice),
				types.NewVar(token.NoPos, pkg, "s2", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Clone[S ~[]E, E any](s S) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Clone",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func Clip[S ~[]E, E any](s S) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Clip",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func Grow[S ~[]E, E any](s S, n int) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Grow",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func Concat[S ~[]E, E any](slices ...S) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Concat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "slices", types.NewSlice(anySlice))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			true)))

	// func Delete[S ~[]E, E any](s S, i, j int) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Delete",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "i", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "j", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func Insert[S ~[]E, E any](s S, i int, v ...E) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Insert",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "i", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "v", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			true)))

	// func Replace[S ~[]E, E any](s S, i, j int, v ...E) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Replace",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "i", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "j", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "v", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			true)))

	// func IsSorted[S ~[]E, E cmp.Ordered](s S) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsSorted",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Min[S ~[]E, E cmp.Ordered](s S) E
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Min",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyType)),
			false)))

	// func Max[S ~[]E, E cmp.Ordered](s S) E
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Max",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyType)),
			false)))

	// func BinarySearch[S ~[]E, E cmp.Ordered](s S, target E) (int, bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "BinarySearch",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "target", anyType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// Func-parameterized variants (use func(E,E) types)
	cmpFunc := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, nil, "a", anyType),
			types.NewVar(token.NoPos, nil, "b", anyType)),
		types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
		false)
	boolFunc := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, nil, "v", anyType)),
		types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
		false)

	// func SortFunc[S ~[]E, E any](s S, cmp func(a, b E) int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SortFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "cmp", cmpFunc)),
			nil, false)))

	// func SortStableFunc[S ~[]E, E any](s S, cmp func(a, b E) int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SortStableFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "cmp", cmpFunc)),
			nil, false)))

	// func IsSortedFunc[S ~[]E, E any](s S, cmp func(a, b E) int) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsSortedFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "cmp", cmpFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func BinarySearchFunc[S ~[]E, E, T any](s S, target T, cmp func(E, T) int) (int, bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "BinarySearchFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "target", anyType),
				types.NewVar(token.NoPos, pkg, "cmp", cmpFunc)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ContainsFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "f", boolFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IndexFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "f", boolFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DeleteFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "del", boolFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S
	eqFunc := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, nil, "a", anyType),
			types.NewVar(token.NoPos, nil, "b", anyType)),
		types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
		false)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CompactFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "eq", eqFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EqualFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s1", anySlice),
				types.NewVar(token.NoPos, pkg, "s2", anySlice),
				types.NewVar(token.NoPos, pkg, "eq", eqFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Compare[S ~[]E, E cmp.Ordered](s1, s2 S) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Compare",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s1", anySlice),
				types.NewVar(token.NoPos, pkg, "s2", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CompareFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s1", anySlice),
				types.NewVar(token.NoPos, pkg, "s2", anySlice),
				types.NewVar(token.NoPos, pkg, "cmp", cmpFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func MinFunc[S ~[]E, E any](s S, cmp func(a, b E) int) E
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MinFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "cmp", cmpFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyType)),
			false)))

	// func MaxFunc[S ~[]E, E any](s S, cmp func(a, b E) int) E
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MaxFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "cmp", cmpFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyType)),
			false)))

	// func Repeat[S ~[]E, E any](s S, count int) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Repeat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "count", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func Chunk[S ~[]E, E any](s S, n int) iter.Seq[S]
	// Simplified: returns a function type
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Chunk",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyType)),
			false)))

	// func All[S ~[]E, E any](s S) iter.Seq2[int, E]
	scope.Insert(types.NewFunc(token.NoPos, pkg, "All",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyType)),
			false)))

	// func Values[S ~[]E, E any](s S) iter.Seq[E]
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Values",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyType)),
			false)))

	// func Backward[S ~[]E, E any](s S) iter.Seq2[int, E]
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Backward",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyType)),
			false)))

	// func Collect[E any](seq iter.Seq[E]) []E
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Collect",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "seq", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func AppendSeq[S ~[]E, E any](s S, seq iter.Seq[E]) S
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendSeq",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", anySlice),
				types.NewVar(token.NoPos, pkg, "seq", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func Sorted[E cmp.Ordered](seq iter.Seq[E]) []E
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sorted",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "seq", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func SortedFunc[E any](seq iter.Seq[E], cmp func(a, b E) int) []E
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SortedFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "seq", anyType),
				types.NewVar(token.NoPos, pkg, "cmp", cmpFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func SortedStableFunc[E any](seq iter.Seq[E], cmp func(a, b E) int) []E
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SortedStableFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "seq", anyType),
				types.NewVar(token.NoPos, pkg, "cmp", cmpFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildMapsPackage creates the type-checked maps package stub (Go 1.21+).
func buildMapsPackage() *types.Package {
	pkg := types.NewPackage("maps", "maps")
	scope := pkg.Scope()

	// Stubbed with interface types for generic functions
	anyType := types.NewInterfaceType(nil, nil)
	anySlice := types.NewSlice(anyType)
	anyMap := types.NewMap(anyType, anyType)

	// func Keys[M ~map[K]V, K comparable, V any](m M) []K
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Keys",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "m", anyMap)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func Values[M ~map[K]V, K comparable, V any](m M) []V
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Values",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "m", anyMap)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anySlice)),
			false)))

	// func Clone[M ~map[K]V, K comparable, V any](m M) M
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Clone",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "m", anyMap)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyMap)),
			false)))

	// func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "m1", anyMap),
				types.NewVar(token.NoPos, pkg, "m2", anyMap)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Copy",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", anyMap),
				types.NewVar(token.NoPos, pkg, "src", anyMap)),
			nil, false)))

	// func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool)
	delFunc := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, nil, "k", anyType),
			types.NewVar(token.NoPos, nil, "v", anyType)),
		types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
		false)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DeleteFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "m", anyMap),
				types.NewVar(token.NoPos, pkg, "del", delFunc)),
			nil, false)))

	// func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool
	eqFunc := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, nil, "a", anyType),
			types.NewVar(token.NoPos, nil, "b", anyType)),
		types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
		false)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EqualFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "m1", anyMap),
				types.NewVar(token.NoPos, pkg, "m2", anyMap),
				types.NewVar(token.NoPos, pkg, "eq", eqFunc)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Collect[K comparable, V any](seq iter.Seq2[K, V]) map[K]V
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Collect",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "seq", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyMap)),
			false)))

	// func All[M ~map[K]V, K comparable, V any](m M) iter.Seq2[K, V]
	scope.Insert(types.NewFunc(token.NoPos, pkg, "All",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "m", anyMap)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyType)),
			false)))

	// func Insert[M ~map[K]V, K comparable, V any](m M, seq iter.Seq2[K, V])
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Insert",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "m", anyMap),
				types.NewVar(token.NoPos, pkg, "seq", anyType)),
			nil, false)))

	pkg.MarkComplete()
	return pkg
}

// buildCmpPackage creates the type-checked cmp package stub (Go 1.21+).
func buildCmpPackage() *types.Package {
	pkg := types.NewPackage("cmp", "cmp")
	scope := pkg.Scope()

	// type Ordered = comparable (simplified as interface{})
	orderedType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Ordered", nil),
		types.NewInterfaceType(nil, nil), nil)
	scope.Insert(orderedType.Obj())

	// func Compare[T Ordered](x, y T) int
	anyType := types.NewInterfaceType(nil, nil)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Compare",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", anyType),
				types.NewVar(token.NoPos, pkg, "y", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Less[T Ordered](x, y T) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Less",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", anyType),
				types.NewVar(token.NoPos, pkg, "y", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Or[T comparable](vals ...T) T
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Or",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "vals",
				types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", anyType)),
			true)))

	pkg.MarkComplete()
	return pkg
}

// buildContextPackage creates the type-checked context package stub.
func buildContextPackage() *types.Package {
	pkg := types.NewPackage("context", "context")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// type Context interface { Deadline, Done, Err, Value }
	anyTypeCtx := types.NewInterfaceType(nil, nil)
	anyTypeCtx.Complete()
	emptyStructType := types.NewStruct(nil, nil)
	ctxIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Deadline",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "deadline", types.Typ[types.Int64]),
					types.NewVar(token.NoPos, nil, "ok", types.Typ[types.Bool])),
				false)),
		types.NewFunc(token.NoPos, pkg, "Done",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "",
					types.NewChan(types.RecvOnly, emptyStructType))),
				false)),
		types.NewFunc(token.NoPos, pkg, "Err",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Value",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "key", anyTypeCtx)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", anyTypeCtx)),
				false)),
	}, nil)
	ctxIface.Complete()
	ctxType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Context", nil),
		ctxIface, nil)
	scope.Insert(ctxType.Obj())

	// type CancelFunc func()
	cancelSig := types.NewSignatureType(nil, nil, nil, nil, nil, false)
	cancelType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CancelFunc", nil),
		cancelSig, nil)
	scope.Insert(cancelType.Obj())

	// func Background() Context
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Background",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ctxType)),
			false)))

	// func TODO() Context
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TODO",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ctxType)),
			false)))

	// func WithCancel(parent Context) (Context, CancelFunc)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WithCancel",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "parent", ctxType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", ctxType),
				types.NewVar(token.NoPos, pkg, "", cancelType)),
			false)))

	// func WithValue(parent Context, key, val any) Context
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WithValue",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "parent", ctxType),
				types.NewVar(token.NoPos, pkg, "key", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "val", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ctxType)),
			false)))

	// var Canceled error
	scope.Insert(types.NewVar(token.NoPos, pkg, "Canceled", errType))

	// var DeadlineExceeded error
	scope.Insert(types.NewVar(token.NoPos, pkg, "DeadlineExceeded", errType))

	// type CancelCauseFunc func(cause error)
	cancelCauseSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, nil, "cause", errType)),
		nil, false)
	cancelCauseType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CancelCauseFunc", nil),
		cancelCauseSig, nil)
	scope.Insert(cancelCauseType.Obj())

	// func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
	// time.Duration is int64 underneath
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WithTimeout",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "parent", ctxType),
				types.NewVar(token.NoPos, pkg, "timeout", types.Typ[types.Int64])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", ctxType),
				types.NewVar(token.NoPos, pkg, "", cancelType)),
			false)))

	// func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
	// time.Time as empty struct placeholder
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WithDeadline",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "parent", ctxType),
				types.NewVar(token.NoPos, pkg, "d", types.NewStruct(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", ctxType),
				types.NewVar(token.NoPos, pkg, "", cancelType)),
			false)))

	// func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WithCancelCause",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "parent", ctxType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", ctxType),
				types.NewVar(token.NoPos, pkg, "", cancelCauseType)),
			false)))

	// func Cause(c Context) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Cause",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "c", ctxType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func AfterFunc(ctx Context, f func()) (stop func() bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AfterFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", ctxType),
				types.NewVar(token.NoPos, pkg, "f", types.NewSignatureType(nil, nil, nil, nil, nil, false))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "",
				types.NewSignatureType(nil, nil, nil, nil,
					types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
					false))),
			false)))

	// func WithoutCancel(parent Context) Context
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WithoutCancel",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "parent", ctxType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ctxType)),
			false)))

	// func WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WithDeadlineCause",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "parent", ctxType),
				types.NewVar(token.NoPos, pkg, "d", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "cause", errType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", ctxType),
				types.NewVar(token.NoPos, pkg, "", cancelType)),
			false)))

	// func WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WithTimeoutCause",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "parent", ctxType),
				types.NewVar(token.NoPos, pkg, "timeout", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "cause", errType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", ctxType),
				types.NewVar(token.NoPos, pkg, "", cancelType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildSyncAtomicPackage creates the type-checked sync/atomic package stub.
func buildSyncAtomicPackage() *types.Package {
	pkg := types.NewPackage("sync/atomic", "atomic")
	scope := pkg.Scope()

	// func AddInt32(addr *int32, delta int32) int32
	int32Ptr := types.NewPointer(types.Typ[types.Int32])
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AddInt32",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", int32Ptr),
				types.NewVar(token.NoPos, pkg, "delta", types.Typ[types.Int32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int32])),
			false)))

	// func AddInt64(addr *int64, delta int64) int64
	int64Ptr := types.NewPointer(types.Typ[types.Int64])
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AddInt64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", int64Ptr),
				types.NewVar(token.NoPos, pkg, "delta", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64])),
			false)))

	// func LoadInt32(addr *int32) int32
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LoadInt32",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "addr", int32Ptr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int32])),
			false)))

	// func LoadInt64(addr *int64) int64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LoadInt64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "addr", int64Ptr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64])),
			false)))

	// func StoreInt32(addr *int32, val int32)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "StoreInt32",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", int32Ptr),
				types.NewVar(token.NoPos, pkg, "val", types.Typ[types.Int32])),
			nil, false)))

	// func StoreInt64(addr *int64, val int64)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "StoreInt64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", int64Ptr),
				types.NewVar(token.NoPos, pkg, "val", types.Typ[types.Int64])),
			nil, false)))

	// func CompareAndSwapInt32(addr *int32, old, new int32) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CompareAndSwapInt32",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", int32Ptr),
				types.NewVar(token.NoPos, pkg, "old", types.Typ[types.Int32]),
				types.NewVar(token.NoPos, pkg, "new_", types.Typ[types.Int32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func CompareAndSwapInt64(addr *int64, old, new int64) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CompareAndSwapInt64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", int64Ptr),
				types.NewVar(token.NoPos, pkg, "old", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "new_", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// uint variants
	uint32Ptr := types.NewPointer(types.Typ[types.Uint32])
	uint64Ptr := types.NewPointer(types.Typ[types.Uint64])
	uintptrPtr := types.NewPointer(types.Typ[types.Uintptr])

	scope.Insert(types.NewFunc(token.NoPos, pkg, "AddUint32",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uint32Ptr),
				types.NewVar(token.NoPos, pkg, "delta", types.Typ[types.Uint32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint32])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AddUint64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uint64Ptr),
				types.NewVar(token.NoPos, pkg, "delta", types.Typ[types.Uint64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint64])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AddUintptr",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uintptrPtr),
				types.NewVar(token.NoPos, pkg, "delta", types.Typ[types.Uintptr])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uintptr])),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "LoadUint32",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "addr", uint32Ptr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint32])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LoadUint64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "addr", uint64Ptr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint64])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LoadUintptr",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "addr", uintptrPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uintptr])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LoadPointer",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "addr", types.NewPointer(types.Typ[types.UnsafePointer]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.UnsafePointer])),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "StoreUint32",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uint32Ptr),
				types.NewVar(token.NoPos, pkg, "val", types.Typ[types.Uint32])),
			nil, false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "StoreUint64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uint64Ptr),
				types.NewVar(token.NoPos, pkg, "val", types.Typ[types.Uint64])),
			nil, false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "StoreUintptr",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uintptrPtr),
				types.NewVar(token.NoPos, pkg, "val", types.Typ[types.Uintptr])),
			nil, false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "StorePointer",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", types.NewPointer(types.Typ[types.UnsafePointer])),
				types.NewVar(token.NoPos, pkg, "val", types.Typ[types.UnsafePointer])),
			nil, false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "SwapInt32",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", int32Ptr),
				types.NewVar(token.NoPos, pkg, "new_", types.Typ[types.Int32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int32])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SwapInt64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", int64Ptr),
				types.NewVar(token.NoPos, pkg, "new_", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SwapUint32",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uint32Ptr),
				types.NewVar(token.NoPos, pkg, "new_", types.Typ[types.Uint32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint32])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SwapUint64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uint64Ptr),
				types.NewVar(token.NoPos, pkg, "new_", types.Typ[types.Uint64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint64])),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "CompareAndSwapUint32",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uint32Ptr),
				types.NewVar(token.NoPos, pkg, "old", types.Typ[types.Uint32]),
				types.NewVar(token.NoPos, pkg, "new_", types.Typ[types.Uint32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CompareAndSwapUint64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uint64Ptr),
				types.NewVar(token.NoPos, pkg, "old", types.Typ[types.Uint64]),
				types.NewVar(token.NoPos, pkg, "new_", types.Typ[types.Uint64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CompareAndSwapUintptr",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", uintptrPtr),
				types.NewVar(token.NoPos, pkg, "old", types.Typ[types.Uintptr]),
				types.NewVar(token.NoPos, pkg, "new_", types.Typ[types.Uintptr])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CompareAndSwapPointer",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", types.NewPointer(types.Typ[types.UnsafePointer])),
				types.NewVar(token.NoPos, pkg, "old", types.Typ[types.UnsafePointer]),
				types.NewVar(token.NoPos, pkg, "new_", types.Typ[types.UnsafePointer])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// type Value struct {}
	valueStruct := types.NewStruct(nil, nil)
	valueType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Value", nil),
		valueStruct, nil)
	scope.Insert(valueType.Obj())
	valuePtr := types.NewPointer(valueType)
	vRecv := types.NewVar(token.NoPos, nil, "v", valuePtr)
	anyType := types.NewInterfaceType(nil, nil)
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Load",
		types.NewSignatureType(vRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", anyType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Store",
		types.NewSignatureType(vRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "val", anyType)),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Swap",
		types.NewSignatureType(vRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "new_", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", anyType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "CompareAndSwap",
		types.NewSignatureType(vRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "old", anyType),
				types.NewVar(token.NoPos, nil, "new_", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// type Bool struct {}
	boolStruct := types.NewStruct(nil, nil)
	boolType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Bool", nil),
		boolStruct, nil)
	scope.Insert(boolType.Obj())
	boolPtr := types.NewPointer(boolType)
	bRecv := types.NewVar(token.NoPos, nil, "x", boolPtr)
	boolType.AddMethod(types.NewFunc(token.NoPos, pkg, "Load",
		types.NewSignatureType(bRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	boolType.AddMethod(types.NewFunc(token.NoPos, pkg, "Store",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "val", types.Typ[types.Bool])),
			nil, false)))
	boolType.AddMethod(types.NewFunc(token.NoPos, pkg, "Swap",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "new_", types.Typ[types.Bool])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	boolType.AddMethod(types.NewFunc(token.NoPos, pkg, "CompareAndSwap",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "old", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, nil, "new_", types.Typ[types.Bool])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// type Int32 struct {}
	int32AtomicStruct := types.NewStruct(nil, nil)
	int32AtomicType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Int32", nil),
		int32AtomicStruct, nil)
	scope.Insert(int32AtomicType.Obj())
	int32AtomicPtr := types.NewPointer(int32AtomicType)
	i32Recv := types.NewVar(token.NoPos, nil, "x", int32AtomicPtr)
	int32AtomicType.AddMethod(types.NewFunc(token.NoPos, pkg, "Load",
		types.NewSignatureType(i32Recv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int32])),
			false)))
	int32AtomicType.AddMethod(types.NewFunc(token.NoPos, pkg, "Store",
		types.NewSignatureType(i32Recv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "val", types.Typ[types.Int32])),
			nil, false)))
	int32AtomicType.AddMethod(types.NewFunc(token.NoPos, pkg, "Add",
		types.NewSignatureType(i32Recv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "delta", types.Typ[types.Int32])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int32])),
			false)))
	int32AtomicType.AddMethod(types.NewFunc(token.NoPos, pkg, "Swap",
		types.NewSignatureType(i32Recv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "new_", types.Typ[types.Int32])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int32])),
			false)))
	int32AtomicType.AddMethod(types.NewFunc(token.NoPos, pkg, "CompareAndSwap",
		types.NewSignatureType(i32Recv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "old", types.Typ[types.Int32]),
				types.NewVar(token.NoPos, nil, "new_", types.Typ[types.Int32])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// type Int64 struct {}
	int64AtomicStruct := types.NewStruct(nil, nil)
	int64AtomicType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Int64", nil),
		int64AtomicStruct, nil)
	scope.Insert(int64AtomicType.Obj())
	int64AtomicPtr := types.NewPointer(int64AtomicType)
	i64Recv := types.NewVar(token.NoPos, nil, "x", int64AtomicPtr)
	int64AtomicType.AddMethod(types.NewFunc(token.NoPos, pkg, "Load",
		types.NewSignatureType(i64Recv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	int64AtomicType.AddMethod(types.NewFunc(token.NoPos, pkg, "Store",
		types.NewSignatureType(i64Recv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "val", types.Typ[types.Int64])),
			nil, false)))
	int64AtomicType.AddMethod(types.NewFunc(token.NoPos, pkg, "Add",
		types.NewSignatureType(i64Recv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "delta", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	int64AtomicType.AddMethod(types.NewFunc(token.NoPos, pkg, "Swap",
		types.NewSignatureType(i64Recv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "new_", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	int64AtomicType.AddMethod(types.NewFunc(token.NoPos, pkg, "CompareAndSwap",
		types.NewSignatureType(i64Recv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "old", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "new_", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// type Uint32, Uint64, Uintptr struct {} — similar pattern
	uint32AtomicStruct := types.NewStruct(nil, nil)
	uint32AtomicType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Uint32", nil),
		uint32AtomicStruct, nil)
	scope.Insert(uint32AtomicType.Obj())

	uint64AtomicStruct := types.NewStruct(nil, nil)
	uint64AtomicType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Uint64", nil),
		uint64AtomicStruct, nil)
	scope.Insert(uint64AtomicType.Obj())

	uintptrAtomicStruct := types.NewStruct(nil, nil)
	uintptrAtomicType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Uintptr", nil),
		uintptrAtomicStruct, nil)
	scope.Insert(uintptrAtomicType.Obj())

	// type Pointer[T any] struct {} — simplified as struct
	pointerAtomicStruct := types.NewStruct(nil, nil)
	pointerAtomicType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Pointer", nil),
		pointerAtomicStruct, nil)
	scope.Insert(pointerAtomicType.Obj())

	pkg.MarkComplete()
	return pkg
}

// buildBufioPackage creates the type-checked bufio package stub.
func buildBufioPackage() *types.Package {
	pkg := types.NewPackage("bufio", "bufio")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	byteSliceIO := types.NewSlice(types.Typ[types.Byte])

	// io.Reader interface
	readerType := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSliceIO)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	readerType.Complete()

	// io.Writer interface
	writerType := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSliceIO)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	writerType.Complete()

	// type Scanner struct { ... }
	scannerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "src", readerType, false),
	}, nil)
	scannerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Scanner", nil),
		scannerStruct, nil)
	scope.Insert(scannerType.Obj())
	scannerPtr := types.NewPointer(scannerType)

	// func NewScanner(r io.Reader) *Scanner
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewScanner",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", readerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", scannerPtr)),
			false)))

	// type Reader struct { ... }
	readerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "rd", readerType, false),
	}, nil)
	bufReaderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Reader", nil),
		readerStruct, nil)
	scope.Insert(bufReaderType.Obj())
	bufReaderPtr := types.NewPointer(bufReaderType)

	// func NewReader(rd io.Reader) *Reader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "rd", readerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", bufReaderPtr)),
			false)))

	// type Writer struct { ... }
	writerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "wr", writerType, false),
	}, nil)
	bufWriterType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Writer", nil),
		writerStruct, nil)
	scope.Insert(bufWriterType.Obj())
	bufWriterPtr := types.NewPointer(bufWriterType)

	// func NewWriter(w io.Writer) *Writer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", writerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", bufWriterPtr)),
			false)))

	// func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ScanLines",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "atEOF", types.Typ[types.Bool])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "advance", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "token_", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func ScanWords similar signature
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ScanWords",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "atEOF", types.Typ[types.Bool])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "advance", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "token_", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func ScanRunes similar signature
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ScanRunes",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "atEOF", types.Typ[types.Bool])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "advance", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "token_", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func ScanBytes similar signature
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ScanBytes",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "atEOF", types.Typ[types.Bool])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "advance", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "token_", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func NewReaderSize(rd io.Reader, size int) *Reader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReaderSize",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "rd", readerType),
				types.NewVar(token.NoPos, pkg, "size", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", bufReaderPtr)),
			false)))

	// func NewWriterSize(w io.Writer, size int) *Writer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriterSize",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", writerType),
				types.NewVar(token.NoPos, pkg, "size", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", bufWriterPtr)),
			false)))

	// SplitFunc type
	byteSlice := types.NewSlice(types.Typ[types.Byte])
	splitFuncSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, nil, "data", byteSlice),
			types.NewVar(token.NoPos, nil, "atEOF", types.Typ[types.Bool])),
		types.NewTuple(
			types.NewVar(token.NoPos, nil, "advance", types.Typ[types.Int]),
			types.NewVar(token.NoPos, nil, "token", byteSlice),
			types.NewVar(token.NoPos, nil, "err", errType)),
		false)

	// Scanner methods
	scanRecv := types.NewVar(token.NoPos, pkg, "s", scannerPtr)
	scannerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Scan",
		types.NewSignatureType(scanRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	scannerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Text",
		types.NewSignatureType(scanRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scannerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Bytes",
		types.NewSignatureType(scanRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
			false)))
	scannerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Err",
		types.NewSignatureType(scanRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	scannerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Split",
		types.NewSignatureType(scanRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "split", splitFuncSig)),
			nil, false)))
	scannerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Buffer",
		types.NewSignatureType(scanRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "buf", byteSlice),
				types.NewVar(token.NoPos, nil, "max", types.Typ[types.Int])),
			nil, false)))

	// Reader methods
	readRecv := types.NewVar(token.NoPos, pkg, "b", bufReaderPtr)
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(readRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadByte",
		types.NewSignatureType(readRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadString",
		types.NewSignatureType(readRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "delim", types.Typ[types.Byte])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadLine",
		types.NewSignatureType(readRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "line", byteSlice),
				types.NewVar(token.NoPos, nil, "isPrefix", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadRune",
		types.NewSignatureType(readRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "r", types.Typ[types.Rune]),
				types.NewVar(token.NoPos, nil, "size", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnreadByte",
		types.NewSignatureType(readRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnreadRune",
		types.NewSignatureType(readRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Peek",
		types.NewSignatureType(readRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", byteSlice),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Buffered",
		types.NewSignatureType(readRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(readRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "r", readerType)),
			nil, false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadBytes",
		types.NewSignatureType(readRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "delim", types.Typ[types.Byte])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", byteSlice),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadSlice",
		types.NewSignatureType(readRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "delim", types.Typ[types.Byte])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "line", byteSlice),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteTo",
		types.NewSignatureType(readRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "w", writerType)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Discard",
		types.NewSignatureType(readRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "discarded", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	bufReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Size",
		types.NewSignatureType(readRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// Writer methods
	writeRecv := types.NewVar(token.NoPos, pkg, "b", bufWriterPtr)
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(writeRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "nn", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteByte",
		types.NewSignatureType(writeRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "c", types.Typ[types.Byte])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteString",
		types.NewSignatureType(writeRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteRune",
		types.NewSignatureType(writeRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "r", types.Typ[types.Rune])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "size", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Flush",
		types.NewSignatureType(writeRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Available",
		types.NewSignatureType(writeRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Buffered",
		types.NewSignatureType(writeRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(writeRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "w", writerType)),
			nil, false)))
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadFrom",
		types.NewSignatureType(writeRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "r", readerType)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "AvailableBuffer",
		types.NewSignatureType(writeRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
			false)))
	bufWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Size",
		types.NewSignatureType(writeRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// type ReadWriter struct
	bufRWType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "ReadWriter", nil), types.NewStruct(nil, nil), nil)
	scope.Insert(bufRWType.Obj())

	// func NewReadWriter(r *Reader, w *Writer) *ReadWriter
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReadWriter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", bufReaderPtr),
				types.NewVar(token.NoPos, pkg, "w", bufWriterPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewPointer(bufRWType))),
			false)))

	// MaxScanTokenSize constant
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxScanTokenSize", types.Typ[types.Int], constant.MakeInt64(65536)))

	// ErrTooLong etc.
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrTooLong", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrNegativeAdvance", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrAdvanceTooFar", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrBadReadCount", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrFinalToken", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrBufferFull", errType))

	pkg.MarkComplete()
	return pkg
}

// buildNetURLPackage creates the type-checked net/url package stub.
func buildNetURLPackage() *types.Package {
	pkg := types.NewPackage("net/url", "url")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// type Userinfo (forward declare for URL struct)
	userinfoStruct := types.NewStruct(nil, nil)
	userinfoType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Userinfo", nil),
		userinfoStruct, nil)
	scope.Insert(userinfoType.Obj())
	userinfoPtr := types.NewPointer(userinfoType)

	// type URL struct
	urlStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Scheme", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Opaque", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "User", userinfoPtr, false),
		types.NewField(token.NoPos, pkg, "Host", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Path", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "RawPath", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "OmitHost", types.Typ[types.Bool], false),
		types.NewField(token.NoPos, pkg, "ForceQuery", types.Typ[types.Bool], false),
		types.NewField(token.NoPos, pkg, "RawQuery", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Fragment", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "RawFragment", types.Typ[types.String], false),
	}, nil)
	urlType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "URL", nil),
		urlStruct, nil)
	scope.Insert(urlType.Obj())
	urlPtr := types.NewPointer(urlType)

	// func Parse(rawURL string) (*URL, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Parse",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "rawURL", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", urlPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func QueryEscape(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "QueryEscape",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func QueryUnescape(s string) (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "QueryUnescape",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func PathEscape(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "PathEscape",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func PathUnescape(s string) (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "PathUnescape",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// type Values map[string][]string
	valuesType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Values", nil),
		types.NewMap(types.Typ[types.String], types.NewSlice(types.Typ[types.String])), nil)
	scope.Insert(valuesType.Obj())

	// func ParseQuery(query string) (Values, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseQuery",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", valuesType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ParseRequestURI(rawURL string) (*URL, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseRequestURI",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "rawURL", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", urlPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func User(username string) *Userinfo
	scope.Insert(types.NewFunc(token.NoPos, pkg, "User",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "username", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", userinfoPtr)),
			false)))

	// func UserPassword(username, password string) *Userinfo
	scope.Insert(types.NewFunc(token.NoPos, pkg, "UserPassword",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "username", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "password", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", userinfoPtr)),
			false)))

	// URL methods
	urlRecv := types.NewVar(token.NoPos, nil, "u", urlPtr)

	// func (*URL) String() string
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(urlRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (*URL) Query() Values
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "Query",
		types.NewSignatureType(urlRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valuesType)),
			false)))

	// func (*URL) Hostname() string
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "Hostname",
		types.NewSignatureType(urlRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (*URL) Port() string
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "Port",
		types.NewSignatureType(urlRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (*URL) RequestURI() string
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "RequestURI",
		types.NewSignatureType(urlRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (*URL) EscapedPath() string
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "EscapedPath",
		types.NewSignatureType(urlRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (*URL) EscapedFragment() string
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "EscapedFragment",
		types.NewSignatureType(urlRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (*URL) Redacted() string
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "Redacted",
		types.NewSignatureType(urlRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (*URL) IsAbs() bool
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsAbs",
		types.NewSignatureType(urlRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func (*URL) ResolveReference(ref *URL) *URL
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "ResolveReference",
		types.NewSignatureType(urlRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "ref", urlPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", urlPtr)),
			false)))

	// func (*URL) MarshalBinary() ([]byte, error)
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "MarshalBinary",
		types.NewSignatureType(urlRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func (*URL) UnmarshalBinary(text []byte) error
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnmarshalBinary",
		types.NewSignatureType(urlRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "text", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Values methods
	valuesRecv := types.NewVar(token.NoPos, nil, "v", valuesType)

	// func (Values) Get(key string) string
	valuesType.AddMethod(types.NewFunc(token.NoPos, pkg, "Get",
		types.NewSignatureType(valuesRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (Values) Set(key, value string)
	valuesType.AddMethod(types.NewFunc(token.NoPos, pkg, "Set",
		types.NewSignatureType(valuesRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.String])),
			nil, false)))

	// func (Values) Add(key, value string)
	valuesType.AddMethod(types.NewFunc(token.NoPos, pkg, "Add",
		types.NewSignatureType(valuesRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.String])),
			nil, false)))

	// func (Values) Del(key string)
	valuesType.AddMethod(types.NewFunc(token.NoPos, pkg, "Del",
		types.NewSignatureType(valuesRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String])),
			nil, false)))

	// func (Values) Has(key string) bool
	valuesType.AddMethod(types.NewFunc(token.NoPos, pkg, "Has",
		types.NewSignatureType(valuesRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func (Values) Encode() string
	valuesType.AddMethod(types.NewFunc(token.NoPos, pkg, "Encode",
		types.NewSignatureType(valuesRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// Userinfo methods
	uiRecv := types.NewVar(token.NoPos, nil, "u", userinfoPtr)

	// func (*Userinfo) Username() string
	userinfoType.AddMethod(types.NewFunc(token.NoPos, pkg, "Username",
		types.NewSignatureType(uiRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (*Userinfo) Password() (string, bool)
	userinfoType.AddMethod(types.NewFunc(token.NoPos, pkg, "Password",
		types.NewSignatureType(uiRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func (*Userinfo) String() string
	userinfoType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(uiRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// type Error struct { Op, URL string; Err error }
	urlErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Op", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "URL", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Err", errType, false),
	}, nil)
	urlErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Error", nil),
		urlErrStruct, nil)
	urlErrPtr := types.NewPointer(urlErrType)
	urlErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", urlErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	urlErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Unwrap",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", urlErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	urlErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Timeout",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", urlErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	urlErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Temporary",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", urlErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	scope.Insert(urlErrType.Obj())

	// func (*URL) JoinPath(elem ...string) *URL
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "JoinPath",
		types.NewSignatureType(urlRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "elem",
				types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", urlPtr)),
			true)))

	// func (*URL) Parse(ref string) (*URL, error)
	urlType.AddMethod(types.NewFunc(token.NoPos, pkg, "Parse",
		types.NewSignatureType(urlRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "ref", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", urlPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func JoinPath(base string, elem ...string) (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "JoinPath",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "base", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "elem", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// EscapeError (returned by invalid escape sequences)
	escapeErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "EscapeError", nil),
		types.Typ[types.String], nil)
	scope.Insert(escapeErrType.Obj())
	escapeErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", escapeErrType), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// InvalidHostError
	invalidHostErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "InvalidHostError", nil),
		types.Typ[types.String], nil)
	scope.Insert(invalidHostErrType.Obj())
	invalidHostErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", invalidHostErrType), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildEncodingJSONPackage creates the type-checked encoding/json package stub.
func buildEncodingJSONPackage() *types.Package {
	pkg := types.NewPackage("encoding/json", "json")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	anyType := types.NewInterfaceType(nil, nil)

	// func Marshal(v any) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Marshal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "v", anyType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func MarshalIndent(v any, prefix, indent string) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MarshalIndent",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "v", anyType),
				types.NewVar(token.NoPos, pkg, "prefix", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "indent", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Unmarshal(data []byte, v any) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Unmarshal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "v", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Valid(data []byte) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Valid",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Compact(dst *bytes.Buffer, src []byte) error — simplified
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Compact",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", anyType),
				types.NewVar(token.NoPos, pkg, "src", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Indent",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", anyType),
				types.NewVar(token.NoPos, pkg, "src", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "prefix", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "indent", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func HTMLEscape(dst *bytes.Buffer, src []byte)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "HTMLEscape",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", anyType),
				types.NewVar(token.NoPos, pkg, "src", types.NewSlice(types.Typ[types.Byte]))),
			nil, false)))

	// io.Writer interface for NewEncoder
	ioWriterJSON := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte]))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioWriterJSON.Complete()

	// io.Reader interface for NewDecoder
	ioReaderJSON := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte]))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioReaderJSON.Complete()

	// type Encoder struct {}
	encoderStruct := types.NewStruct(nil, nil)
	encoderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Encoder", nil),
		encoderStruct, nil)
	scope.Insert(encoderType.Obj())
	encoderPtr := types.NewPointer(encoderType)

	// func NewEncoder(w io.Writer) *Encoder
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewEncoder",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriterJSON)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", encoderPtr)),
			false)))

	// Encoder methods
	encRecv := types.NewVar(token.NoPos, nil, "enc", encoderPtr)
	encoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Encode",
		types.NewSignatureType(encRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "v", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	encoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetIndent",
		types.NewSignatureType(encRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "prefix", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "indent", types.Typ[types.String])),
			nil, false)))
	encoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetEscapeHTML",
		types.NewSignatureType(encRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "on", types.Typ[types.Bool])),
			nil, false)))

	// type Decoder struct {}
	decoderStruct := types.NewStruct(nil, nil)
	decoderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Decoder", nil),
		decoderStruct, nil)
	scope.Insert(decoderType.Obj())
	decoderPtr := types.NewPointer(decoderType)

	// func NewDecoder(r io.Reader) *Decoder
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewDecoder",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", ioReaderJSON)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", decoderPtr)),
			false)))

	// Decoder methods
	decRecv := types.NewVar(token.NoPos, nil, "dec", decoderPtr)
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Decode",
		types.NewSignatureType(decRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "v", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "More",
		types.NewSignatureType(decRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "UseNumber",
		types.NewSignatureType(decRecv, nil, nil, nil, nil, false)))
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "DisallowUnknownFields",
		types.NewSignatureType(decRecv, nil, nil, nil, nil, false)))
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Token",
		types.NewSignatureType(decRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", anyType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Buffered",
		types.NewSignatureType(decRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ioReaderJSON)),
			false)))
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "InputOffset",
		types.NewSignatureType(decRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64])),
			false)))

	// type Number string
	numberType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Number", nil),
		types.Typ[types.String], nil)
	scope.Insert(numberType.Obj())

	// type RawMessage []byte
	rawMsgType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "RawMessage", nil),
		types.NewSlice(types.Typ[types.Byte]), nil)
	scope.Insert(rawMsgType.Obj())

	// Marshaler interface: MarshalJSON() ([]byte, error)
	byteSlice := types.NewSlice(types.Typ[types.Byte])
	marshalerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "MarshalJSON",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", byteSlice),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	marshalerIface.Complete()
	marshalerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Marshaler", nil),
		marshalerIface, nil)
	scope.Insert(marshalerType.Obj())

	// Unmarshaler interface: UnmarshalJSON([]byte) error
	unmarshalerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "UnmarshalJSON",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "data", byteSlice)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	unmarshalerIface.Complete()
	unmarshalerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Unmarshaler", nil),
		unmarshalerIface, nil)
	scope.Insert(unmarshalerType.Obj())

	// Number methods
	numberType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "n", numberType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	numberType.AddMethod(types.NewFunc(token.NoPos, pkg, "Float64",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "n", numberType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	numberType.AddMethod(types.NewFunc(token.NoPos, pkg, "Int64",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "n", numberType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// type Delim rune
	delimType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Delim", nil),
		types.Typ[types.Rune], nil)
	scope.Insert(delimType.Obj())

	// type Token interface{}
	tokenIface := types.NewInterfaceType(nil, nil)
	tokenIface.Complete()
	tokenType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Token", nil),
		tokenIface, nil)
	scope.Insert(tokenType.Obj())

	// type SyntaxError struct { Offset int64; msg string }
	syntaxErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Offset", types.Typ[types.Int64], false),
	}, nil)
	syntaxErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "SyntaxError", nil),
		syntaxErrStruct, nil)
	scope.Insert(syntaxErrType.Obj())
	syntaxErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "e", types.NewPointer(syntaxErrType)),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// type UnmarshalTypeError struct { Value string; Type reflect.Type; Offset int64; Struct string; Field string }
	unmarshalTypeErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Value", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Offset", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "Struct", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Field", types.Typ[types.String], false),
	}, nil)
	unmarshalTypeErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "UnmarshalTypeError", nil),
		unmarshalTypeErrStruct, nil)
	scope.Insert(unmarshalTypeErrType.Obj())
	unmarshalTypeErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "e", types.NewPointer(unmarshalTypeErrType)),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// type InvalidUnmarshalError struct { Type reflect.Type }
	invalidUnmarshalErrStruct := types.NewStruct([]*types.Var{}, nil)
	invalidUnmarshalErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "InvalidUnmarshalError", nil),
		invalidUnmarshalErrStruct, nil)
	scope.Insert(invalidUnmarshalErrType.Obj())
	invalidUnmarshalErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "e", types.NewPointer(invalidUnmarshalErrType)),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// type MarshalerError struct {}
	marshalerErrStruct := types.NewStruct([]*types.Var{}, nil)
	marshalerErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "MarshalerError", nil),
		marshalerErrStruct, nil)
	scope.Insert(marshalerErrType.Obj())
	marshalerErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "e", types.NewPointer(marshalerErrType)),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	marshalerErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Unwrap",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "e", types.NewPointer(marshalerErrType)),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// type UnsupportedTypeError struct { Type reflect.Type }
	unsupportedTypeErrStruct := types.NewStruct([]*types.Var{}, nil)
	unsupportedTypeErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "UnsupportedTypeError", nil),
		unsupportedTypeErrStruct, nil)
	scope.Insert(unsupportedTypeErrType.Obj())
	unsupportedTypeErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "e", types.NewPointer(unsupportedTypeErrType)),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// type UnsupportedValueError struct { Value reflect.Value; Str string }
	unsupportedValueErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Str", types.Typ[types.String], false),
	}, nil)
	unsupportedValueErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "UnsupportedValueError", nil),
		unsupportedValueErrStruct, nil)
	scope.Insert(unsupportedValueErrType.Obj())
	unsupportedValueErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "e", types.NewPointer(unsupportedValueErrType)),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// RawMessage methods: MarshalJSON, UnmarshalJSON
	rawMsgType.AddMethod(types.NewFunc(token.NoPos, pkg, "MarshalJSON",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "m", rawMsgType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	rawMsgType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnmarshalJSON",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "m", types.NewPointer(rawMsgType)),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "data", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildRuntimePackage creates the type-checked runtime package stub.
func buildRuntimePackage() *types.Package {
	pkg := types.NewPackage("runtime", "runtime")
	scope := pkg.Scope()

	// func GOMAXPROCS(n int) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "GOMAXPROCS",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func NumCPU() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NumCPU",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func NumGoroutine() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NumGoroutine",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Gosched()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Gosched",
		types.NewSignatureType(nil, nil, nil, nil, nil, false)))

	// func GC()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "GC",
		types.NewSignatureType(nil, nil, nil, nil, nil, false)))

	// func Goexit()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Goexit",
		types.NewSignatureType(nil, nil, nil, nil, nil, false)))

	// var GOOS string
	scope.Insert(types.NewVar(token.NoPos, pkg, "GOOS", types.Typ[types.String]))

	// var GOARCH string
	scope.Insert(types.NewVar(token.NoPos, pkg, "GOARCH", types.Typ[types.String]))

	// func Caller(skip int) (pc uintptr, file string, line int, ok bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Caller",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "skip", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "pc", types.Typ[types.Uintptr]),
				types.NewVar(token.NoPos, pkg, "file", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "line", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "ok", types.Typ[types.Bool])),
			false)))

	// func Callers(skip int, pc []uintptr) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Callers",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "skip", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "pc", types.NewSlice(types.Typ[types.Uintptr]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func GOROOT() string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "GOROOT",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Version() string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Version",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func SetFinalizer(obj any, finalizer any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SetFinalizer",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "obj", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "finalizer", types.NewInterfaceType(nil, nil))),
			nil, false)))

	// func KeepAlive(x any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "KeepAlive",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.NewInterfaceType(nil, nil))),
			nil, false)))

	// func LockOSThread()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LockOSThread",
		types.NewSignatureType(nil, nil, nil, nil, nil, false)))

	// func UnlockOSThread()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "UnlockOSThread",
		types.NewSignatureType(nil, nil, nil, nil, nil, false)))

	// func Stack(buf []byte, all bool) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Stack",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "all", types.Typ[types.Bool])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// type MemStats struct { ... }
	memStatsStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Alloc", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "TotalAlloc", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "Sys", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "Lookups", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "Mallocs", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "Frees", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "HeapAlloc", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "HeapSys", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "HeapIdle", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "HeapInuse", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "HeapReleased", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "HeapObjects", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "NumGC", types.Typ[types.Uint32], false),
		types.NewField(token.NoPos, pkg, "GCCPUFraction", types.Typ[types.Float64], false),
	}, nil)
	memStatsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "MemStats", nil),
		memStatsStruct, nil)
	scope.Insert(memStatsType.Obj())

	// func ReadMemStats(m *MemStats)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadMemStats",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "m", types.NewPointer(memStatsType))),
			nil, false)))

	// type Frame struct { PC uintptr; Func *Func; Function string; File string; Line int; Entry uintptr }
	// type Func struct {}
	funcStruct := types.NewStruct(nil, nil)
	funcType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Func", nil),
		funcStruct, nil)
	scope.Insert(funcType.Obj())
	funcPtr := types.NewPointer(funcType)

	funcType.AddMethod(types.NewFunc(token.NoPos, pkg, "Name",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "f", funcPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	funcType.AddMethod(types.NewFunc(token.NoPos, pkg, "Entry",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "f", funcPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uintptr])),
			false)))
	funcType.AddMethod(types.NewFunc(token.NoPos, pkg, "FileLine",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "f", funcPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "pc", types.Typ[types.Uintptr])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "file", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "line", types.Typ[types.Int])),
			false)))

	// func FuncForPC(pc uintptr) *Func
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FuncForPC",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "pc", types.Typ[types.Uintptr])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", funcPtr)),
			false)))

	// type Frames struct {}
	framesStruct := types.NewStruct(nil, nil)
	framesType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Frames", nil),
		framesStruct, nil)
	scope.Insert(framesType.Obj())
	framesPtr := types.NewPointer(framesType)

	frameStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "PC", types.Typ[types.Uintptr], false),
		types.NewField(token.NoPos, pkg, "Func", funcPtr, false),
		types.NewField(token.NoPos, pkg, "Function", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "File", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Line", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Entry", types.Typ[types.Uintptr], false),
	}, nil)
	frameType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Frame", nil),
		frameStruct, nil)
	scope.Insert(frameType.Obj())

	// (*Frames).Next() (frame Frame, more bool)
	framesType.AddMethod(types.NewFunc(token.NoPos, pkg, "Next",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "ci", framesPtr),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "frame", frameType),
				types.NewVar(token.NoPos, nil, "more", types.Typ[types.Bool])),
			false)))

	// func CallersFrames(callers []uintptr) *Frames
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CallersFrames",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "callers", types.NewSlice(types.Typ[types.Uintptr]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", framesPtr)),
			false)))

	// type Error interface { RuntimeError(); Error() string }
	runtimeErrorIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "RuntimeError",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, pkg, "Error",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
				false)),
	}, nil)
	runtimeErrorIface.Complete()
	runtimeErrorType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Error", nil),
		runtimeErrorIface, nil)
	scope.Insert(runtimeErrorType.Obj())

	// Compiler variable
	scope.Insert(types.NewVar(token.NoPos, pkg, "Compiler", types.Typ[types.String]))

	pkg.MarkComplete()
	return pkg
}

// buildReflectPackage creates a minimal type-checked reflect package stub.
func buildReflectPackage() *types.Package {
	pkg := types.NewPackage("reflect", "reflect")
	scope := pkg.Scope()

	// type Kind uint
	kindType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Kind", nil),
		types.Typ[types.Uint], nil)
	scope.Insert(kindType.Obj())

	// type StructField struct
	structFieldType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "StructField", nil),
		types.NewStruct([]*types.Var{
			types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "PkgPath", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "Tag", types.NewNamed(
				types.NewTypeName(token.NoPos, pkg, "StructTag", nil),
				types.Typ[types.String], nil), false),
			types.NewField(token.NoPos, pkg, "Index", types.NewSlice(types.Typ[types.Int]), false),
			types.NewField(token.NoPos, pkg, "Anonymous", types.Typ[types.Bool], false),
		}, nil), nil)
	scope.Insert(structFieldType.Obj())

	// type StructTag string (already nested above, define separately too)
	structTagType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "StructTag", nil),
		types.Typ[types.String], nil)
	scope.Insert(structTagType.Obj())
	structTagType.AddMethod(types.NewFunc(token.NoPos, pkg, "Get",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "tag", structTagType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))
	structTagType.AddMethod(types.NewFunc(token.NoPos, pkg, "Lookup",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "tag", structTagType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)))

	// type ChanDir int
	chanDirType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ChanDir", nil),
		types.Typ[types.Int], nil)
	scope.Insert(chanDirType.Obj())

	// type Method struct
	methodStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "PkgPath", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Index", types.Typ[types.Int], false),
	}, nil)
	methodType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Method", nil),
		methodStruct, nil)
	scope.Insert(methodType.Obj())

	// type Type interface { ... } - forward declare, then populate
	typeIface := types.NewInterfaceType(nil, nil)
	typeIface.Complete()
	typeType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Type", nil),
		typeIface, nil)

	// Populate Type interface with methods
	typeIfaceReal := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Align",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "FieldAlign",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "Method",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", methodType)), false)),
		types.NewFunc(token.NoPos, pkg, "MethodByName",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", methodType),
					types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "NumMethod",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "Name",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)),
		types.NewFunc(token.NoPos, pkg, "PkgPath",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)),
		types.NewFunc(token.NoPos, pkg, "Size",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uintptr])), false)),
		types.NewFunc(token.NoPos, pkg, "String",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)),
		types.NewFunc(token.NoPos, pkg, "Kind",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", kindType)), false)),
		types.NewFunc(token.NoPos, pkg, "Implements",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "u", typeType)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "AssignableTo",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "u", typeType)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "ConvertibleTo",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "u", typeType)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Comparable",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Bits",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "ChanDir",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", chanDirType)), false)),
		types.NewFunc(token.NoPos, pkg, "IsVariadic",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Elem",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", typeType)), false)),
		types.NewFunc(token.NoPos, pkg, "Field",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", structFieldType)), false)),
		types.NewFunc(token.NoPos, pkg, "FieldByIndex",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "index", types.NewSlice(types.Typ[types.Int]))),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", structFieldType)), false)),
		types.NewFunc(token.NoPos, pkg, "FieldByName",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", structFieldType),
					types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "NumField",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "In",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", typeType)), false)),
		types.NewFunc(token.NoPos, pkg, "Key",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", typeType)), false)),
		types.NewFunc(token.NoPos, pkg, "Len",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "NumIn",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "NumOut",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "Out",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", typeType)), false)),
	}, nil)
	typeIfaceReal.Complete()
	typeType.SetUnderlying(typeIfaceReal)
	scope.Insert(typeType.Obj())

	// type Value struct { ... }
	valueStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "val", types.Typ[types.Int], false),
	}, nil)
	valueType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Value", nil),
		valueStruct, nil)
	scope.Insert(valueType.Obj())

	// func TypeOf(i any) Type
	anyType := types.NewInterfaceType(nil, nil)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TypeOf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "i", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", typeType)),
			false)))

	// func ValueOf(i any) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ValueOf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "i", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// func DeepEqual(x, y any) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DeepEqual",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", anyType),
				types.NewVar(token.NoPos, pkg, "y", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Zero(typ Type) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Zero",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "typ", typeType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// func New(typ Type) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "typ", typeType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// func MakeSlice(typ Type, len, cap int) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MakeSlice",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "typ", typeType),
				types.NewVar(token.NoPos, pkg, "len", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "cap", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// func MakeMap(typ Type) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MakeMap",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "typ", typeType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// func MakeMapWithSize(typ Type, n int) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MakeMapWithSize",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "typ", typeType),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// func MakeChan(typ Type, buffer int) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MakeChan",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "typ", typeType),
				types.NewVar(token.NoPos, pkg, "buffer", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// func Indirect(v Value) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Indirect",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "v", valueType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// func Append(s Value, x ...Value) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Append",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", valueType),
				types.NewVar(token.NoPos, pkg, "x", types.NewSlice(valueType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			true)))

	// func AppendSlice(s, t Value) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendSlice",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", valueType),
				types.NewVar(token.NoPos, pkg, "t", valueType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// func Copy(dst, src Value) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Copy",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dst", valueType),
				types.NewVar(token.NoPos, pkg, "src", valueType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Swapper(slice any) func(i, j int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Swapper",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "slice", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "",
				types.NewSignatureType(nil, nil, nil,
					types.NewTuple(
						types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int]),
						types.NewVar(token.NoPos, nil, "j", types.Typ[types.Int])),
					nil, false))),
			false)))

	// func PtrTo(t Type) Type (deprecated alias for PointerTo)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "PtrTo",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "t", typeType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", typeType)),
			false)))

	// func PointerTo(t Type) Type
	scope.Insert(types.NewFunc(token.NoPos, pkg, "PointerTo",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "t", typeType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", typeType)),
			false)))

	// func SliceOf(t Type) Type
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SliceOf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "t", typeType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", typeType)),
			false)))

	// func MapOf(key, elem Type) Type
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MapOf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", typeType),
				types.NewVar(token.NoPos, pkg, "elem", typeType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", typeType)),
			false)))

	// func ChanOf(dir ChanDir, t Type) Type — ChanDir is int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ChanOf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dir", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "t", typeType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", typeType)),
			false)))

	// Value methods
	valuePtr := types.NewPointer(valueType)
	_ = valuePtr
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Int",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Float",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Float64])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Bool",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Bytes",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Byte]))),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Interface",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", anyType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Kind",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", kindType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Type",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", typeType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsNil",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsValid",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsZero",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Elem",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Field",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "FieldByName",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Index",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Len",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cap",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "MapKeys",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(valueType))),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "MapIndex",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", valueType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "NumField",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "NumMethod",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Set",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", valueType)),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetInt",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.Typ[types.Int64])),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetString",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.Typ[types.String])),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetFloat",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.Typ[types.Float64])),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetBool",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.Typ[types.Bool])),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetBytes",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.NewSlice(types.Typ[types.Byte]))),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "CanSet",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "CanInterface",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "CanAddr",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Addr",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Pointer",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uintptr])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetMapIndex",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", valueType),
				types.NewVar(token.NoPos, nil, "elem", valueType)),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Slice",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "j", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Call",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "in", types.NewSlice(valueType))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(valueType))),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "CallSlice",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "in", types.NewSlice(valueType))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(valueType))),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Uint",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uint64])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetUint",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.Typ[types.Uint64])),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Convert",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "t", typeType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "MapRange",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewPointer(valueType))),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetLen",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetCap",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			nil, false)))

	// More Value methods
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "FieldByIndex",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "index", types.NewSlice(types.Typ[types.Int]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "FieldByNameFunc",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "match",
				types.NewSignatureType(nil, nil, nil,
					types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
					types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
					false))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Method",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "MethodByName",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", valueType),
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Recv",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "x", valueType),
				types.NewVar(token.NoPos, nil, "ok", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Send",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", valueType)),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "TrySend",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", valueType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "TryRecv",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "x", valueType),
				types.NewVar(token.NoPos, nil, "ok", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil, nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetPointer",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.Typ[types.UnsafePointer])),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnsafeAddr",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uintptr])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "UnsafePointer",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.UnsafePointer])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "OverflowFloat",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "OverflowInt",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "OverflowUint",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.Typ[types.Uint64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Complex",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Complex128])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetComplex",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.Typ[types.Complex128])),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Comparable",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "u", valueType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "Grow",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			nil, false)))
	valueType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetZero",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "v", valueType),
			nil, nil, nil, nil, false)))

	// (StructField, StructTag, Method types now defined earlier for Type interface)
	// Add Type and Func fields to StructField via the more complete definition
	// StructTag methods already defined above
	// Method already defined above with simpler form; add extra fields via later use

	// type SelectDir int
	selectDirType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "SelectDir", nil),
		types.Typ[types.Int], nil)
	scope.Insert(selectDirType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "SelectSend", selectDirType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SelectRecv", selectDirType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SelectDefault", selectDirType, constant.MakeInt64(3)))

	// type SelectCase struct { Dir SelectDir; Chan Value; Send Value }
	selectCaseStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Dir", selectDirType, false),
		types.NewField(token.NoPos, pkg, "Chan", valueType, false),
		types.NewField(token.NoPos, pkg, "Send", valueType, false),
	}, nil)
	selectCaseType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "SelectCase", nil),
		selectCaseStruct, nil)
	scope.Insert(selectCaseType.Obj())

	// func Select(cases []SelectCase) (chosen int, value Value, ok bool)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Select",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "cases", types.NewSlice(selectCaseType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "chosen", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "value", valueType),
				types.NewVar(token.NoPos, pkg, "ok", types.Typ[types.Bool])),
			false)))

	// func FuncOf(in, out []Type, variadic bool) Type
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FuncOf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "in", types.NewSlice(typeType)),
				types.NewVar(token.NoPos, pkg, "out", types.NewSlice(typeType)),
				types.NewVar(token.NoPos, pkg, "variadic", types.Typ[types.Bool])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", typeType)),
			false)))

	// func StructOf(fields []StructField) Type
	scope.Insert(types.NewFunc(token.NoPos, pkg, "StructOf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "fields", types.NewSlice(structFieldType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", typeType)),
			false)))

	// func ArrayOf(length int, elem Type) Type
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ArrayOf",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "length", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "elem", typeType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", typeType)),
			false)))

	// func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MakeFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "typ", typeType),
				types.NewVar(token.NoPos, pkg, "fn",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "args", types.NewSlice(valueType))),
						types.NewTuple(types.NewVar(token.NoPos, nil, "results", types.NewSlice(valueType))),
						false))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// func NewAt(typ Type, p unsafe.Pointer) Value
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewAt",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "typ", typeType),
				types.NewVar(token.NoPos, pkg, "p", types.Typ[types.UnsafePointer])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", valueType)),
			false)))

	// type MapIter struct{}
	mapIterStruct := types.NewStruct(nil, nil)
	mapIterType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "MapIter", nil),
		mapIterStruct, nil)
	scope.Insert(mapIterType.Obj())
	mapIterPtr := types.NewPointer(mapIterType)
	mapIterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Key",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "it", mapIterPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	mapIterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Value",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "it", mapIterPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", valueType)),
			false)))
	mapIterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Next",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "it", mapIterPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	mapIterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "it", mapIterPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "m", valueType)),
			nil, false)))

	// type SliceHeader struct { Data uintptr; Len int; Cap int }
	sliceHeaderStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Data", types.Typ[types.Uintptr], false),
		types.NewField(token.NoPos, pkg, "Len", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Cap", types.Typ[types.Int], false),
	}, nil)
	sliceHeaderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "SliceHeader", nil),
		sliceHeaderStruct, nil)
	scope.Insert(sliceHeaderType.Obj())

	// type StringHeader struct { Data uintptr; Len int }
	stringHeaderStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Data", types.Typ[types.Uintptr], false),
		types.NewField(token.NoPos, pkg, "Len", types.Typ[types.Int], false),
	}, nil)
	stringHeaderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "StringHeader", nil),
		stringHeaderStruct, nil)
	scope.Insert(stringHeaderType.Obj())

	// Kind constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "Invalid", kindType, constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Bool", kindType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Int", kindType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Int8", kindType, constant.MakeInt64(3)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Int16", kindType, constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Int32", kindType, constant.MakeInt64(5)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Int64", kindType, constant.MakeInt64(6)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Uint", kindType, constant.MakeInt64(7)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Uint8", kindType, constant.MakeInt64(8)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Uint16", kindType, constant.MakeInt64(9)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Uint32", kindType, constant.MakeInt64(10)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Uint64", kindType, constant.MakeInt64(11)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Uintptr", kindType, constant.MakeInt64(12)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Float32", kindType, constant.MakeInt64(13)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Float64", kindType, constant.MakeInt64(14)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Complex64", kindType, constant.MakeInt64(15)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Complex128", kindType, constant.MakeInt64(16)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Array", kindType, constant.MakeInt64(17)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Chan", kindType, constant.MakeInt64(18)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Func", kindType, constant.MakeInt64(19)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Map", kindType, constant.MakeInt64(21)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Pointer", kindType, constant.MakeInt64(22)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Slice", kindType, constant.MakeInt64(23)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "String", kindType, constant.MakeInt64(24)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Struct", kindType, constant.MakeInt64(25)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "UnsafePointer", kindType, constant.MakeInt64(26)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Ptr", kindType, constant.MakeInt64(22))) // alias for Pointer

	// ChanDir type defined earlier for Type interface; add constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "RecvDir", chanDirType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SendDir", chanDirType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "BothDir", chanDirType, constant.MakeInt64(3)))

	pkg.MarkComplete()
	return pkg
}

// buildTestingPackage creates a minimal type-checked testing package stub.
func buildTestingPackage() *types.Package {
	pkg := types.NewPackage("testing", "testing")
	scope := pkg.Scope()
	anyType := types.NewInterfaceType(nil, nil)

	// type TB interface (common interface for T and B)
	anySliceTB := types.NewSlice(anyType)
	tbIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Error",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "args", anySliceTB)),
				nil, true)),
		types.NewFunc(token.NoPos, pkg, "Errorf",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
					types.NewVar(token.NoPos, nil, "args", anySliceTB)),
				nil, true)),
		types.NewFunc(token.NoPos, pkg, "Fail",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, pkg, "FailNow",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, pkg, "Failed",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Fatal",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "args", anySliceTB)),
				nil, true)),
		types.NewFunc(token.NoPos, pkg, "Fatalf",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
					types.NewVar(token.NoPos, nil, "args", anySliceTB)),
				nil, true)),
		types.NewFunc(token.NoPos, pkg, "Helper",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, pkg, "Log",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "args", anySliceTB)),
				nil, true)),
		types.NewFunc(token.NoPos, pkg, "Logf",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
					types.NewVar(token.NoPos, nil, "args", anySliceTB)),
				nil, true)),
		types.NewFunc(token.NoPos, pkg, "Name",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)),
		types.NewFunc(token.NoPos, pkg, "Skip",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "args", anySliceTB)),
				nil, true)),
		types.NewFunc(token.NoPos, pkg, "SkipNow",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, pkg, "Skipf",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
					types.NewVar(token.NoPos, nil, "args", anySliceTB)),
				nil, true)),
		types.NewFunc(token.NoPos, pkg, "Skipped",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "TempDir",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)),
		types.NewFunc(token.NoPos, pkg, "Cleanup",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "f",
					types.NewSignatureType(nil, nil, nil, nil, nil, false))),
				nil, false)),
	}, nil)
	tbIface.Complete()
	tbType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "TB", nil),
		tbIface, nil)
	scope.Insert(tbType.Obj())

	// type T struct { ... }
	tStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "name", types.Typ[types.String], false),
	}, nil)
	tType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "T", nil),
		tStruct, nil)
	scope.Insert(tType.Obj())
	tPtr := types.NewPointer(tType)
	tRecv := types.NewVar(token.NoPos, nil, "t", tPtr)

	// T methods (common with B)
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Errorf",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fail",
		types.NewSignatureType(tRecv, nil, nil, nil, nil, false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "FailNow",
		types.NewSignatureType(tRecv, nil, nil, nil, nil, false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Failed",
		types.NewSignatureType(tRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fatal",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fatalf",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Helper",
		types.NewSignatureType(tRecv, nil, nil, nil, nil, false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Log",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Logf",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Name",
		types.NewSignatureType(tRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Skip",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "SkipNow",
		types.NewSignatureType(tRecv, nil, nil, nil, nil, false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Skipf",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Skipped",
		types.NewSignatureType(tRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "TempDir",
		types.NewSignatureType(tRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cleanup",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "f",
				types.NewSignatureType(nil, nil, nil, nil, nil, false))),
			nil, false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Setenv",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String])),
			nil, false)))
	// T-specific methods
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Run",
		types.NewSignatureType(tRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "f",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "t", tPtr)),
						nil, false))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Parallel",
		types.NewSignatureType(tRecv, nil, nil, nil, nil, false)))
	tType.AddMethod(types.NewFunc(token.NoPos, pkg, "Deadline",
		types.NewSignatureType(tRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "deadline", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "ok", types.Typ[types.Bool])),
			false)))

	// type B struct { ... }
	bStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "N", types.Typ[types.Int], false),
	}, nil)
	bType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "B", nil),
		bStruct, nil)
	scope.Insert(bType.Obj())
	bPtr := types.NewPointer(bType)
	bRecv := types.NewVar(token.NoPos, nil, "b", bPtr)

	// B methods (common)
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Errorf",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fail",
		types.NewSignatureType(bRecv, nil, nil, nil, nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "FailNow",
		types.NewSignatureType(bRecv, nil, nil, nil, nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Failed",
		types.NewSignatureType(bRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fatal",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Fatalf",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Helper",
		types.NewSignatureType(bRecv, nil, nil, nil, nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Log",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Logf",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Name",
		types.NewSignatureType(bRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Skip",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "SkipNow",
		types.NewSignatureType(bRecv, nil, nil, nil, nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Skipf",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "args", anyType)),
			nil, true)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Skipped",
		types.NewSignatureType(bRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "TempDir",
		types.NewSignatureType(bRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cleanup",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "f",
				types.NewSignatureType(nil, nil, nil, nil, nil, false))),
			nil, false)))
	// B-specific methods
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Run",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "f",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "b", bPtr)),
						nil, false))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "ResetTimer",
		types.NewSignatureType(bRecv, nil, nil, nil, nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "StartTimer",
		types.NewSignatureType(bRecv, nil, nil, nil, nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "StopTimer",
		types.NewSignatureType(bRecv, nil, nil, nil, nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReportAllocs",
		types.NewSignatureType(bRecv, nil, nil, nil, nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetBytes",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int64])),
			nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReportMetric",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, nil, "unit", types.Typ[types.String])),
			nil, false)))

	// type PB struct {}
	pbStruct := types.NewStruct(nil, nil)
	pbType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "PB", nil),
		pbStruct, nil)
	scope.Insert(pbType.Obj())
	pbPtr := types.NewPointer(pbType)
	pbType.AddMethod(types.NewFunc(token.NoPos, pkg, "Next",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "pb", pbPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// B.RunParallel(body func(*PB))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "RunParallel",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "body",
				types.NewSignatureType(nil, nil, nil,
					types.NewTuple(types.NewVar(token.NoPos, nil, "pb", pbPtr)),
					nil, false))),
			nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetParallelism",
		types.NewSignatureType(bRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "p", types.Typ[types.Int])),
			nil, false)))
	bType.AddMethod(types.NewFunc(token.NoPos, pkg, "Elapsed",
		types.NewSignatureType(bRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))

	// type M struct {}
	mStruct := types.NewStruct(nil, nil)
	mType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "M", nil),
		mStruct, nil)
	scope.Insert(mType.Obj())
	mPtr := types.NewPointer(mType)
	mType.AddMethod(types.NewFunc(token.NoPos, pkg, "Run",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "m", mPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// func Short() bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Short",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func Verbose() bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Verbose",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// type BenchmarkResult struct { N int; T time.Duration; Bytes int64; MemAllocs uint64; MemBytes uint64 }
	benchResultStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "N", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "T", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "Bytes", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "MemAllocs", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "MemBytes", types.Typ[types.Uint64], false),
	}, nil)
	benchResultType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "BenchmarkResult", nil),
		benchResultStruct, nil)
	scope.Insert(benchResultType.Obj())

	// BenchmarkResult methods
	brRecv := types.NewVar(token.NoPos, nil, "r", benchResultType)
	benchResultType.AddMethod(types.NewFunc(token.NoPos, pkg, "NsPerOp",
		types.NewSignatureType(brRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	benchResultType.AddMethod(types.NewFunc(token.NoPos, pkg, "AllocsPerOp",
		types.NewSignatureType(brRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	benchResultType.AddMethod(types.NewFunc(token.NoPos, pkg, "AllocedBytesPerOp",
		types.NewSignatureType(brRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))
	benchResultType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(brRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	benchResultType.AddMethod(types.NewFunc(token.NoPos, pkg, "MemString",
		types.NewSignatureType(brRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// func AllocsPerRun(runs int, f func()) float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AllocsPerRun",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "runs", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "f",
					types.NewSignatureType(nil, nil, nil, nil, nil, false))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func Benchmark(f func(b *B)) BenchmarkResult
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Benchmark",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "f",
				types.NewSignatureType(nil, nil, nil,
					types.NewTuple(types.NewVar(token.NoPos, nil, "b", bPtr)),
					nil, false))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", benchResultType)),
			false)))

	// func CoverMode() string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CoverMode",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Coverage() float64
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Coverage",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64])),
			false)))

	// func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)
	// Simplified: not adding InternalTest/etc types, just use Main(m func(string,string)(bool,error), ...)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Main",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "matchString", types.NewSignatureType(nil, nil, nil,
					types.NewTuple(
						types.NewVar(token.NoPos, nil, "pat", types.Typ[types.String]),
						types.NewVar(token.NoPos, nil, "str", types.Typ[types.String])),
					types.NewTuple(
						types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool]),
						types.NewVar(token.NoPos, nil, "", types.Universe.Lookup("error").Type())),
					false)),
				types.NewVar(token.NoPos, pkg, "tests", anyType),
				types.NewVar(token.NoPos, pkg, "benchmarks", anyType),
				types.NewVar(token.NoPos, pkg, "examples", anyType)),
			nil, false)))

	pkg.MarkComplete()
	return pkg
}

// buildOsExecPackage creates the type-checked os/exec package stub.
func buildOsExecPackage() *types.Package {
	pkg := types.NewPackage("os/exec", "exec")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	byteSliceExec := types.NewSlice(types.Typ[types.Byte])

	// io.Writer interface
	writerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSliceExec)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	writerIface.Complete()

	// io.Reader interface
	readerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSliceExec)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	readerIface.Complete()

	// io.WriteCloser interface (for StdinPipe)
	writeCloserIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSliceExec)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, nil, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	writeCloserIface.Complete()

	// io.ReadCloser interface (for StdoutPipe, StderrPipe)
	readCloserIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSliceExec)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, nil, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	readCloserIface.Complete()

	// type Cmd struct { Path, Dir string; Args, Env []string; Stdin io.Reader; Stdout, Stderr io.Writer }
	cmdStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Path", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Dir", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Args", types.NewSlice(types.Typ[types.String]), false),
		types.NewField(token.NoPos, pkg, "Env", types.NewSlice(types.Typ[types.String]), false),
		types.NewField(token.NoPos, pkg, "Stdin", readerIface, false),
		types.NewField(token.NoPos, pkg, "Stdout", writerIface, false),
		types.NewField(token.NoPos, pkg, "Stderr", writerIface, false),
	}, nil)
	cmdType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Cmd", nil),
		cmdStruct, nil)
	scope.Insert(cmdType.Obj())
	cmdPtr := types.NewPointer(cmdType)

	// func Command(name string, arg ...string) *Cmd
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Command",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "arg", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", cmdPtr)),
			true)))

	// func LookPath(file string) (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LookPath",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "file", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func CommandContext(ctx context.Context, name string, arg ...string) *Cmd
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CommandContext",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "arg", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", cmdPtr)),
			true)))

	// Cmd methods
	cmdRecv := types.NewVar(token.NoPos, pkg, "c", cmdPtr)
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// (*Cmd).Run() error
	cmdType.AddMethod(types.NewFunc(token.NoPos, pkg, "Run",
		types.NewSignatureType(cmdRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*Cmd).Start() error
	cmdType.AddMethod(types.NewFunc(token.NoPos, pkg, "Start",
		types.NewSignatureType(cmdRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*Cmd).Wait() error
	cmdType.AddMethod(types.NewFunc(token.NoPos, pkg, "Wait",
		types.NewSignatureType(cmdRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*Cmd).Output() ([]byte, error)
	cmdType.AddMethod(types.NewFunc(token.NoPos, pkg, "Output",
		types.NewSignatureType(cmdRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", byteSlice),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*Cmd).CombinedOutput() ([]byte, error)
	cmdType.AddMethod(types.NewFunc(token.NoPos, pkg, "CombinedOutput",
		types.NewSignatureType(cmdRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", byteSlice),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*Cmd).StdinPipe() (io.WriteCloser, error)
	cmdType.AddMethod(types.NewFunc(token.NoPos, pkg, "StdinPipe",
		types.NewSignatureType(cmdRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", writeCloserIface),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*Cmd).StdoutPipe() (io.ReadCloser, error)
	cmdType.AddMethod(types.NewFunc(token.NoPos, pkg, "StdoutPipe",
		types.NewSignatureType(cmdRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", readCloserIface),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*Cmd).StderrPipe() (io.ReadCloser, error)
	cmdType.AddMethod(types.NewFunc(token.NoPos, pkg, "StderrPipe",
		types.NewSignatureType(cmdRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", readCloserIface),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// (*Cmd).String() string
	cmdType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(cmdRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// (*Cmd).Environ() []string
	cmdType.AddMethod(types.NewFunc(token.NoPos, pkg, "Environ",
		types.NewSignatureType(cmdRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// type Error struct
	errStruct := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Error", nil),
		types.NewStruct([]*types.Var{
			types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		}, nil), nil)
	scope.Insert(errStruct.Obj())
	// Error.Error() string
	errStruct.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", types.NewPointer(errStruct)), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	// Error.Unwrap() error
	errStruct.AddMethod(types.NewFunc(token.NoPos, pkg, "Unwrap",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", types.NewPointer(errStruct)), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// type ExitError struct { Stderr []byte }
	exitErrType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "ExitError", nil),
		types.NewStruct([]*types.Var{
			types.NewField(token.NoPos, pkg, "Stderr", byteSlice, false),
		}, nil), nil)
	scope.Insert(exitErrType.Obj())
	exitErrPtr := types.NewPointer(exitErrType)
	// ExitError.Error() string
	exitErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", exitErrPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	// ExitError.ExitCode() int
	exitErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "ExitCode",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", exitErrPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// var ErrNotFound error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrNotFound", errType))
	// var ErrDot error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrDot", errType))
	// var ErrWaitDelay error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrWaitDelay", errType))

	pkg.MarkComplete()
	return pkg
}

// buildOsSignalPackage creates the type-checked os/signal package stub.
func buildOsSignalPackage() *types.Package {
	pkg := types.NewPackage("os/signal", "signal")
	scope := pkg.Scope()

	// func Notify(c chan<- os.Signal, sig ...os.Signal)
	// Simplified: use interface{} for Signal type
	sigType := types.NewInterfaceType(nil, nil)
	sigChan := types.NewChan(types.SendOnly, sigType)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Notify",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "c", sigChan),
				types.NewVar(token.NoPos, pkg, "sig", types.NewSlice(sigType))),
			nil, true)))

	// func Stop(c chan<- os.Signal)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Stop",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "c", sigChan)),
			nil, false)))

	pkg.MarkComplete()
	return pkg
}

// buildIOUtilPackage creates the type-checked io/ioutil package stub (deprecated).
func buildIOUtilPackage() *types.Package {
	pkg := types.NewPackage("io/ioutil", "ioutil")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// func ReadFile(filename string) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadFile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "filename", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func WriteFile(filename string, data []byte, perm uint32) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WriteFile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "filename", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "perm", types.Typ[types.Uint32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ReadAll(r io.Reader) ([]byte, error)
	readerType := types.NewInterfaceType(nil, nil)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadAll",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", readerType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func TempDir(dir, pattern string) (string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TempDir",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dir", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// var Discard io.Writer
	scope.Insert(types.NewVar(token.NoPos, pkg, "Discard", types.NewInterfaceType(nil, nil)))

	// func NopCloser(r io.Reader) io.ReadCloser — simplified
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NopCloser",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", readerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", readerType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildIOFSPackage creates the type-checked io/fs package stub.
func buildIOFSPackage() *types.Package {
	pkg := types.NewPackage("io/fs", "fs")
	scope := pkg.Scope()

	// type FileMode uint32
	fileModeType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FileMode", nil),
		types.Typ[types.Uint32], nil)
	scope.Insert(fileModeType.Obj())

	errType := types.Universe.Lookup("error").Type()

	// type FileInfo interface { Name() string; Size() int64; Mode() FileMode; ModTime() int64; IsDir() bool; Sys() any }
	fileInfoIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Name",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
				false)),
		types.NewFunc(token.NoPos, pkg, "Size",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
				false)),
		types.NewFunc(token.NoPos, pkg, "Mode",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", fileModeType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "ModTime",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
				false)),
		types.NewFunc(token.NoPos, pkg, "IsDir",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
				false)),
		types.NewFunc(token.NoPos, pkg, "Sys",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))),
				false)),
	}, nil)
	fileInfoIface.Complete()
	fileInfoType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FileInfo", nil),
		fileInfoIface, nil)
	scope.Insert(fileInfoType.Obj())

	// type DirEntry interface { Name() string; IsDir() bool; Type() FileMode; Info() (FileInfo, error) }
	dirEntryIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Name",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
				false)),
		types.NewFunc(token.NoPos, pkg, "IsDir",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
				false)),
		types.NewFunc(token.NoPos, pkg, "Type",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", fileModeType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Info",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", fileInfoType),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	dirEntryIface.Complete()
	dirEntryType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "DirEntry", nil),
		dirEntryIface, nil)
	scope.Insert(dirEntryType.Obj())

	// FileMode constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeDir", fileModeType, constant.MakeUint64(1<<31)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeAppend", fileModeType, constant.MakeUint64(1<<30)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeExclusive", fileModeType, constant.MakeUint64(1<<29)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeTemporary", fileModeType, constant.MakeUint64(1<<28)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeSymlink", fileModeType, constant.MakeUint64(1<<27)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeDevice", fileModeType, constant.MakeUint64(1<<26)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeNamedPipe", fileModeType, constant.MakeUint64(1<<25)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeSocket", fileModeType, constant.MakeUint64(1<<24)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeSetuid", fileModeType, constant.MakeUint64(1<<23)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeSetgid", fileModeType, constant.MakeUint64(1<<22)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeCharDevice", fileModeType, constant.MakeUint64(1<<21)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeSticky", fileModeType, constant.MakeUint64(1<<20)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeIrregular", fileModeType, constant.MakeUint64(1<<19)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModeType", fileModeType, constant.MakeUint64(0xFFFF0000)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ModePerm", fileModeType, constant.MakeUint64(0777)))

	// FileMode methods
	fileModeType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsDir",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", fileModeType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	fileModeType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsRegular",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", fileModeType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	fileModeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Perm",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", fileModeType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", fileModeType)),
			false)))
	fileModeType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", fileModeType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	fileModeType.AddMethod(types.NewFunc(token.NoPos, pkg, "Type",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", fileModeType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", fileModeType)),
			false)))

	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// type File interface { Stat() (FileInfo, error); Read([]byte) (int, error); Close() error }
	fileIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Stat",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", fileInfoType),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	fileIface.Complete()
	fileType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "File", nil),
		fileIface, nil)
	scope.Insert(fileType.Obj())

	// type ReadDirFile interface { File + ReadDir(n int) ([]DirEntry, error) }
	readDirFileIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadDir",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", types.NewSlice(dirEntryIface)),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, []types.Type{fileType})
	readDirFileIface.Complete()
	readDirFileType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReadDirFile", nil),
		readDirFileIface, nil)
	scope.Insert(readDirFileType.Obj())

	// type FS interface { Open(name string) (File, error) }
	fsIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Open",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", fileType),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	fsIface.Complete()
	fsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FS", nil),
		fsIface, nil)
	scope.Insert(fsType.Obj())

	// type StatFS interface { FS + Stat(name) (FileInfo, error) }
	statFSIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Stat",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", fileInfoType),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, []types.Type{fsType})
	statFSIface.Complete()
	statFSType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "StatFS", nil),
		statFSIface, nil)
	scope.Insert(statFSType.Obj())

	// type ReadFileFS interface { FS + ReadFile(name) ([]byte, error) }
	readFileFSIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadFile",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", byteSlice),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, []types.Type{fsType})
	readFileFSIface.Complete()
	readFileFSType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReadFileFS", nil),
		readFileFSIface, nil)
	scope.Insert(readFileFSType.Obj())

	// type ReadDirFS interface { FS + ReadDir(name) ([]DirEntry, error) }
	readDirFSIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadDir",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", types.NewSlice(dirEntryIface)),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, []types.Type{fsType})
	readDirFSIface.Complete()
	readDirFSType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReadDirFS", nil),
		readDirFSIface, nil)
	scope.Insert(readDirFSType.Obj())

	// type GlobFS interface { FS + Glob(pattern) ([]string, error) }
	globFSIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Glob",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "pattern", types.Typ[types.String])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String])),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, []types.Type{fsType})
	globFSIface.Complete()
	globFSType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "GlobFS", nil),
		globFSIface, nil)
	scope.Insert(globFSType.Obj())

	// type SubFS interface { FS + Sub(dir) (FS, error) }
	subFSIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Sub",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "dir", types.Typ[types.String])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", fsIface),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, []types.Type{fsType})
	subFSIface.Complete()
	subFSType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "SubFS", nil),
		subFSIface, nil)
	scope.Insert(subFSType.Obj())

	// func ValidPath(name string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ValidPath",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func FormatFileInfo(info FileInfo) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatFileInfo",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "info", fileInfoType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func FormatDirEntry(dir DirEntry) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatDirEntry",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "dir", dirEntryType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// type WalkDirFunc
	walkDirFuncType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "WalkDirFunc", nil),
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "path", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "d", dirEntryIface),
				types.NewVar(token.NoPos, nil, "err", errType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false), nil)
	scope.Insert(walkDirFuncType.Obj())

	// type PathError struct
	pathErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Op", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Path", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Err", errType, false),
	}, nil)
	pathErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "PathError", nil),
		pathErrStruct, nil)
	pathErrPtr := types.NewPointer(pathErrType)
	pathErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", pathErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	pathErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Unwrap",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", pathErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	scope.Insert(pathErrType.Obj())

	// var ErrNotExist, ErrExist, ErrPermission, ErrInvalid, ErrClosed error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrNotExist", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrExist", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrPermission", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrInvalid", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrClosed", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "SkipDir", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "SkipAll", errType))

	// Package functions
	// func ReadFile(fsys FS, name string) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadFile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fsys", fsIface),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ReadDir(fsys FS, name string) ([]DirEntry, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadDir",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fsys", fsIface),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(dirEntryIface)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Stat(fsys FS, name string) (FileInfo, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Stat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fsys", fsIface),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", fileInfoIface),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func WalkDir(fsys FS, root string, fn WalkDirFunc) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "WalkDir",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fsys", fsIface),
				types.NewVar(token.NoPos, pkg, "root", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "fn", walkDirFuncType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Sub(fsys FS, dir string) (FS, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sub",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fsys", fsIface),
				types.NewVar(token.NoPos, pkg, "dir", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", fsIface),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Glob(fsys FS, pattern string) ([]string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Glob",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fsys", fsIface),
				types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ValidPath(name string) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ValidPath",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func FormatFileInfo(info FileInfo) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatFileInfo",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "info", fileInfoIface)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func FormatDirEntry(dir DirEntry) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatDirEntry",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "dir", dirEntryIface)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildRegexpPackage creates the type-checked regexp package stub.
func buildRegexpPackage() *types.Package {
	pkg := types.NewPackage("regexp", "regexp")
	scope := pkg.Scope()

	// type Regexp struct { ... }
	regexpStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "pattern", types.Typ[types.String], false),
	}, nil)
	regexpType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Regexp", nil),
		regexpStruct, nil)
	scope.Insert(regexpType.Obj())
	regexpPtr := types.NewPointer(regexpType)

	// func Compile(expr string) (*Regexp, error)
	errType := types.Universe.Lookup("error").Type()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Compile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "expr", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", regexpPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func MustCompile(str string) *Regexp
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MustCompile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "str", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", regexpPtr)),
			false)))

	// func MatchString(pattern string, s string) (bool, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MatchString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func QuoteMeta(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "QuoteMeta",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Match(pattern string, b []byte) (matched bool, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Match",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "b", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func CompilePOSIX(expr string) (*Regexp, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CompilePOSIX",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "expr", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", regexpPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func MustCompilePOSIX(str string) *Regexp
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MustCompilePOSIX",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "str", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", regexpPtr)),
			false)))

	// Regexp methods
	regexpRecv := types.NewVar(token.NoPos, pkg, "re", regexpPtr)
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// (*Regexp).MatchString(s string) bool
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "MatchString",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// (*Regexp).Match(b []byte) bool
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "Match",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// (*Regexp).FindString(s string) string
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindString",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// (*Regexp).FindStringIndex(s string) []int
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindStringIndex",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Int]))),
			false)))

	// (*Regexp).FindStringSubmatch(s string) []string
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindStringSubmatch",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// (*Regexp).FindAllString(s string, n int) []string
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindAllString",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// (*Regexp).FindAllStringSubmatch(s string, n int) [][]string
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindAllStringSubmatch",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.NewSlice(types.Typ[types.String])))),
			false)))

	// (*Regexp).ReplaceAllString(src, repl string) string
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReplaceAllString",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "src", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "repl", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// (*Regexp).ReplaceAllStringFunc(src string, repl func(string) string) string
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReplaceAllStringFunc",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "src", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "repl",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
						false))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// (*Regexp).Split(s string, n int) []string
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "Split",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// (*Regexp).String() string
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(regexpRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// (*Regexp).SubexpNames() []string
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "SubexpNames",
		types.NewSignatureType(regexpRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// (*Regexp).NumSubexp() int
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "NumSubexp",
		types.NewSignatureType(regexpRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// (*Regexp).Find(b []byte) []byte
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "Find",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
			false)))

	// (*Regexp).FindIndex(b []byte) []int
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindIndex",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Int]))),
			false)))

	// (*Regexp).FindSubmatch(b []byte) [][]byte
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindSubmatch",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(byteSlice))),
			false)))

	// (*Regexp).FindSubmatchIndex(b []byte) []int
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindSubmatchIndex",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Int]))),
			false)))

	// (*Regexp).FindAll(b []byte, n int) [][]byte
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindAll",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "b", byteSlice),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(byteSlice))),
			false)))

	// (*Regexp).FindAllIndex(b []byte, n int) [][]int
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindAllIndex",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "b", byteSlice),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.NewSlice(types.Typ[types.Int])))),
			false)))

	// (*Regexp).FindAllSubmatch(b []byte, n int) [][][]byte
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindAllSubmatch",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "b", byteSlice),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.NewSlice(byteSlice)))),
			false)))

	// (*Regexp).FindAllSubmatchIndex(b []byte, n int) [][]int
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindAllSubmatchIndex",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "b", byteSlice),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.NewSlice(types.Typ[types.Int])))),
			false)))

	// (*Regexp).FindStringSubmatchIndex(s string) []int
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindStringSubmatchIndex",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Int]))),
			false)))

	// (*Regexp).FindAllStringIndex(s string, n int) [][]int
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindAllStringIndex",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.NewSlice(types.Typ[types.Int])))),
			false)))

	// (*Regexp).FindAllStringSubmatchIndex(s string, n int) [][]int
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "FindAllStringSubmatchIndex",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.NewSlice(types.Typ[types.Int])))),
			false)))

	// (*Regexp).ReplaceAll(src, repl []byte) []byte
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReplaceAll",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "src", byteSlice),
				types.NewVar(token.NoPos, nil, "repl", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
			false)))

	// (*Regexp).ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReplaceAllFunc",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "src", byteSlice),
				types.NewVar(token.NoPos, nil, "repl",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
						false))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
			false)))

	// (*Regexp).ReplaceAllLiteral(src, repl []byte) []byte
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReplaceAllLiteral",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "src", byteSlice),
				types.NewVar(token.NoPos, nil, "repl", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
			false)))

	// (*Regexp).ReplaceAllLiteralString(src, repl string) string
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReplaceAllLiteralString",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "src", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "repl", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// (*Regexp).Expand(dst []byte, template []byte, src []byte, match []int) []byte
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "Expand",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "dst", byteSlice),
				types.NewVar(token.NoPos, nil, "template", byteSlice),
				types.NewVar(token.NoPos, nil, "src", byteSlice),
				types.NewVar(token.NoPos, nil, "match", types.NewSlice(types.Typ[types.Int]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
			false)))

	// (*Regexp).ExpandString(dst []byte, template string, src string, match []int) []byte
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "ExpandString",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "dst", byteSlice),
				types.NewVar(token.NoPos, nil, "template", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "src", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "match", types.NewSlice(types.Typ[types.Int]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
			false)))

	// (*Regexp).Longest()
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "Longest",
		types.NewSignatureType(regexpRecv, nil, nil, nil, nil, false)))

	// (*Regexp).SubexpIndex(name string) int
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "SubexpIndex",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// (*Regexp).Copy() *Regexp (deprecated but still used)
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "Copy",
		types.NewSignatureType(regexpRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", regexpPtr)),
			false)))

	// (*Regexp).LiteralPrefix() (prefix string, complete bool)
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "LiteralPrefix",
		types.NewSignatureType(regexpRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "prefix", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "complete", types.Typ[types.Bool])),
			false)))

	// (*Regexp).MatchReader(r io.RuneReader) bool — simplified to any
	regexpType.AddMethod(types.NewFunc(token.NoPos, pkg, "MatchReader",
		types.NewSignatureType(regexpRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "r", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildNetHTTPPackage creates a minimal type-checked net/http package stub.
func buildNetHTTPPackage() *types.Package {
	pkg := types.NewPackage("net/http", "http")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// type Header map[string][]string
	headerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Header", nil),
		types.NewMap(types.Typ[types.String], types.NewSlice(types.Typ[types.String])), nil)
	scope.Insert(headerType.Obj())

	// *url.URL stand-in struct
	urlStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, nil, "Scheme", types.Typ[types.String], false),
		types.NewField(token.NoPos, nil, "Opaque", types.Typ[types.String], false),
		types.NewField(token.NoPos, nil, "Host", types.Typ[types.String], false),
		types.NewField(token.NoPos, nil, "Path", types.Typ[types.String], false),
		types.NewField(token.NoPos, nil, "RawPath", types.Typ[types.String], false),
		types.NewField(token.NoPos, nil, "RawQuery", types.Typ[types.String], false),
		types.NewField(token.NoPos, nil, "Fragment", types.Typ[types.String], false),
	}, nil)
	urlType := types.NewNamed(types.NewTypeName(token.NoPos, nil, "URL", nil), urlStruct, nil)
	urlPtr := types.NewPointer(urlType)

	// io.ReadCloser stand-in
	ioReadCloser := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", types.NewSlice(types.Typ[types.Byte]))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, nil, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	ioReadCloser.Complete()

	// *tls.Config stand-in
	tlsConfigStruct := types.NewStruct(nil, nil)
	tlsConfigType := types.NewNamed(types.NewTypeName(token.NoPos, nil, "Config", nil), tlsConfigStruct, nil)
	tlsConfigPtr := types.NewPointer(tlsConfigType)

	// type Request struct { Method string; URL *url.URL; Proto string; Header Header; Body io.ReadCloser; ... }
	reqStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Method", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "URL", urlPtr, false),
		types.NewField(token.NoPos, pkg, "Proto", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "ProtoMajor", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "ProtoMinor", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Header", headerType, false),
		types.NewField(token.NoPos, pkg, "Body", ioReadCloser, false),
		types.NewField(token.NoPos, pkg, "ContentLength", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "Host", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Form", types.NewMap(types.Typ[types.String], types.NewSlice(types.Typ[types.String])), false),
		types.NewField(token.NoPos, pkg, "PostForm", types.NewMap(types.Typ[types.String], types.NewSlice(types.Typ[types.String])), false),
		types.NewField(token.NoPos, pkg, "RemoteAddr", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "RequestURI", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Pattern", types.Typ[types.String], false),
	}, nil)
	reqType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Request", nil),
		reqStruct, nil)
	scope.Insert(reqType.Obj())

	// type Response struct { Status string; StatusCode int; Proto string; Header Header; Body io.ReadCloser; ContentLength int64; ... }
	respStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Status", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "StatusCode", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Proto", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "ProtoMajor", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "ProtoMinor", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Header", headerType, false),
		types.NewField(token.NoPos, pkg, "Body", ioReadCloser, false),
		types.NewField(token.NoPos, pkg, "ContentLength", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "Uncompressed", types.Typ[types.Bool], false),
		types.NewField(token.NoPos, pkg, "Request", types.NewPointer(reqType), false),
		types.NewField(token.NoPos, pkg, "TLS", tlsConfigPtr, false),
	}, nil)
	respType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Response", nil),
		respStruct, nil)
	scope.Insert(respType.Obj())
	respPtr := types.NewPointer(respType)

	// func Get(url string) (*Response, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Get",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "url", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", respPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Post(url, contentType string, body io.Reader) (*Response, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Post",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "url", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "contentType", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "body", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", respPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Status codes
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusOK", types.Typ[types.Int],
		constant.MakeInt64(200)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusNotFound", types.Typ[types.Int],
		constant.MakeInt64(404)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusInternalServerError", types.Typ[types.Int],
		constant.MakeInt64(500)))

	// type ResponseWriter interface
	rwIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", types.NewSlice(types.Typ[types.Byte]))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "WriteHeader",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "statusCode", types.Typ[types.Int])),
				nil, false)),
		types.NewFunc(token.NoPos, pkg, "Header",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", headerType)),
				false)),
	}, nil)
	rwIface.Complete()
	responseWriterType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ResponseWriter", nil),
		rwIface, nil)
	scope.Insert(responseWriterType.Obj())

	// type HandlerFunc func(ResponseWriter, *Request)
	handlerFuncSig := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(
			types.NewVar(token.NoPos, nil, "w", responseWriterType),
			types.NewVar(token.NoPos, nil, "r", types.NewPointer(reqType))),
		nil, false)
	handlerFuncType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "HandlerFunc", nil),
		handlerFuncSig, nil)
	scope.Insert(handlerFuncType.Obj())

	// type Handler interface
	handlerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ServeHTTP",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "w", responseWriterType),
					types.NewVar(token.NoPos, nil, "r", types.NewPointer(reqType))),
				nil, false)),
	}, nil)
	handlerIface.Complete()
	handlerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Handler", nil),
		handlerIface, nil)
	scope.Insert(handlerType.Obj())

	// type ServeMux struct
	muxType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "ServeMux", nil), types.NewStruct(nil, nil), nil)
	muxPtr := types.NewPointer(muxType)
	scope.Insert(muxType.Obj())

	// func NewServeMux() *ServeMux
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewServeMux",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", muxPtr)),
			false)))

	// func Handle(pattern string, handler Handler)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Handle",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "handler", handlerType)),
			nil, false)))

	// func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "HandleFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "handler", handlerFuncSig)),
			nil, false)))

	// func ListenAndServe(addr string, handler Handler) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ListenAndServe",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "handler", handlerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ListenAndServeTLS",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "addr", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "certFile", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "keyFile", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "handler", handlerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func NewRequest(method, url string, body io.Reader) (*Request, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewRequest",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "method", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "url", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "body", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewPointer(reqType)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Error(w ResponseWriter, error string, code int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", responseWriterType),
				types.NewVar(token.NoPos, pkg, "error", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "code", types.Typ[types.Int])),
			nil, false)))

	// func NotFound(w ResponseWriter, r *Request)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NotFound",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", responseWriterType),
				types.NewVar(token.NoPos, pkg, "r", types.NewPointer(reqType))),
			nil, false)))

	// func Redirect(w ResponseWriter, r *Request, url string, code int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Redirect",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", responseWriterType),
				types.NewVar(token.NoPos, pkg, "r", types.NewPointer(reqType)),
				types.NewVar(token.NoPos, pkg, "url", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "code", types.Typ[types.Int])),
			nil, false)))

	// func StatusText(code int) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "StatusText",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "code", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// type Server struct
	serverType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Server", nil),
		types.NewStruct([]*types.Var{
			types.NewField(token.NoPos, pkg, "Addr", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "Handler", handlerType, false),
			types.NewField(token.NoPos, pkg, "TLSConfig", tlsConfigPtr, false),
			types.NewField(token.NoPos, pkg, "ReadTimeout", types.Typ[types.Int64], false),
			types.NewField(token.NoPos, pkg, "ReadHeaderTimeout", types.Typ[types.Int64], false),
			types.NewField(token.NoPos, pkg, "WriteTimeout", types.Typ[types.Int64], false),
			types.NewField(token.NoPos, pkg, "IdleTimeout", types.Typ[types.Int64], false),
			types.NewField(token.NoPos, pkg, "MaxHeaderBytes", types.Typ[types.Int], false),
		}, nil), nil)
	scope.Insert(serverType.Obj())

	// type RoundTripper interface
	roundTripperIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "RoundTrip",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "req", types.NewPointer(reqType))),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", respPtr),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	roundTripperIface.Complete()
	roundTripperType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "RoundTripper", nil),
		roundTripperIface, nil)
	scope.Insert(roundTripperType.Obj())

	// CookieJar interface (stand-in)
	cookieJarIface := types.NewInterfaceType(nil, nil)
	cookieJarIface.Complete()
	cookieJarType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CookieJar", nil),
		cookieJarIface, nil)
	scope.Insert(cookieJarType.Obj())

	// type Client struct
	clientType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Client", nil),
		types.NewStruct([]*types.Var{
			types.NewField(token.NoPos, pkg, "Transport", roundTripperType, false),
			types.NewField(token.NoPos, pkg, "CheckRedirect", types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "req", types.NewPointer(reqType)),
					types.NewVar(token.NoPos, nil, "via", types.NewSlice(types.NewPointer(reqType)))),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false), false),
			types.NewField(token.NoPos, pkg, "Jar", cookieJarType, false),
			types.NewField(token.NoPos, pkg, "Timeout", types.Typ[types.Int64], false),
		}, nil), nil)
	scope.Insert(clientType.Obj())

	// Proxy func(*Request) (*url.URL, error)
	proxyFuncType := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, nil, "req", types.NewPointer(reqType))),
		types.NewTuple(
			types.NewVar(token.NoPos, nil, "", urlPtr),
			types.NewVar(token.NoPos, nil, "", errType)),
		false)

	// type Transport struct
	transportType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Transport", nil),
		types.NewStruct([]*types.Var{
			types.NewField(token.NoPos, pkg, "TLSClientConfig", tlsConfigPtr, false),
			types.NewField(token.NoPos, pkg, "DisableKeepAlives", types.Typ[types.Bool], false),
			types.NewField(token.NoPos, pkg, "DisableCompression", types.Typ[types.Bool], false),
			types.NewField(token.NoPos, pkg, "MaxIdleConns", types.Typ[types.Int], false),
			types.NewField(token.NoPos, pkg, "MaxIdleConnsPerHost", types.Typ[types.Int], false),
			types.NewField(token.NoPos, pkg, "IdleConnTimeout", types.Typ[types.Int64], false),
			types.NewField(token.NoPos, pkg, "Proxy", proxyFuncType, false),
			types.NewField(token.NoPos, pkg, "TLSHandshakeTimeout", types.Typ[types.Int64], false),
			types.NewField(token.NoPos, pkg, "ResponseHeaderTimeout", types.Typ[types.Int64], false),
			types.NewField(token.NoPos, pkg, "ExpectContinueTimeout", types.Typ[types.Int64], false),
			types.NewField(token.NoPos, pkg, "ForceAttemptHTTP2", types.Typ[types.Bool], false),
		}, nil), nil)
	scope.Insert(transportType.Obj())

	// type Cookie struct
	cookieType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Cookie", nil),
		types.NewStruct([]*types.Var{
			types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "Value", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "Path", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "Domain", types.Typ[types.String], false),
			types.NewField(token.NoPos, pkg, "MaxAge", types.Typ[types.Int], false),
			types.NewField(token.NoPos, pkg, "Secure", types.Typ[types.Bool], false),
			types.NewField(token.NoPos, pkg, "HttpOnly", types.Typ[types.Bool], false),
			types.NewField(token.NoPos, pkg, "SameSite", types.Typ[types.Int], false),
			types.NewField(token.NoPos, pkg, "Raw", types.Typ[types.String], false),
		}, nil), nil)
	scope.Insert(cookieType.Obj())

	// HTTP method constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "MethodGet", types.Typ[types.String], constant.MakeString("GET")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MethodPost", types.Typ[types.String], constant.MakeString("POST")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MethodPut", types.Typ[types.String], constant.MakeString("PUT")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MethodDelete", types.Typ[types.String], constant.MakeString("DELETE")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MethodHead", types.Typ[types.String], constant.MakeString("HEAD")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MethodPatch", types.Typ[types.String], constant.MakeString("PATCH")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MethodOptions", types.Typ[types.String], constant.MakeString("OPTIONS")))

	// More status codes
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusContinue", types.Typ[types.Int], constant.MakeInt64(100)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusMovedPermanently", types.Typ[types.Int], constant.MakeInt64(301)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusFound", types.Typ[types.Int], constant.MakeInt64(302)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusBadRequest", types.Typ[types.Int], constant.MakeInt64(400)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusUnauthorized", types.Typ[types.Int], constant.MakeInt64(401)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusForbidden", types.Typ[types.Int], constant.MakeInt64(403)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusMethodNotAllowed", types.Typ[types.Int], constant.MakeInt64(405)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusConflict", types.Typ[types.Int], constant.MakeInt64(409)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusGone", types.Typ[types.Int], constant.MakeInt64(410)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusTeapot", types.Typ[types.Int], constant.MakeInt64(418)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusTooManyRequests", types.Typ[types.Int], constant.MakeInt64(429)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusServiceUnavailable", types.Typ[types.Int], constant.MakeInt64(503)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusGatewayTimeout", types.Typ[types.Int], constant.MakeInt64(504)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusCreated", types.Typ[types.Int], constant.MakeInt64(201)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusAccepted", types.Typ[types.Int], constant.MakeInt64(202)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusNoContent", types.Typ[types.Int], constant.MakeInt64(204)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusNotModified", types.Typ[types.Int], constant.MakeInt64(304)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusUnprocessableEntity", types.Typ[types.Int], constant.MakeInt64(422)))

	// Default HTTP client/transport
	scope.Insert(types.NewVar(token.NoPos, pkg, "DefaultClient", types.NewPointer(clientType)))
	scope.Insert(types.NewVar(token.NoPos, pkg, "DefaultTransport", types.NewPointer(transportType)))
	scope.Insert(types.NewVar(token.NoPos, pkg, "DefaultServeMux", muxPtr))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrBodyNotAllowed", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrContentLength", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrMissingFile", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrNotSupported", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrServerClosed", errType))

	// func Head(url string) (resp *Response, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Head",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "url", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", respPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func PostForm(url string, data url.Values) (resp *Response, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "PostForm",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "url", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "data", types.NewMap(types.Typ[types.String], types.NewSlice(types.Typ[types.String])))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", respPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func NotFoundHandler() Handler
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NotFoundHandler",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", handlerType)),
			false)))

	// func StripPrefix(prefix string, h Handler) Handler
	scope.Insert(types.NewFunc(token.NoPos, pkg, "StripPrefix",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "prefix", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "h", handlerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", handlerType)),
			false)))

	// type File interface (http.File - simplified)
	httpFileIface := types.NewInterfaceType(nil, nil)
	httpFileIface.Complete()
	httpFileType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "File", nil),
		httpFileIface, nil)
	scope.Insert(httpFileType.Obj())

	// type FileSystem interface { Open(name string) (File, error) }
	fileSystemIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Open",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", httpFileType),
					types.NewVar(token.NoPos, nil, "", errType)), false)),
	}, nil)
	fileSystemIface.Complete()
	fileSystemType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FileSystem", nil),
		fileSystemIface, nil)
	scope.Insert(fileSystemType.Obj())

	// type Dir string
	dirType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Dir", nil),
		types.Typ[types.String], nil)
	scope.Insert(dirType.Obj())

	scope.Insert(types.NewFunc(token.NoPos, pkg, "FileServer",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "root", fileSystemType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", handlerType)),
			false)))

	// func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MaxBytesReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", responseWriterType),
				types.NewVar(token.NoPos, pkg, "r", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewInterfaceType(nil, nil))),
			false)))

	reqPtr := types.NewPointer(reqType)
	serverPtr := types.NewPointer(serverType)
	clientPtr := types.NewPointer(clientType)
	cookiePtr := types.NewPointer(cookieType)
	byteSlice := types.NewSlice(types.Typ[types.Byte])
	ioReader := types.NewInterfaceType(nil, nil)

	// ---- Header methods ----
	headerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Set",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "h", headerType), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String])),
			nil, false)))
	headerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Get",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "h", headerType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	headerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Add",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "h", headerType), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String])),
			nil, false)))
	headerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Del",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "h", headerType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			nil, false)))
	headerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Values",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "h", headerType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String]))),
			false)))
	headerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Clone",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "h", headerType), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", headerType)),
			false)))
	headerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "h", headerType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "w", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// ---- Request methods ----
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "FormValue",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "PostFormValue",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "UserAgent",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "Referer",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "Context",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "Clone",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "ctx", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", reqPtr)),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cookie",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", cookiePtr),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cookies",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(cookiePtr))),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "AddCookie",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "c", cookiePtr)),
			nil, false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "BasicAuth",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "username", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "password", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "ok", types.Typ[types.Bool])),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetBasicAuth",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "username", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "password", types.Typ[types.String])),
			nil, false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "ParseForm",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "ParseMultipartForm",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "maxMemory", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "ProtoAtLeast",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "major", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "minor", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "w", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "WithContext",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "ctx", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", reqPtr)),
			false)))
	reqType.AddMethod(types.NewFunc(token.NoPos, pkg, "MultipartReader",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", reqPtr), nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// ---- Response methods ----
	respType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cookies",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", respPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(cookiePtr))),
			false)))
	respType.AddMethod(types.NewFunc(token.NoPos, pkg, "Location",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", respPtr), nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", urlPtr),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	respType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", respPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "w", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	respType.AddMethod(types.NewFunc(token.NoPos, pkg, "ProtoAtLeast",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", respPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "major", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "minor", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// ---- Client methods ----
	clientType.AddMethod(types.NewFunc(token.NoPos, pkg, "Do",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", clientPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "req", reqPtr)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", respPtr),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	clientType.AddMethod(types.NewFunc(token.NoPos, pkg, "Get",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", clientPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "url", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", respPtr),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	clientType.AddMethod(types.NewFunc(token.NoPos, pkg, "Post",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", clientPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "url", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "contentType", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "body", ioReader)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", respPtr),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	clientType.AddMethod(types.NewFunc(token.NoPos, pkg, "Head",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", clientPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "url", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", respPtr),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	clientType.AddMethod(types.NewFunc(token.NoPos, nil, "PostForm",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", clientPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "url", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "data", types.NewMap(types.Typ[types.String], types.NewSlice(types.Typ[types.String])))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", respPtr),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	clientType.AddMethod(types.NewFunc(token.NoPos, pkg, "CloseIdleConnections",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", clientPtr), nil, nil, nil, nil, false)))

	// ---- Server methods ----
	serverType.AddMethod(types.NewFunc(token.NoPos, pkg, "ListenAndServe",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "srv", serverPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	serverType.AddMethod(types.NewFunc(token.NoPos, pkg, "ListenAndServeTLS",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "srv", serverPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "certFile", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "keyFile", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	serverType.AddMethod(types.NewFunc(token.NoPos, pkg, "Shutdown",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "srv", serverPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "ctx", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	serverType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "srv", serverPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// ---- ServeMux methods ----
	muxType.AddMethod(types.NewFunc(token.NoPos, pkg, "Handle",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "mux", muxPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "pattern", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "handler", handlerType)),
			nil, false)))
	muxType.AddMethod(types.NewFunc(token.NoPos, pkg, "HandleFunc",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "mux", muxPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "pattern", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "handler", handlerFuncSig)),
			nil, false)))
	muxType.AddMethod(types.NewFunc(token.NoPos, pkg, "ServeHTTP",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "mux", muxPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "w", responseWriterType),
				types.NewVar(token.NoPos, nil, "r", reqPtr)),
			nil, false)))

	// ---- Cookie methods ----
	cookieType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", cookiePtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	cookieType.AddMethod(types.NewFunc(token.NoPos, pkg, "Valid",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", cookiePtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// ---- Additional package functions ----
	// func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewRequestWithContext",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "method", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "url", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "body", ioReader)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", reqPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func SetCookie(w ResponseWriter, cookie *Cookie)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SetCookie",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", responseWriterType),
				types.NewVar(token.NoPos, pkg, "cookie", cookiePtr)),
			nil, false)))

	// func CanonicalHeaderKey(s string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CanonicalHeaderKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func DetectContentType(data []byte) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DetectContentType",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "data", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func ProxyFromEnvironment(req *Request) (*url.URL, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ProxyFromEnvironment",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "req", reqPtr)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", urlPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ProxyURL",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "fixedURL", urlPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", proxyFuncType)),
			false)))

	// func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TimeoutHandler",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "h", handlerType),
				types.NewVar(token.NoPos, pkg, "dt", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "msg", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", handlerType)),
			false)))

	// func AllowQuerySemicolons(h Handler) Handler
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AllowQuerySemicolons",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "h", handlerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", handlerType)),
			false)))

	// type Flusher interface { Flush() }
	flusherIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Flush",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
	}, nil)
	flusherIface.Complete()
	scope.Insert(types.NewTypeName(token.NoPos, pkg, "Flusher",
		types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Flusher", nil), flusherIface, nil)))

	// type SameSite int
	sameSiteType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "SameSite", nil), types.Typ[types.Int], nil)
	scope.Insert(sameSiteType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "SameSiteDefaultMode", sameSiteType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SameSiteLaxMode", sameSiteType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SameSiteStrictMode", sameSiteType, constant.MakeInt64(3)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SameSiteNoneMode", sameSiteType, constant.MakeInt64(4)))

	// More status codes
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusSwitchingProtocols", types.Typ[types.Int], constant.MakeInt64(101)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusResetContent", types.Typ[types.Int], constant.MakeInt64(205)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusPartialContent", types.Typ[types.Int], constant.MakeInt64(206)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusTemporaryRedirect", types.Typ[types.Int], constant.MakeInt64(307)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusPermanentRedirect", types.Typ[types.Int], constant.MakeInt64(308)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusRequestEntityTooLarge", types.Typ[types.Int], constant.MakeInt64(413)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusRequestURITooLong", types.Typ[types.Int], constant.MakeInt64(414)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusUnsupportedMediaType", types.Typ[types.Int], constant.MakeInt64(415)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusNotImplemented", types.Typ[types.Int], constant.MakeInt64(501)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "StatusBadGateway", types.Typ[types.Int], constant.MakeInt64(502)))

	// MethodConnect, MethodTrace
	scope.Insert(types.NewConst(token.NoPos, pkg, "MethodConnect", types.Typ[types.String], constant.MakeString("CONNECT")))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MethodTrace", types.Typ[types.String], constant.MakeString("TRACE")))

	// var ErrAbortHandler, ErrHandlerTimeout, ErrLineTooLong, ErrNoCookie, ErrNoLocation
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrAbortHandler", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrHandlerTimeout", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrLineTooLong", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrNoCookie", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrNoLocation", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrUseLastResponse", errType))

	// ---- Transport methods ----
	transportPtr := types.NewPointer(transportType)
	transportType.AddMethod(types.NewFunc(token.NoPos, pkg, "RoundTrip",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "t", transportPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "req", reqPtr)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", respPtr),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	transportType.AddMethod(types.NewFunc(token.NoPos, pkg, "CloseIdleConnections",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "t", transportPtr), nil, nil, nil, nil, false)))
	transportType.AddMethod(types.NewFunc(token.NoPos, pkg, "Clone",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "t", transportPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", transportPtr)),
			false)))

	// ---- Additional package-level functions ----
	// func ServeFile(w ResponseWriter, r *Request, name string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ServeFile",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", responseWriterType),
				types.NewVar(token.NoPos, pkg, "r", reqPtr),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			nil, false)))

	// func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)
	// Simplified: modtime as interface{}, content as interface{}
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ServeContent",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", responseWriterType),
				types.NewVar(token.NoPos, pkg, "req", reqPtr),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "modtime", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "content", types.NewInterfaceType(nil, nil))),
			nil, false)))

	// func Serve(l net.Listener, handler Handler) error — simplified
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Serve",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "l", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "handler", handlerType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ServeTLS",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "l", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "handler", handlerType),
				types.NewVar(token.NoPos, pkg, "certFile", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "keyFile", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ReadRequest(b *bufio.Reader) (*Request, error) — simplified
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadRequest",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "b", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", reqPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ReadResponse(r *bufio.Reader, req *Request) (*Response, error) — simplified
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadResponse",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "req", reqPtr)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", respPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// type RoundTripper interface { RoundTrip(*Request) (*Response, error) }
	rtIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "RoundTrip",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "req", reqPtr)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", respPtr),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	rtIface.Complete()
	rtType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "RoundTripper", nil),
		rtIface, nil)
	scope.Insert(rtType.Obj())

	// type CookieJar interface { SetCookies, Cookies }
	cookieSlice := types.NewSlice(types.NewPointer(cookieType))
	urlIface := types.NewInterfaceType(nil, nil)
	urlIface.Complete()
	cjIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "SetCookies",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "u", urlIface),
					types.NewVar(token.NoPos, nil, "cookies", cookieSlice)),
				nil, false)),
		types.NewFunc(token.NoPos, pkg, "Cookies",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "u", urlIface)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", cookieSlice)), false)),
	}, nil)
	cjIface.Complete()
	cjType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CookieJar", nil),
		cjIface, nil)
	scope.Insert(cjType.Obj())

	// type Flusher interface { Flush() } - already defined above
	// type Hijacker interface { Hijack() (net.Conn, *bufio.ReadWriter, error) }
	hijackerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Hijack",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil)),
					types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil)),
					types.NewVar(token.NoPos, nil, "", errType)), false)),
	}, nil)
	hijackerIface.Complete()
	hijackerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Hijacker", nil),
		hijackerIface, nil)
	scope.Insert(hijackerType.Obj())

	// type CloseNotifier interface { CloseNotify() <-chan bool } (deprecated but still used)
	closeNotifierIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "CloseNotify",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "",
					types.NewChan(types.RecvOnly, types.Typ[types.Bool]))), false)),
	}, nil)
	closeNotifierIface.Complete()
	closeNotifierType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CloseNotifier", nil),
		closeNotifierIface, nil)
	scope.Insert(closeNotifierType.Obj())

	_ = byteSlice

	pkg.MarkComplete()
	return pkg
}

// buildLogSlogPackage creates the type-checked log/slog package stub.
func buildLogSlogPackage() *types.Package {
	pkg := types.NewPackage("log/slog", "slog")
	scope := pkg.Scope()

	anySlice := types.NewSlice(types.NewInterfaceType(nil, nil))

	// func Info(msg string, args ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Info",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "msg", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", anySlice)),
			nil, true)))

	// func Warn(msg string, args ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Warn",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "msg", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", anySlice)),
			nil, true)))

	// func Error(msg string, args ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "msg", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", anySlice)),
			nil, true)))

	// func Debug(msg string, args ...any)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Debug",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "msg", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", anySlice)),
			nil, true)))

	// type Level int
	levelType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Level", nil),
		types.Typ[types.Int], nil)
	scope.Insert(levelType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelDebug", levelType, constant.MakeInt64(-4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelInfo", levelType, constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelWarn", levelType, constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelError", levelType, constant.MakeInt64(8)))

	// Level methods
	levelType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "l", levelType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))

	// type Attr struct { Key string; Value Value }
	attrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Key", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Value", types.NewInterfaceType(nil, nil), false),
	}, nil)
	attrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Attr", nil),
		attrStruct, nil)
	scope.Insert(attrType.Obj())
	attrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "a", attrType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", attrType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// type Value (opaque interface)
	valueType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Value", nil),
		types.NewInterfaceType(nil, nil), nil)
	scope.Insert(valueType.Obj())

	// type Record struct (simplified)
	errTypeSlog := types.Universe.Lookup("error").Type()
	recordStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Message", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Level", levelType, false),
	}, nil)
	recordType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Record", nil),
		recordStruct, nil)
	scope.Insert(recordType.Obj())

	// type Handler interface { Enabled, Handle, WithAttrs, WithGroup }
	ctxForHandler := types.NewInterfaceType(nil, nil)
	ctxForHandler.Complete()
	handlerIface := types.NewInterfaceType(nil, nil) // forward decl
	handlerIface.Complete()
	handlerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Handler", nil),
		handlerIface, nil)

	// Now create the real interface with methods that reference handlerType
	attrSlice := types.NewSlice(attrType)
	handlerIfaceReal := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Enabled",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "ctx", ctxForHandler),
					types.NewVar(token.NoPos, nil, "level", levelType)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
		types.NewFunc(token.NoPos, pkg, "Handle",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "ctx", ctxForHandler),
					types.NewVar(token.NoPos, nil, "r", recordType)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errTypeSlog)), false)),
		types.NewFunc(token.NoPos, pkg, "WithAttrs",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "attrs", attrSlice)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", handlerType)), false)),
		types.NewFunc(token.NoPos, pkg, "WithGroup",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", handlerType)), false)),
	}, nil)
	handlerIfaceReal.Complete()
	handlerType.SetUnderlying(handlerIfaceReal)
	scope.Insert(handlerType.Obj())

	// type Logger struct
	loggerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "handler", handlerIfaceReal, false),
	}, nil)
	loggerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Logger", nil),
		loggerStruct, nil)
	scope.Insert(loggerType.Obj())
	loggerPtr := types.NewPointer(loggerType)

	// Logger methods
	logRecv := types.NewVar(token.NoPos, nil, "l", loggerPtr)
	for _, mname := range []string{"Info", "Warn", "Error", "Debug"} {
		loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, mname,
			types.NewSignatureType(logRecv, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, pkg, "msg", types.Typ[types.String]),
					types.NewVar(token.NoPos, pkg, "args", anySlice)),
				nil, true)))
	}
	for _, mname := range []string{"InfoContext", "WarnContext", "ErrorContext", "DebugContext"} {
		loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, mname,
			types.NewSignatureType(logRecv, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, pkg, "ctx", types.NewInterfaceType(nil, nil)),
					types.NewVar(token.NoPos, pkg, "msg", types.Typ[types.String]),
					types.NewVar(token.NoPos, pkg, "args", anySlice)),
				nil, true)))
	}
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "With",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "args", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", loggerPtr)),
			true)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "WithGroup",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", loggerPtr)),
			false)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Enabled",
		types.NewSignatureType(logRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "level", levelType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))
	loggerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Handler",
		types.NewSignatureType(logRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", handlerType)),
			false)))

	// Package-level functions
	scope.Insert(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "h", handlerIface)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", loggerPtr)),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Default",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", loggerPtr)),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SetDefault",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "l", loggerPtr)),
			nil, false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "With",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "args", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", loggerPtr)),
			true)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Group",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", anySlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", attrType)),
			true)))

	// Attr constructors
	scope.Insert(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", attrType)),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Int",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", attrType)),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Int64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", attrType)),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Float64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", attrType)),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Bool",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Bool])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", attrType)),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Any",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", attrType)),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Duration",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", attrType)),
			false)))

	// type HandlerOptions struct
	handlerOptsStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "AddSource", types.Typ[types.Bool], false),
		types.NewField(token.NoPos, pkg, "Level", levelType, false),
		types.NewField(token.NoPos, pkg, "ReplaceAttr", types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "groups", types.NewSlice(types.Typ[types.String])),
				types.NewVar(token.NoPos, nil, "a", attrType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", attrType)),
			false), false),
	}, nil)
	handlerOptsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "HandlerOptions", nil),
		handlerOptsStruct, nil)
	scope.Insert(handlerOptsType.Obj())
	handlerOptsPtr := types.NewPointer(handlerOptsType)

	ioWriter := types.NewInterfaceType(nil, nil)
	ioWriter.Complete()

	// Handler implementations
	// type TextHandler struct
	textHandlerStruct := types.NewStruct(nil, nil)
	textHandlerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "TextHandler", nil),
		textHandlerStruct, nil)
	scope.Insert(textHandlerType.Obj())
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewTextHandler",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", ioWriter),
				types.NewVar(token.NoPos, pkg, "opts", handlerOptsPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewPointer(textHandlerType))),
			false)))

	// type JSONHandler struct
	jsonHandlerStruct := types.NewStruct(nil, nil)
	jsonHandlerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "JSONHandler", nil),
		jsonHandlerStruct, nil)
	scope.Insert(jsonHandlerType.Obj())
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewJSONHandler",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", ioWriter),
				types.NewVar(token.NoPos, pkg, "opts", handlerOptsPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewPointer(jsonHandlerType))),
			false)))

	// type LevelVar struct
	levelVarStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "val", types.Typ[types.Int64], false),
	}, nil)
	levelVarType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "LevelVar", nil),
		levelVarStruct, nil)
	scope.Insert(levelVarType.Obj())
	lvRecv := types.NewVar(token.NoPos, nil, "v", types.NewPointer(levelVarType))
	levelVarType.AddMethod(types.NewFunc(token.NoPos, pkg, "Level",
		types.NewSignatureType(lvRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", levelType)),
			false)))
	levelVarType.AddMethod(types.NewFunc(token.NoPos, pkg, "Set",
		types.NewSignatureType(lvRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "l", levelType)),
			nil, false)))

	pkg.MarkComplete()
	return pkg
}

// buildFlagPackage creates the type-checked flag package stub.
func buildFlagPackage() *types.Package {
	pkg := types.NewPackage("flag", "flag")
	scope := pkg.Scope()

	// func Parse()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Parse",
		types.NewSignatureType(nil, nil, nil, nil, nil, false)))

	// func String(name string, value string, usage string) *string
	strPtr := types.NewPointer(types.Typ[types.String])
	scope.Insert(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", strPtr)),
			false)))

	// func Int(name string, value int, usage string) *int
	intPtr := types.NewPointer(types.Typ[types.Int])
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Int",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func Bool(name string, value bool, usage string) *bool
	boolPtr := types.NewPointer(types.Typ[types.Bool])
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Bool",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", boolPtr)),
			false)))

	// func Arg(i int) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Arg",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "i", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func Args() []string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Args",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// func NArg() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NArg",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func NFlag() int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NFlag",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Float64(name string, value float64, usage string) *float64
	float64Ptr := types.NewPointer(types.Typ[types.Float64])
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Float64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", float64Ptr)),
			false)))

	// func Int64(name string, value int64, usage string) *int64
	int64Ptr := types.NewPointer(types.Typ[types.Int64])
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Int64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", int64Ptr)),
			false)))

	// func Uint(name string, value uint, usage string) *uint
	uintPtr := types.NewPointer(types.Typ[types.Uint])
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Uint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Uint]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", uintPtr)),
			false)))

	// func Uint64(name string, value uint64, usage string) *uint64
	uint64Ptr := types.NewPointer(types.Typ[types.Uint64])
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Uint64",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Uint64]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", uint64Ptr)),
			false)))

	// func Duration(name string, value time.Duration, usage string) *time.Duration
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Duration",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", int64Ptr)),
			false)))

	// Var functions (set variable directly)
	// func StringVar(p *string, name string, value string, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "StringVar",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", strPtr),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			nil, false)))

	// func IntVar(p *int, name string, value int, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IntVar",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", intPtr),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			nil, false)))

	// func BoolVar(p *bool, name string, value bool, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "BoolVar",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", boolPtr),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			nil, false)))

	// func Parsed() bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Parsed",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func Set(name, value string) error
	errType := types.Universe.Lookup("error").Type()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Set",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Lookup(name string) *Flag
	// type Flag struct { Name, Usage string; DefValue string }
	flagStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Usage", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "DefValue", types.Typ[types.String], false),
	}, nil)
	flagType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Flag", nil),
		flagStruct, nil)
	scope.Insert(flagType.Obj())
	flagTypePtr := types.NewPointer(flagType)

	scope.Insert(types.NewFunc(token.NoPos, pkg, "Lookup",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", flagTypePtr)),
			false)))

	// type FlagSet struct {}
	flagSetStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Usage", types.NewSignatureType(nil, nil, nil, nil, nil, false), false),
	}, nil)
	flagSetType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FlagSet", nil),
		flagSetStruct, nil)
	scope.Insert(flagSetType.Obj())
	flagSetPtr := types.NewPointer(flagSetType)

	// func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet
	errorHandlingType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ErrorHandling", nil),
		types.Typ[types.Int], nil)
	scope.Insert(errorHandlingType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "ContinueOnError", errorHandlingType, constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ExitOnError", errorHandlingType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "PanicOnError", errorHandlingType, constant.MakeInt64(2)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewFlagSet",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "errorHandling", errorHandlingType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", flagSetPtr)),
			false)))

	// func CommandLine() *FlagSet
	scope.Insert(types.NewVar(token.NoPos, pkg, "CommandLine", flagSetPtr))

	// FlagSet methods (same as package-level)
	fsRecv := types.NewVar(token.NoPos, nil, "f", flagSetPtr)
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Parse",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "arguments", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", strPtr)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Int",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", intPtr)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Bool",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", boolPtr)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Parsed",
		types.NewSignatureType(fsRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "NArg",
		types.NewSignatureType(fsRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "NFlag",
		types.NewSignatureType(fsRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Arg",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "i", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Args",
		types.NewSignatureType(fsRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	// FlagSet remaining methods (mirror package-level functions)
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Float64",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", float64Ptr)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Int64",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", int64Ptr)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Uint",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Uint]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", uintPtr)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Uint64",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Uint64]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", uint64Ptr)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Duration",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", int64Ptr)),
			false)))
	// FlagSet Var functions
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "StringVar",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "p", strPtr),
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "IntVar",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "p", intPtr),
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "BoolVar",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "p", boolPtr),
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Bool]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Float64Var",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "p", float64Ptr),
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Int64Var",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "p", int64Ptr),
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "UintVar",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "p", uintPtr),
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Uint]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Uint64Var",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "p", uint64Ptr),
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Uint64]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "DurationVar",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "p", int64Ptr),
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Lookup",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", flagTypePtr)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Set",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "PrintDefaults",
		types.NewSignatureType(fsRecv, nil, nil, nil, nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetOutput",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "output", types.NewInterfaceType(nil, nil))),
			nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Name",
		types.NewSignatureType(fsRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "ErrorHandling",
		types.NewSignatureType(fsRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errorHandlingType)),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Output",
		types.NewSignatureType(fsRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))),
			false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Init",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "errorHandling", errorHandlingType)),
			nil, false)))
	flagFnType := types.NewSignatureType(nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, nil, "fn",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", flagTypePtr)),
				nil, false))),
		nil, false)
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Visit",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "fn",
				types.NewSignatureType(nil, nil, nil,
					types.NewTuple(types.NewVar(token.NoPos, nil, "", flagTypePtr)),
					nil, false))),
			nil, false)))
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "VisitAll",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "fn",
				types.NewSignatureType(nil, nil, nil,
					types.NewTuple(types.NewVar(token.NoPos, nil, "", flagTypePtr)),
					nil, false))),
			nil, false)))

	// Package-level missing functions
	// func PrintDefaults()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "PrintDefaults",
		types.NewSignatureType(nil, nil, nil, nil, nil, false)))
	// func Visit(fn func(*Flag))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Visit", flagFnType))
	// func VisitAll(fn func(*Flag))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "VisitAll", flagFnType))
	// func Float64Var(p *float64, name string, value float64, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Float64Var",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", float64Ptr),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			nil, false)))
	// func Int64Var(p *int64, name string, value int64, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Int64Var",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", int64Ptr),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			nil, false)))
	// func UintVar(p *uint, name string, value uint, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "UintVar",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", uintPtr),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Uint]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			nil, false)))
	// func Uint64Var(p *uint64, name string, value uint64, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Uint64Var",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", uint64Ptr),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Uint64]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			nil, false)))
	// func DurationVar(p *int64, name string, value int64, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DurationVar",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", int64Ptr),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			nil, false)))
	// func Func(name, usage string, fn func(string) error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Func",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "fn",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
						false))),
			nil, false)))
	// func BoolFunc(name, usage string, fn func(string) error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "BoolFunc",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "fn",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
						false))),
			nil, false)))
	// func TextVar(p encoding.TextUnmarshaler, name, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "TextVar",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			nil, false)))
	// func UnquoteUsage(flag *Flag) (name string, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "UnquoteUsage",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "flag", flagTypePtr)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// Value interface: String() string, Set(string) error
	valueIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "String",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
				false)),
		types.NewFunc(token.NoPos, pkg, "Set",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	valueIface.Complete()
	valueType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Value", nil),
		valueIface, nil)
	scope.Insert(valueType.Obj())

	// func Var(value Value, name string, usage string)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Var",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "value", valueType),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "usage", types.Typ[types.String])),
			nil, false)))

	// FlagSet.Var
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Var",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "value", valueType),
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			nil, false)))
	// FlagSet.Func
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Func",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "fn",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
						false))),
			nil, false)))
	// FlagSet.BoolFunc
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "BoolFunc",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "fn",
					types.NewSignatureType(nil, nil, nil,
						types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
						types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
						false))),
			nil, false)))
	// FlagSet.TextVar
	flagSetType.AddMethod(types.NewFunc(token.NoPos, pkg, "TextVar",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "p", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "usage", types.Typ[types.String])),
			nil, false)))

	// Getter interface (extends Value with Get() any)
	getterIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Get",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))),
				false)),
	}, []types.Type{valueType})
	getterIface.Complete()
	getterType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Getter", nil),
		getterIface, nil)
	scope.Insert(getterType.Obj())

	// var ErrHelp error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrHelp", errType))

	// var Usage func()
	scope.Insert(types.NewVar(token.NoPos, pkg, "Usage", types.NewSignatureType(nil, nil, nil, nil, nil, false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoSHA256Package creates the type-checked crypto/sha256 package stub.
func buildCryptoSHA256Package() *types.Package {
	pkg := types.NewPackage("crypto/sha256", "sha256")
	scope := pkg.Scope()
	byteSlice := types.NewSlice(types.Typ[types.Byte])
	errType := types.Universe.Lookup("error").Type()

	// hash.Hash interface
	hashIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, nil, "Sum",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
				false)),
		types.NewFunc(token.NoPos, nil, "Reset",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, nil, "Size",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
				false)),
		types.NewFunc(token.NoPos, nil, "BlockSize",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
				false)),
	}, nil)
	hashIface.Complete()

	// const Size = 32
	scope.Insert(types.NewConst(token.NoPos, pkg, "Size", types.Typ[types.Int],
		constant.MakeInt64(32)))

	// const Size224 = 28
	scope.Insert(types.NewConst(token.NoPos, pkg, "Size224", types.Typ[types.Int],
		constant.MakeInt64(28)))

	// const BlockSize = 64
	scope.Insert(types.NewConst(token.NoPos, pkg, "BlockSize", types.Typ[types.Int],
		constant.MakeInt64(64)))

	// func Sum256(data []byte) [32]byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sum256",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "data", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewArray(types.Typ[types.Byte], 32))),
			false)))

	// func Sum224(data []byte) [28]byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sum224",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "data", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewArray(types.Typ[types.Byte], 28))),
			false)))

	// func New() hash.Hash
	scope.Insert(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", hashIface)),
			false)))

	// func New224() hash.Hash
	scope.Insert(types.NewFunc(token.NoPos, pkg, "New224",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", hashIface)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoMD5Package creates the type-checked crypto/md5 package stub.
func buildCryptoMD5Package() *types.Package {
	pkg := types.NewPackage("crypto/md5", "md5")
	scope := pkg.Scope()
	byteSlice := types.NewSlice(types.Typ[types.Byte])
	errType := types.Universe.Lookup("error").Type()

	// hash.Hash interface
	hashIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, nil, "Sum",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
				false)),
		types.NewFunc(token.NoPos, nil, "Reset",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, nil, "Size",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
				false)),
		types.NewFunc(token.NoPos, nil, "BlockSize",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
				false)),
	}, nil)
	hashIface.Complete()

	// const Size = 16
	scope.Insert(types.NewConst(token.NoPos, pkg, "Size", types.Typ[types.Int],
		constant.MakeInt64(16)))

	// const BlockSize = 64
	scope.Insert(types.NewConst(token.NoPos, pkg, "BlockSize", types.Typ[types.Int],
		constant.MakeInt64(64)))

	// func Sum(data []byte) [16]byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sum",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "data", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewArray(types.Typ[types.Byte], 16))),
			false)))

	// func New() hash.Hash
	scope.Insert(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", hashIface)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildEncodingBinaryPackage creates the type-checked encoding/binary package stub.
func buildEncodingBinaryPackage() *types.Package {
	pkg := types.NewPackage("encoding/binary", "binary")
	scope := pkg.Scope()

	// type ByteOrder interface { Uint16, Uint32, Uint64, PutUint16, PutUint32, PutUint64, String }
	byteSliceBin := types.NewSlice(types.Typ[types.Byte])
	byteOrderIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Uint16",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSliceBin)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uint16])), false)),
		types.NewFunc(token.NoPos, pkg, "Uint32",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSliceBin)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uint32])), false)),
		types.NewFunc(token.NoPos, pkg, "Uint64",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSliceBin)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uint64])), false)),
		types.NewFunc(token.NoPos, pkg, "PutUint16",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "b", byteSliceBin),
					types.NewVar(token.NoPos, nil, "v", types.Typ[types.Uint16])),
				nil, false)),
		types.NewFunc(token.NoPos, pkg, "PutUint32",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "b", byteSliceBin),
					types.NewVar(token.NoPos, nil, "v", types.Typ[types.Uint32])),
				nil, false)),
		types.NewFunc(token.NoPos, pkg, "PutUint64",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "b", byteSliceBin),
					types.NewVar(token.NoPos, nil, "v", types.Typ[types.Uint64])),
				nil, false)),
		types.NewFunc(token.NoPos, pkg, "String",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)),
	}, nil)
	byteOrderIface.Complete()
	byteOrderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ByteOrder", nil),
		byteOrderIface, nil)
	scope.Insert(byteOrderType.Obj())

	// var BigEndian, LittleEndian ByteOrder
	scope.Insert(types.NewVar(token.NoPos, pkg, "BigEndian", byteOrderType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "LittleEndian", byteOrderType))

	// func Write(w io.Writer, order ByteOrder, data any) error
	errType := types.Universe.Lookup("error").Type()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "order", byteOrderType),
				types.NewVar(token.NoPos, pkg, "data", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Read(r io.Reader, order ByteOrder, data any) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "order", byteOrderType),
				types.NewVar(token.NoPos, pkg, "data", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func PutUvarint(buf []byte, x uint64) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "PutUvarint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Uint64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Uvarint(buf []byte) (uint64, int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Uvarint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint64]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func PutVarint(buf []byte, x int64) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "PutVarint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Varint(buf []byte) (int64, int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Varint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func Size(v any) int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Size",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "v", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func AppendUvarint(buf []byte, x uint64) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendUvarint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Uint64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			false)))

	// func AppendVarint(buf []byte, x int64) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "AppendVarint",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			false)))

	// var NativeEndian ByteOrder
	scope.Insert(types.NewVar(token.NoPos, pkg, "NativeEndian", byteOrderType))

	// type AppendByteOrder interface (same as ByteOrder)
	appendByteOrderIface := types.NewInterfaceType(nil, nil)
	appendByteOrderIface.Complete()
	appendByteOrderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "AppendByteOrder", nil),
		appendByteOrderIface, nil)
	scope.Insert(appendByteOrderType.Obj())

	// const MaxVarintLen16, MaxVarintLen32, MaxVarintLen64
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxVarintLen16", types.Typ[types.Int], constant.MakeInt64(3)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxVarintLen32", types.Typ[types.Int], constant.MakeInt64(5)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "MaxVarintLen64", types.Typ[types.Int], constant.MakeInt64(10)))

	// func Encode(buf []byte, order ByteOrder, data any) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Encode",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "order", byteOrderType),
				types.NewVar(token.NoPos, pkg, "data", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Decode(buf []byte, order ByteOrder, data any) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Decode",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "order", byteOrderType),
				types.NewVar(token.NoPos, pkg, "data", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Append(order ByteOrder, buf []byte, data any) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Append",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "order", byteOrderType),
				types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "data", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildEncodingCSVPackage creates the type-checked encoding/csv package stub.
func buildEncodingCSVPackage() *types.Package {
	pkg := types.NewPackage("encoding/csv", "csv")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// type Reader struct { ... }
	readerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Comma", types.Typ[types.Int32], false),
		types.NewField(token.NoPos, pkg, "Comment", types.Typ[types.Int32], false),
		types.NewField(token.NoPos, pkg, "FieldsPerRecord", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "LazyQuotes", types.Typ[types.Bool], false),
		types.NewField(token.NoPos, pkg, "TrimLeadingSpace", types.Typ[types.Bool], false),
		types.NewField(token.NoPos, pkg, "ReuseRecord", types.Typ[types.Bool], false),
	}, nil)
	readerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Reader", nil),
		readerStruct, nil)
	scope.Insert(readerType.Obj())
	readerPtr := types.NewPointer(readerType)

	// io interfaces for CSV
	csvByteSlice := types.NewSlice(types.Typ[types.Byte])
	ioReaderCSV := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", csvByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioReaderCSV.Complete()
	ioWriterCSV := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", csvByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioWriterCSV.Complete()

	// func NewReader(r io.Reader) *Reader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", ioReaderCSV)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", readerPtr)),
			false)))

	// type Writer struct { ... }
	writerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Comma", types.Typ[types.Int32], false),
		types.NewField(token.NoPos, pkg, "UseCRLF", types.Typ[types.Bool], false),
	}, nil)
	writerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Writer", nil),
		writerStruct, nil)
	scope.Insert(writerType.Obj())
	writerPtr := types.NewPointer(writerType)

	// func NewWriter(w io.Writer) *Writer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriterCSV)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", writerPtr)),
			false)))

	// Reader methods
	strSlice := types.NewSlice(types.Typ[types.String])
	// func (*Reader) Read() (record []string, err error)
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil,
			nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "record", strSlice),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func (*Reader) ReadAll() (records [][]string, err error)
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadAll",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil,
			nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "records", types.NewSlice(strSlice)),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func (*Reader) FieldPos(field int) (line, column int)
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "FieldPos",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "field", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "line", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "column", types.Typ[types.Int])),
			false)))

	// func (*Reader) InputOffset() int64
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "InputOffset",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64])),
			false)))

	// type ParseError
	parseErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "StartLine", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Line", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Column", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Err", errType, false),
	}, nil)
	parseErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ParseError", nil),
		parseErrStruct, nil)
	parseErrPtr := types.NewPointer(parseErrType)
	parseErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", parseErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	parseErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Unwrap",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", parseErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	scope.Insert(parseErrType.Obj())

	// Writer methods
	// func (*Writer) Write(record []string) error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "record", strSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func (*Writer) WriteAll(records [][]string) error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteAll",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "records", types.NewSlice(strSlice))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func (*Writer) Flush()
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Flush",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil, nil, nil, false)))

	// func (*Writer) Error() error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// var ErrFieldCount, ErrQuote, ErrBareQuote error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrFieldCount", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrQuote", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrBareQuote", errType))

	pkg.MarkComplete()
	return pkg
}

// buildMathBigPackage creates the type-checked math/big package stub.
func buildMathBigPackage() *types.Package {
	pkg := types.NewPackage("math/big", "big")
	scope := pkg.Scope()

	// type Int struct { ... }
	intStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "val", types.Typ[types.Int64], false),
	}, nil)
	intType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Int", nil),
		intStruct, nil)
	scope.Insert(intType.Obj())
	intPtr := types.NewPointer(intType)

	// func NewInt(x int64) *Int
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewInt",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// type Float struct { ... }
	floatStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "val", types.Typ[types.Float64], false),
	}, nil)
	floatType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Float", nil),
		floatStruct, nil)
	scope.Insert(floatType.Obj())
	floatPtr := types.NewPointer(floatType)

	// func NewFloat(x float64) *Float
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewFloat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", floatPtr)),
			false)))

	// type Rat struct {}
	ratStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "num", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "den", types.Typ[types.Int64], false),
	}, nil)
	ratType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Rat", nil),
		ratStruct, nil)
	scope.Insert(ratType.Obj())
	ratPtr := types.NewPointer(ratType)

	// func NewRat(a, b int64) *Rat
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewRat",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "a", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, pkg, "b", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ratPtr)),
			false)))

	// type Accuracy int8
	accuracyType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Accuracy", nil),
		types.Typ[types.Int8], nil)
	scope.Insert(accuracyType.Obj())

	// type RoundingMode byte
	roundingModeType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "RoundingMode", nil),
		types.Typ[types.Byte], nil)
	scope.Insert(roundingModeType.Obj())

	// Int methods
	intRecv := types.NewVar(token.NoPos, nil, "x", intPtr)

	// func (*Int) Add(x, y *Int) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Add",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", intPtr),
				types.NewVar(token.NoPos, pkg, "y", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) Sub(x, y *Int) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Sub",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", intPtr),
				types.NewVar(token.NoPos, pkg, "y", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) Mul(x, y *Int) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Mul",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", intPtr),
				types.NewVar(token.NoPos, pkg, "y", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) Div(x, y *Int) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Div",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", intPtr),
				types.NewVar(token.NoPos, pkg, "y", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) Mod(x, y *Int) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Mod",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", intPtr),
				types.NewVar(token.NoPos, pkg, "y", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) Cmp(y *Int) int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cmp",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "y", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func (*Int) Int64() int64
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Int64",
		types.NewSignatureType(intRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int64])),
			false)))

	// func (*Int) SetInt64(x int64) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetInt64",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) SetString(s string, base int) (*Int, bool)
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetString",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "base", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", intPtr),
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func (*Int) String() string
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(intRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (*Int) Bytes() []byte
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Bytes",
		types.NewSignatureType(intRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			false)))

	// func (*Int) SetBytes(buf []byte) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetBytes",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "buf", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) Sign() int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Sign",
		types.NewSignatureType(intRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func (*Int) Abs(x *Int) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Abs",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) Neg(x *Int) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Neg",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) Set(x *Int) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Set",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) IsInt64() bool
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsInt64",
		types.NewSignatureType(intRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// func (*Int) BitLen() int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "BitLen",
		types.NewSignatureType(intRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	// func (*Int) Exp(x, y, m *Int) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "Exp",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", intPtr),
				types.NewVar(token.NoPos, pkg, "y", intPtr),
				types.NewVar(token.NoPos, pkg, "m", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// func (*Int) GCD(x, y, a, b *Int) *Int
	intType.AddMethod(types.NewFunc(token.NoPos, pkg, "GCD",
		types.NewSignatureType(intRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", intPtr),
				types.NewVar(token.NoPos, pkg, "y", intPtr),
				types.NewVar(token.NoPos, pkg, "a", intPtr),
				types.NewVar(token.NoPos, pkg, "b", intPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", intPtr)),
			false)))

	// Float methods — similar patterns
	floatRecv := types.NewVar(token.NoPos, nil, "x", floatPtr)

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "Add",
		types.NewSignatureType(floatRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", floatPtr),
				types.NewVar(token.NoPos, pkg, "y", floatPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", floatPtr)),
			false)))

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "Sub",
		types.NewSignatureType(floatRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", floatPtr),
				types.NewVar(token.NoPos, pkg, "y", floatPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", floatPtr)),
			false)))

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "Mul",
		types.NewSignatureType(floatRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", floatPtr),
				types.NewVar(token.NoPos, pkg, "y", floatPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", floatPtr)),
			false)))

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "Quo",
		types.NewSignatureType(floatRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", floatPtr),
				types.NewVar(token.NoPos, pkg, "y", floatPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", floatPtr)),
			false)))

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cmp",
		types.NewSignatureType(floatRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "y", floatPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "Float64",
		types.NewSignatureType(floatRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Float64]),
				types.NewVar(token.NoPos, pkg, "", accuracyType)),
			false)))

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetFloat64",
		types.NewSignatureType(floatRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "x", types.Typ[types.Float64])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", floatPtr)),
			false)))

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(floatRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetPrec",
		types.NewSignatureType(floatRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "prec", types.Typ[types.Uint])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", floatPtr)),
			false)))

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "Sign",
		types.NewSignatureType(floatRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int])),
			false)))

	floatType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsInf",
		types.NewSignatureType(floatRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// Rat methods
	ratRecv := types.NewVar(token.NoPos, nil, "x", ratPtr)
	_ = ratRecv // available for future Rat method extensions

	pkg.MarkComplete()
	return pkg
}

// buildTextTemplatePackage creates the type-checked text/template package stub.
func buildTextTemplatePackage() *types.Package {
	pkg := types.NewPackage("text/template", "template")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// type Template struct { ... }
	tmplStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "name", types.Typ[types.String], false),
	}, nil)
	tmplType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Template", nil),
		tmplStruct, nil)
	scope.Insert(tmplType.Obj())
	tmplPtr := types.NewPointer(tmplType)

	// func New(name string) *Template
	scope.Insert(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))

	// func Must(t *Template, err error) *Template
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Must",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "t", tmplPtr),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))

	// func ParseFiles(filenames ...string) (*Template, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseFiles",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "filenames", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// func ParseGlob(pattern string) (*Template, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseGlob",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// type FuncMap map[string]any
	funcMapType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FuncMap", nil),
		types.NewMap(types.Typ[types.String], types.NewInterfaceType(nil, nil)), nil)
	scope.Insert(funcMapType.Obj())

	// io.Writer for template Execute
	tmplByteSlice := types.NewSlice(types.Typ[types.Byte])
	tmplWriterIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", tmplByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	tmplWriterIface.Complete()
	anyType := types.NewInterfaceType(nil, nil)

	// Template methods
	tmplRecv := types.NewVar(token.NoPos, nil, "t", tmplPtr)

	// func (*Template) Parse(text string) (*Template, error)
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Parse",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "text", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func (*Template) Execute(wr io.Writer, data any) error
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Execute",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "wr", tmplWriterIface),
				types.NewVar(token.NoPos, pkg, "data", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func (*Template) ExecuteTemplate(wr io.Writer, name string, data any) error
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "ExecuteTemplate",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "wr", tmplWriterIface),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "data", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func (*Template) Funcs(funcMap FuncMap) *Template
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Funcs",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "funcMap", funcMapType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))

	// func (*Template) ParseFiles(filenames ...string) (*Template, error)
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "ParseFiles",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "filenames", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// func (*Template) ParseGlob(pattern string) (*Template, error)
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "ParseGlob",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func (*Template) Name() string
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Name",
		types.NewSignatureType(tmplRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func (*Template) New(name string) *Template
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))

	// func (*Template) Lookup(name string) *Template
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Lookup",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))

	// func (*Template) Option(opt ...string) *Template
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Option",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "opt", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))

	// func (*Template) Clone() (*Template, error)
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Clone",
		types.NewSignatureType(tmplRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildEmbedPackage creates the type-checked embed package stub.
func buildEmbedPackage() *types.Package {
	pkg := types.NewPackage("embed", "embed")
	scope := pkg.Scope()

	errType := types.Universe.Lookup("error").Type()

	// type FS struct { ... }
	fsStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "files", types.Typ[types.Int], false),
	}, nil)
	fsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FS", nil),
		fsStruct, nil)
	scope.Insert(fsType.Obj())

	// FS methods
	fsRecv := types.NewVar(token.NoPos, nil, "f", fsType)
	fsType.AddMethod(types.NewFunc(token.NoPos, pkg, "Open",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	fsType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadDir",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.NewInterfaceType(nil, nil))),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	fsType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadFile",
		types.NewSignatureType(fsRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildHashPackage creates the type-checked hash package stub.
func buildHashPackage() *types.Package {
	pkg := types.NewPackage("hash", "hash")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// type Hash interface {
	//   io.Writer (Write(p []byte) (n int, err error))
	//   Sum(b []byte) []byte
	//   Reset()
	//   Size() int
	//   BlockSize() int
	// }
	hashIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Sum",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Reset",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, pkg, "Size",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
				false)),
		types.NewFunc(token.NoPos, pkg, "BlockSize",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
				false)),
	}, nil)
	hashIface.Complete()
	hashType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Hash", nil),
		hashIface, nil)
	scope.Insert(hashType.Obj())

	// type Hash32 interface {
	//   Hash
	//   Sum32() uint32
	// }
	hash32Iface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Sum32",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uint32])),
				false)),
	}, []types.Type{hashType})
	hash32Iface.Complete()
	hash32Type := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Hash32", nil),
		hash32Iface, nil)
	scope.Insert(hash32Type.Obj())

	// type Hash64 interface {
	//   Hash
	//   Sum64() uint64
	// }
	hash64Iface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Sum64",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uint64])),
				false)),
	}, []types.Type{hashType})
	hash64Iface.Complete()
	hash64Type := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Hash64", nil),
		hash64Iface, nil)
	scope.Insert(hash64Type.Obj())

	pkg.MarkComplete()
	return pkg
}

// buildHashCRC32Package creates the type-checked hash/crc32 package stub.
func buildHashCRC32Package() *types.Package {
	pkg := types.NewPackage("hash/crc32", "crc32")
	scope := pkg.Scope()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// const Size = 4
	scope.Insert(types.NewConst(token.NoPos, pkg, "Size", types.Typ[types.Int],
		constant.MakeInt64(4)))

	// type Table [256]uint32
	tableType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Table", nil),
		types.NewArray(types.Typ[types.Uint32], 256), nil)
	scope.Insert(tableType.Obj())
	tablePtr := types.NewPointer(tableType)

	// Predefined polynomial constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "IEEE", types.Typ[types.Uint32], constant.MakeUint64(0xedb88320)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Castagnoli", types.Typ[types.Uint32], constant.MakeUint64(0x82f63b78)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Koopman", types.Typ[types.Uint32], constant.MakeUint64(0xeb31d82e)))

	// var IEEETable *Table
	scope.Insert(types.NewVar(token.NoPos, pkg, "IEEETable", tablePtr))

	// func MakeTable(poly uint32) *Table
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MakeTable",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "poly", types.Typ[types.Uint32])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tablePtr)),
			false)))

	// hash.Hash32 interface
	hashIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", types.Universe.Lookup("error").Type())),
				false)),
		types.NewFunc(token.NoPos, nil, "Sum",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
				false)),
		types.NewFunc(token.NoPos, nil, "Reset",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, nil, "Size",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
				false)),
		types.NewFunc(token.NoPos, nil, "BlockSize",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
				false)),
	}, nil)
	hashIface.Complete()

	// func New(tab *Table) hash.Hash32
	scope.Insert(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "tab", tablePtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", hashIface)),
			false)))

	// func NewIEEE() hash.Hash32
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewIEEE",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", hashIface)),
			false)))

	// func ChecksumIEEE(data []byte) uint32
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ChecksumIEEE",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "data", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint32])),
			false)))

	// func Checksum(data []byte, tab *Table) uint32
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Checksum",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "data", byteSlice),
				types.NewVar(token.NoPos, pkg, "tab", tablePtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint32])),
			false)))

	// func Update(crc uint32, tab *Table, p []byte) uint32
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Update",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "crc", types.Typ[types.Uint32]),
				types.NewVar(token.NoPos, pkg, "tab", tablePtr),
				types.NewVar(token.NoPos, pkg, "p", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Uint32])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildNetPackage creates the type-checked net package stub.
func buildNetPackage() *types.Package {
	pkg := types.NewPackage("net", "net")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// type Addr interface { Network() string; String() string }
	addrIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Network",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
				false)),
		types.NewFunc(token.NoPos, pkg, "String",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
				false)),
	}, nil)
	addrIface.Complete()
	addrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Addr", nil),
		addrIface, nil)
	scope.Insert(addrType.Obj())

	// type Conn interface { Read, Write, Close, LocalAddr, RemoteAddr, SetDeadline, SetReadDeadline, SetWriteDeadline }
	connIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "LocalAddr",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", addrType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "RemoteAddr",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", addrType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "SetDeadline",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "t", types.Typ[types.Int64])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "SetReadDeadline",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "t", types.Typ[types.Int64])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "SetWriteDeadline",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "t", types.Typ[types.Int64])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	connIface.Complete()
	connType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Conn", nil),
		connIface, nil)
	scope.Insert(connType.Obj())

	// type Listener interface { Accept() (Conn, error); Close() error; Addr() Addr }
	listenerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Accept",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", connType),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Addr",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", addrType)),
				false)),
	}, nil)
	listenerIface.Complete()
	listenerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Listener", nil),
		listenerIface, nil)
	scope.Insert(listenerType.Obj())

	// func Dial(network, address string) (Conn, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Dial",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "address", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", connType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Listen(network, address string) (Listener, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Listen",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "address", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", listenerType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func JoinHostPort(host, port string) string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "JoinHostPort",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "host", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "port", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// func SplitHostPort(hostport string) (host, port string, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SplitHostPort",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "hostport", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "host", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "port", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// type IP []byte
	ipType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "IP", nil), byteSlice, nil)
	scope.Insert(ipType.Obj())
	ipType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "ip", ipType), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))
	ipType.AddMethod(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "ip", ipType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", ipType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)))
	ipType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsLoopback",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "ip", ipType), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)))
	ipType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsPrivate",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "ip", ipType), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)))
	ipType.AddMethod(types.NewFunc(token.NoPos, pkg, "IsUnspecified",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "ip", ipType), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)))
	ipType.AddMethod(types.NewFunc(token.NoPos, pkg, "To4",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "ip", ipType), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", ipType)), false)))
	ipType.AddMethod(types.NewFunc(token.NoPos, pkg, "To16",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "ip", ipType), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", ipType)), false)))
	ipType.AddMethod(types.NewFunc(token.NoPos, pkg, "MarshalText",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "ip", ipType), nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", byteSlice),
				types.NewVar(token.NoPos, nil, "", errType)), false)))

	// type IPMask []byte
	ipMaskType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "IPMask", nil), byteSlice, nil)
	scope.Insert(ipMaskType.Obj())
	ipMaskType.AddMethod(types.NewFunc(token.NoPos, pkg, "Size",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", ipMaskType), nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "ones", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "bits", types.Typ[types.Int])), false)))
	ipMaskType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "m", ipMaskType), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))

	// type IPNet struct { IP IP; Mask IPMask }
	ipNetStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "IP", ipType, false),
		types.NewField(token.NoPos, pkg, "Mask", ipMaskType, false),
	}, nil)
	ipNetType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "IPNet", nil), ipNetStruct, nil)
	scope.Insert(ipNetType.Obj())
	ipNetPtr := types.NewPointer(ipNetType)
	ipNetType.AddMethod(types.NewFunc(token.NoPos, pkg, "Contains",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "n", ipNetPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "ip", ipType)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)))
	ipNetType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "n", ipNetPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))

	// type TCPAddr struct { IP IP; Port int; Zone string }
	tcpAddrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "IP", ipType, false),
		types.NewField(token.NoPos, pkg, "Port", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Zone", types.Typ[types.String], false),
	}, nil)
	tcpAddrType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "TCPAddr", nil), tcpAddrStruct, nil)
	scope.Insert(tcpAddrType.Obj())
	tcpAddrPtr := types.NewPointer(tcpAddrType)
	tcpAddrType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "a", tcpAddrPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))
	tcpAddrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Network",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "a", tcpAddrPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))

	// type UDPAddr struct { IP IP; Port int; Zone string }
	udpAddrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "IP", ipType, false),
		types.NewField(token.NoPos, pkg, "Port", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Zone", types.Typ[types.String], false),
	}, nil)
	udpAddrType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "UDPAddr", nil), udpAddrStruct, nil)
	scope.Insert(udpAddrType.Obj())
	udpAddrPtr := types.NewPointer(udpAddrType)
	udpAddrType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "a", udpAddrPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))
	udpAddrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Network",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "a", udpAddrPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))

	// type Dialer struct { Timeout time.Duration }
	dialerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Timeout", types.Typ[types.Int64], false),
	}, nil)
	dialerType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Dialer", nil), dialerStruct, nil)
	scope.Insert(dialerType.Obj())
	dialerPtr := types.NewPointer(dialerType)
	dialerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Dial",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "d", dialerPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "address", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", connType),
				types.NewVar(token.NoPos, nil, "", errType)), false)))
	dialerType.AddMethod(types.NewFunc(token.NoPos, pkg, "DialContext",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "d", dialerPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "ctx", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "address", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", connType),
				types.NewVar(token.NoPos, nil, "", errType)), false)))

	// type Resolver struct {}
	resolverType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Resolver", nil), types.NewStruct(nil, nil), nil)
	scope.Insert(resolverType.Obj())
	resolverPtr := types.NewPointer(resolverType)
	resolverType.AddMethod(types.NewFunc(token.NoPos, pkg, "LookupHost",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", resolverPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "ctx", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "host", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String])),
				types.NewVar(token.NoPos, nil, "", errType)), false)))

	// func ParseIP(s string) IP
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseIP",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ipType)), false)))

	// func ParseCIDR(s string) (IP, *IPNet, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseCIDR",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", ipType),
				types.NewVar(token.NoPos, pkg, "", ipNetPtr),
				types.NewVar(token.NoPos, pkg, "", errType)), false)))

	// func IPv4(a, b, c, d byte) IP
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IPv4",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "a", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "b", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "c", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "d", types.Typ[types.Byte])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ipType)), false)))

	// func CIDRMask(ones, bits int) IPMask
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CIDRMask",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ones", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "bits", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ipMaskType)), false)))

	// func IPv4Mask(a, b, c, d byte) IPMask
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IPv4Mask",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "a", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "b", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "c", types.Typ[types.Byte]),
				types.NewVar(token.NoPos, pkg, "d", types.Typ[types.Byte])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ipMaskType)), false)))

	// func ResolveTCPAddr(network, address string) (*TCPAddr, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ResolveTCPAddr",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "address", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tcpAddrPtr),
				types.NewVar(token.NoPos, pkg, "", errType)), false)))

	// func ResolveUDPAddr(network, address string) (*UDPAddr, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ResolveUDPAddr",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "address", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", udpAddrPtr),
				types.NewVar(token.NoPos, pkg, "", errType)), false)))

	// func DialTimeout(network, address string, timeout time.Duration) (Conn, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DialTimeout",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "address", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "timeout", types.Typ[types.Int64])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", connType),
				types.NewVar(token.NoPos, pkg, "", errType)), false)))

	// func LookupHost(host string) ([]string, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LookupHost",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "host", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String])),
				types.NewVar(token.NoPos, pkg, "", errType)), false)))

	// func LookupIP(host string) ([]IP, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LookupIP",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "host", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(ipType)),
				types.NewVar(token.NoPos, pkg, "", errType)), false)))

	// func LookupPort(network, service string) (int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LookupPort",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "service", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)), false)))

	// type Error interface { error; Timeout() bool; Temporary() bool }
	netErrIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Error",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
				false)),
		types.NewFunc(token.NoPos, pkg, "Timeout",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
				false)),
		types.NewFunc(token.NoPos, pkg, "Temporary",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
				false)),
	}, nil)
	netErrIface.Complete()
	netErrType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Error", nil), netErrIface, nil)
	scope.Insert(netErrType.Obj())

	// var IPv4zero, IPv4bcast, IPv6zero, IPv6loopback IP
	scope.Insert(types.NewVar(token.NoPos, pkg, "IPv4zero", ipType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "IPv4bcast", ipType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "IPv6zero", ipType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "IPv6loopback", ipType))

	// var ErrClosed error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrClosed", errType))

	// const IPv4len = 4, IPv6len = 16
	scope.Insert(types.NewConst(token.NoPos, pkg, "IPv4len", types.Typ[types.Int], constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "IPv6len", types.Typ[types.Int], constant.MakeInt64(16)))

	// type OpError struct { ... }
	opErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Op", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Net", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Err", errType, false),
	}, nil)
	opErrType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "OpError", nil), opErrStruct, nil)
	scope.Insert(opErrType.Obj())
	opErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", types.NewPointer(opErrType)), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))

	// type DNSError struct { ... }
	dnsErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Err", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
	}, nil)
	dnsErrType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "DNSError", nil), dnsErrStruct, nil)
	scope.Insert(dnsErrType.Obj())
	dnsErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", types.NewPointer(dnsErrType)), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))
	dnsErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Timeout",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", types.NewPointer(dnsErrType)), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)))
	dnsErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Temporary",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", types.NewPointer(dnsErrType)), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)))

	// type PacketConn interface { ReadFrom, WriteTo, Close, LocalAddr, SetDeadline, SetReadDeadline, SetWriteDeadline }
	packetConnIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "ReadFrom",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "addr", addrType),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "WriteTo",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "p", byteSlice),
					types.NewVar(token.NoPos, nil, "addr", addrType)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "LocalAddr",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", addrType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "SetDeadline",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "t", types.Typ[types.Int64])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "SetReadDeadline",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "t", types.Typ[types.Int64])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, pkg, "SetWriteDeadline",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "t", types.Typ[types.Int64])),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	packetConnIface.Complete()
	packetConnType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "PacketConn", nil), packetConnIface, nil)
	scope.Insert(packetConnType.Obj())

	// func ListenPacket(network, address string) (PacketConn, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ListenPacket",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "address", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "", errType)), false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoRandPackage creates the type-checked crypto/rand package stub.
func buildCryptoRandPackage() *types.Package {
	pkg := types.NewPackage("crypto/rand", "rand")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// io.Reader interface for Reader var and function params
	ioReaderIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioReaderIface.Complete()

	// var Reader io.Reader
	scope.Insert(types.NewVar(token.NoPos, pkg, "Reader", ioReaderIface))

	// func Read(b []byte) (n int, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "b", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// *big.Int stand-in (opaque pointer)
	bigIntStruct := types.NewStruct(nil, nil)
	bigIntType := types.NewNamed(types.NewTypeName(token.NoPos, nil, "bigInt", nil), bigIntStruct, nil)
	bigIntPtr := types.NewPointer(bigIntType)

	// func Int(rand io.Reader, max *big.Int) (*big.Int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Int",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "rand", ioReaderIface),
				types.NewVar(token.NoPos, pkg, "max", bigIntPtr)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", bigIntPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Prime(rand io.Reader, bits int) (*big.Int, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Prime",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "rand", ioReaderIface),
				types.NewVar(token.NoPos, pkg, "bits", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", bigIntPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoHMACPackage creates the type-checked crypto/hmac package stub.
func buildCryptoHMACPackage() *types.Package {
	pkg := types.NewPackage("crypto/hmac", "hmac")
	scope := pkg.Scope()

	// hash.Hash interface
	byteSlice := types.NewSlice(types.Typ[types.Byte])
	errType := types.Universe.Lookup("error").Type()
	hashIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, nil, "Sum",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
				false)),
		types.NewFunc(token.NoPos, nil, "Reset",
			types.NewSignatureType(nil, nil, nil, nil, nil, false)),
		types.NewFunc(token.NoPos, nil, "Size",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
				false)),
		types.NewFunc(token.NoPos, nil, "BlockSize",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
				false)),
	}, nil)
	hashIface.Complete()

	// func() hash.Hash — hash factory function type
	hashFactoryFn := types.NewSignatureType(nil, nil, nil, nil,
		types.NewTuple(types.NewVar(token.NoPos, nil, "", hashIface)),
		false)

	// func New(h func() hash.Hash, key []byte) hash.Hash
	scope.Insert(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "h", hashFactoryFn),
				types.NewVar(token.NoPos, pkg, "key", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", hashIface)),
			false)))

	// func Equal(mac1, mac2 []byte) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "mac1", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "mac2", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoAESPackage creates the type-checked crypto/aes package stub.
func buildCryptoAESPackage() *types.Package {
	pkg := types.NewPackage("crypto/aes", "aes")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// cipher.Block interface (local stand-in)
	cipherBlock := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "BlockSize",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, nil, "Encrypt",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "dst", byteSlice),
					types.NewVar(token.NoPos, nil, "src", byteSlice)),
				nil, false)),
		types.NewFunc(token.NoPos, nil, "Decrypt",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "dst", byteSlice),
					types.NewVar(token.NoPos, nil, "src", byteSlice)),
				nil, false)),
	}, nil)
	cipherBlock.Complete()

	// type KeySizeError int
	keySizeErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "KeySizeError", nil),
		types.Typ[types.Int], nil)
	scope.Insert(keySizeErrType.Obj())

	scope.Insert(types.NewConst(token.NoPos, pkg, "BlockSize", types.Typ[types.Int], constant.MakeInt64(16)))

	// func NewCipher(key []byte) (cipher.Block, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewCipher",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "key", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", cipherBlock),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoCipherPackage creates the type-checked crypto/cipher package stub.
func buildCryptoCipherPackage() *types.Package {
	pkg := types.NewPackage("crypto/cipher", "cipher")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// Block interface
	blockIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "BlockSize",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "Encrypt",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "dst", byteSlice),
					types.NewVar(token.NoPos, nil, "src", byteSlice)),
				nil, false)),
		types.NewFunc(token.NoPos, pkg, "Decrypt",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "dst", byteSlice),
					types.NewVar(token.NoPos, nil, "src", byteSlice)),
				nil, false)),
	}, nil)
	blockIface.Complete()
	blockType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Block", nil),
		blockIface, nil)
	scope.Insert(blockType.Obj())

	// Stream interface
	streamIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "XORKeyStream",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "dst", byteSlice),
					types.NewVar(token.NoPos, nil, "src", byteSlice)),
				nil, false)),
	}, nil)
	streamIface.Complete()
	streamType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Stream", nil),
		streamIface, nil)
	scope.Insert(streamType.Obj())

	// AEAD interface
	aeadIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "NonceSize",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "Overhead",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "Seal",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "dst", byteSlice),
					types.NewVar(token.NoPos, nil, "nonce", byteSlice),
					types.NewVar(token.NoPos, nil, "plaintext", byteSlice),
					types.NewVar(token.NoPos, nil, "additionalData", byteSlice)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)), false)),
		types.NewFunc(token.NoPos, pkg, "Open",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "dst", byteSlice),
					types.NewVar(token.NoPos, nil, "nonce", byteSlice),
					types.NewVar(token.NoPos, nil, "ciphertext", byteSlice),
					types.NewVar(token.NoPos, nil, "additionalData", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", byteSlice),
					types.NewVar(token.NoPos, nil, "", errType)), false)),
	}, nil)
	aeadIface.Complete()
	aeadType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "AEAD", nil),
		aeadIface, nil)
	scope.Insert(aeadType.Obj())

	// BlockMode interface
	blockModeIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "BlockSize",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])), false)),
		types.NewFunc(token.NoPos, pkg, "CryptBlocks",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "dst", byteSlice),
					types.NewVar(token.NoPos, nil, "src", byteSlice)),
				nil, false)),
	}, nil)
	blockModeIface.Complete()
	blockModeType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "BlockMode", nil),
		blockModeIface, nil)
	scope.Insert(blockModeType.Obj())

	// func NewGCM(cipher Block) (AEAD, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewGCM",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "cipher", blockType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", aeadType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func NewCFBEncrypter(block Block, iv []byte) Stream
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewCFBEncrypter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "block", blockType),
				types.NewVar(token.NoPos, pkg, "iv", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", streamType)),
			false)))

	// func NewCFBDecrypter(block Block, iv []byte) Stream
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewCFBDecrypter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "block", blockType),
				types.NewVar(token.NoPos, pkg, "iv", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", streamType)),
			false)))

	// func NewCBCEncrypter(b Block, iv []byte) BlockMode
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewCBCEncrypter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", blockType),
				types.NewVar(token.NoPos, pkg, "iv", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", blockModeType)),
			false)))

	// func NewCBCDecrypter(b Block, iv []byte) BlockMode
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewCBCDecrypter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", blockType),
				types.NewVar(token.NoPos, pkg, "iv", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", blockModeType)),
			false)))

	// func NewCTR(block Block, iv []byte) Stream
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewCTR",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "block", blockType),
				types.NewVar(token.NoPos, pkg, "iv", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", streamType)),
			false)))

	// func NewOFB(b Block, iv []byte) Stream
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewOFB",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "b", blockType),
				types.NewVar(token.NoPos, pkg, "iv", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", streamType)),
			false)))

	// func NewGCMWithNonceSize(cipher Block, size int) (AEAD, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewGCMWithNonceSize",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "cipher", blockType),
				types.NewVar(token.NoPos, pkg, "size", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", aeadType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func NewGCMWithTagSize(cipher Block, tagSize int) (AEAD, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewGCMWithTagSize",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "cipher", blockType),
				types.NewVar(token.NoPos, pkg, "tagSize", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", aeadType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// io.Reader interface for StreamReader
	cipherIOReader := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	cipherIOReader.Complete()

	// io.Writer interface for StreamWriter
	cipherIOWriter := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	cipherIOWriter.Complete()

	// type StreamReader struct { S Stream; R io.Reader }
	streamReaderStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "S", streamType, false),
		types.NewField(token.NoPos, pkg, "R", cipherIOReader, false),
	}, nil)
	streamReaderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "StreamReader", nil),
		streamReaderStruct, nil)
	scope.Insert(streamReaderType.Obj())
	streamReaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "r", streamReaderType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "dst", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))

	// type StreamWriter struct { S Stream; W io.Writer; Err error }
	streamWriterStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "S", streamType, false),
		types.NewField(token.NoPos, pkg, "W", cipherIOWriter, false),
		types.NewField(token.NoPos, pkg, "Err", errType, false),
	}, nil)
	streamWriterType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "StreamWriter", nil),
		streamWriterStruct, nil)
	scope.Insert(streamWriterType.Obj())
	streamWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "w", streamWriterType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "src", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	streamWriterType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(
			types.NewVar(token.NoPos, nil, "w", streamWriterType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildUnicodeUTF16Package creates the type-checked unicode/utf16 package stub.
func buildUnicodeUTF16Package() *types.Package {
	pkg := types.NewPackage("unicode/utf16", "utf16")
	scope := pkg.Scope()

	// func Encode(s []rune) []uint16
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Encode",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.NewSlice(types.Typ[types.Rune]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Uint16]))),
			false)))

	// func Decode(s []uint16) []rune
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Decode",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.NewSlice(types.Typ[types.Uint16]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Rune]))),
			false)))

	// func IsSurrogate(r rune) bool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "IsSurrogate",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", types.Typ[types.Rune])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildEncodingXMLPackage creates the type-checked encoding/xml package stub.
func buildEncodingXMLPackage() *types.Package {
	pkg := types.NewPackage("encoding/xml", "xml")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	anyType := types.Universe.Lookup("any").Type()

	// func Marshal(v any) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Marshal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "v", anyType)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Unmarshal(data []byte, v any) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Unmarshal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "v", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func MarshalIndent(v any, prefix, indent string) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MarshalIndent",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "v", anyType),
				types.NewVar(token.NoPos, pkg, "prefix", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "indent", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	scope.Insert(types.NewConst(token.NoPos, pkg, "Header", types.Typ[types.String],
		constant.MakeString("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")))

	// io.Writer interface for XML functions
	xmlByteSlice := types.NewSlice(types.Typ[types.Byte])
	ioWriterXML := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", xmlByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioWriterXML.Complete()

	// io.Reader interface for XML functions
	ioReaderXML := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", xmlByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioReaderXML.Complete()

	// func EscapeText(w io.Writer, data []byte) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EscapeText",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", ioWriterXML),
				types.NewVar(token.NoPos, pkg, "data", xmlByteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func Escape(w io.Writer, data []byte)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Escape",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", ioWriterXML),
				types.NewVar(token.NoPos, pkg, "data", xmlByteSlice)),
			nil, false)))

	// func CopyToken(t Token) Token
	tokenType := types.NewInterfaceType(nil, nil)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CopyToken",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "t", tokenType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tokenType)),
			false)))

	// type Token interface{}
	tokenTypeName := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Token", nil),
		tokenType, nil)
	scope.Insert(tokenTypeName.Obj())

	// type Encoder struct {}
	encoderStruct := types.NewStruct(nil, nil)
	encoderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Encoder", nil),
		encoderStruct, nil)
	scope.Insert(encoderType.Obj())
	encoderPtr := types.NewPointer(encoderType)

	// func NewEncoder(w io.Writer) *Encoder
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewEncoder",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriterXML)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", encoderPtr)),
			false)))

	// Encoder methods
	encRecv := types.NewVar(token.NoPos, nil, "enc", encoderPtr)
	encoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Encode",
		types.NewSignatureType(encRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "v", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	encoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "EncodeToken",
		types.NewSignatureType(encRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "t", tokenType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	// Forward-declare StartElement for EncodeElement; actual struct set below
	startElemTypeName := types.NewTypeName(token.NoPos, pkg, "StartElement", nil)
	startElemType := types.NewNamed(startElemTypeName, nil, nil)

	encoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "EncodeElement",
		types.NewSignatureType(encRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "v", anyType),
				types.NewVar(token.NoPos, pkg, "start", startElemType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	encoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Flush",
		types.NewSignatureType(encRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	encoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Indent",
		types.NewSignatureType(encRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "prefix", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "indent", types.Typ[types.String])),
			nil, false)))

	// type Decoder struct {}
	decoderStruct := types.NewStruct(nil, nil)
	decoderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Decoder", nil),
		decoderStruct, nil)
	scope.Insert(decoderType.Obj())
	decoderPtr := types.NewPointer(decoderType)

	// func NewDecoder(r io.Reader) *Decoder
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewDecoder",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", ioReaderXML)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", decoderPtr)),
			false)))

	// Decoder methods
	decRecv := types.NewVar(token.NoPos, nil, "d", decoderPtr)
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Decode",
		types.NewSignatureType(decRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "v", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "DecodeElement",
		types.NewSignatureType(decRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "v", anyType),
				types.NewVar(token.NoPos, pkg, "start", types.NewPointer(startElemType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Token",
		types.NewSignatureType(decRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tokenType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Skip",
		types.NewSignatureType(decRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Common XML types
	// type Name struct { Space, Local string }
	nameStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Space", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Local", types.Typ[types.String], false),
	}, nil)
	nameType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Name", nil),
		nameStruct, nil)
	scope.Insert(nameType.Obj())

	// type Attr struct { Name Name; Value string }
	attrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Name", nameType, false),
		types.NewField(token.NoPos, pkg, "Value", types.Typ[types.String], false),
	}, nil)
	attrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Attr", nil),
		attrStruct, nil)
	scope.Insert(attrType.Obj())

	// Set StartElement underlying struct (forward-declared above for EncodeElement)
	startElemStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Name", nameType, false),
		types.NewField(token.NoPos, pkg, "Attr", types.NewSlice(attrType), false),
	}, nil)
	startElemType.SetUnderlying(startElemStruct)
	scope.Insert(startElemType.Obj())

	// type EndElement struct { Name Name }
	endElemStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Name", nameType, false),
	}, nil)
	endElemType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "EndElement", nil),
		endElemStruct, nil)
	scope.Insert(endElemType.Obj())

	// type CharData []byte
	charDataType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CharData", nil),
		types.NewSlice(types.Typ[types.Byte]), nil)
	scope.Insert(charDataType.Obj())

	// type Comment []byte
	commentType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Comment", nil),
		types.NewSlice(types.Typ[types.Byte]), nil)
	scope.Insert(commentType.Obj())

	// type ProcInst struct { Target string; Inst []byte }
	procInstStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Target", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Inst", types.NewSlice(types.Typ[types.Byte]), false),
	}, nil)
	procInstType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ProcInst", nil),
		procInstStruct, nil)
	scope.Insert(procInstType.Obj())

	// type Directive []byte
	directiveType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Directive", nil),
		types.NewSlice(types.Typ[types.Byte]), nil)
	scope.Insert(directiveType.Obj())

	// Marshaler interface: MarshalXML(e *Encoder, start StartElement) error
	marshalerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "MarshalXML",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "e", encoderPtr),
					types.NewVar(token.NoPos, nil, "start", startElemType)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	marshalerIface.Complete()
	marshalerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Marshaler", nil),
		marshalerIface, nil)
	scope.Insert(marshalerType.Obj())

	// Unmarshaler interface: UnmarshalXML(d *Decoder, start StartElement) error
	unmarshalerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "UnmarshalXML",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "d", decoderPtr),
					types.NewVar(token.NoPos, nil, "start", startElemType)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	unmarshalerIface.Complete()
	unmarshalerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Unmarshaler", nil),
		unmarshalerIface, nil)
	scope.Insert(unmarshalerType.Obj())

	// StartElement methods
	startElemType.AddMethod(types.NewFunc(token.NoPos, pkg, "Copy",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", startElemType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", startElemType)),
			false)))
	startElemType.AddMethod(types.NewFunc(token.NoPos, pkg, "End",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", startElemType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", endElemType)),
			false)))

	// CharData.Copy, Comment.Copy
	charDataType.AddMethod(types.NewFunc(token.NoPos, pkg, "Copy",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", charDataType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", charDataType)),
			false)))
	commentType.AddMethod(types.NewFunc(token.NoPos, pkg, "Copy",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", commentType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", commentType)),
			false)))
	procInstType.AddMethod(types.NewFunc(token.NoPos, pkg, "Copy",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "p", procInstType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", procInstType)),
			false)))
	directiveType.AddMethod(types.NewFunc(token.NoPos, pkg, "Copy",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "d", directiveType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", directiveType)),
			false)))

	// Decoder.RawToken
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "RawToken",
		types.NewSignatureType(decRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", tokenType),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// Decoder.InputOffset
	decoderType.AddMethod(types.NewFunc(token.NoPos, pkg, "InputOffset",
		types.NewSignatureType(decRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64])),
			false)))

	// Decoder.CharsetReader field (set via Decoder.CharsetReader = func...)
	// Already in struct as empty — leave Decoder opaque

	// Error types
	// type SyntaxError struct { Msg string; Line int }
	syntaxErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Msg", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Line", types.Typ[types.Int], false),
	}, nil)
	syntaxErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "SyntaxError", nil),
		syntaxErrStruct, nil)
	syntaxErrPtr := types.NewPointer(syntaxErrType)
	syntaxErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", syntaxErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(syntaxErrType.Obj())

	// type TagPathError struct { Struct reflect.Type; ... }
	tagPathErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Field1", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Tag1", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Field2", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Tag2", types.Typ[types.String], false),
	}, nil)
	tagPathErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "TagPathError", nil),
		tagPathErrStruct, nil)
	tagPathErrPtr := types.NewPointer(tagPathErrType)
	tagPathErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", tagPathErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(tagPathErrType.Obj())

	// type UnsupportedTypeError struct { Type reflect.Type }
	unsupTypeErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Type", types.NewInterfaceType(nil, nil), false),
	}, nil)
	unsupTypeErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "UnsupportedTypeError", nil),
		unsupTypeErrStruct, nil)
	unsupTypeErrPtr := types.NewPointer(unsupTypeErrType)
	unsupTypeErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", unsupTypeErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(unsupTypeErrType.Obj())

	// func NewTokenDecoder(t TokenReader) *Decoder
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewTokenDecoder",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "t", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", decoderPtr)),
			false)))

	// MarshalerAttr interface: MarshalXMLAttr(name Name) (Attr, error)
	marshalerAttrIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "MarshalXMLAttr",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "name", nameType)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", attrType),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	marshalerAttrIface.Complete()
	marshalerAttrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "MarshalerAttr", nil),
		marshalerAttrIface, nil)
	scope.Insert(marshalerAttrType.Obj())

	// UnmarshalerAttr interface: UnmarshalXMLAttr(attr Attr) error
	unmarshalerAttrIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "UnmarshalXMLAttr",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "attr", attrType)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	unmarshalerAttrIface.Complete()
	unmarshalerAttrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "UnmarshalerAttr", nil),
		unmarshalerAttrIface, nil)
	scope.Insert(unmarshalerAttrType.Obj())

	// TokenReader interface: Token() (Token, error)
	tokenReaderIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Token",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", tokenType),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	tokenReaderIface.Complete()
	tokenReaderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "TokenReader", nil),
		tokenReaderIface, nil)
	scope.Insert(tokenReaderType.Obj())

	pkg.MarkComplete()
	return pkg
}

// buildEncodingPEMPackage creates the type-checked encoding/pem package stub.
func buildEncodingPEMPackage() *types.Package {
	pkg := types.NewPackage("encoding/pem", "pem")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// type Block struct
	blockStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Type", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Bytes", types.NewSlice(types.Typ[types.Byte]), false),
	}, nil)
	blockType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Block", nil),
		blockStruct, nil)
	scope.Insert(blockType.Obj())
	blockPtr := types.NewPointer(blockType)

	// func Decode(data []byte) (p *Block, rest []byte)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Decode",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "data", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "p", blockPtr),
				types.NewVar(token.NoPos, pkg, "rest", types.NewSlice(types.Typ[types.Byte]))),
			false)))

	// func Encode(out io.Writer, b *Block) error
	pemByteSlice := types.NewSlice(types.Typ[types.Byte])
	ioWriterPEM := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", pemByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioWriterPEM.Complete()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Encode",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "out", ioWriterPEM),
				types.NewVar(token.NoPos, pkg, "b", blockPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func EncodeToMemory(b *Block) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EncodeToMemory",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "b", blockPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoTLSPackage creates the type-checked crypto/tls package stub.
func buildCryptoTLSPackage() *types.Package {
	pkg := types.NewPackage("crypto/tls", "tls")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// type Certificate struct { Certificate [][]byte; PrivateKey interface{}; ... }
	tlsCertStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Certificate", types.NewSlice(types.NewSlice(types.Typ[types.Byte])), false),
		types.NewField(token.NoPos, pkg, "PrivateKey", types.NewInterfaceType(nil, nil), false),
		types.NewField(token.NoPos, pkg, "Leaf", types.NewPointer(types.NewStruct(nil, nil)), false),
	}, nil)
	tlsCertType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Certificate", nil),
		tlsCertStruct, nil)
	scope.Insert(tlsCertType.Obj())

	// type CurveID uint16
	curveIDType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CurveID", nil),
		types.Typ[types.Uint16], nil)
	scope.Insert(curveIDType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "CurveP256", curveIDType, constant.MakeInt64(23)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "CurveP384", curveIDType, constant.MakeInt64(24)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "CurveP521", curveIDType, constant.MakeInt64(25)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "X25519", curveIDType, constant.MakeInt64(29)))

	// type ClientAuthType int
	clientAuthType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ClientAuthType", nil),
		types.Typ[types.Int], nil)
	scope.Insert(clientAuthType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "NoClientCert", clientAuthType, constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RequestClientCert", clientAuthType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RequireAnyClientCert", clientAuthType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "VerifyClientCertIfGiven", clientAuthType, constant.MakeInt64(3)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RequireAndVerifyClientCert", clientAuthType, constant.MakeInt64(4)))

	// type Config struct
	configStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "InsecureSkipVerify", types.Typ[types.Bool], false),
		types.NewField(token.NoPos, pkg, "MinVersion", types.Typ[types.Uint16], false),
		types.NewField(token.NoPos, pkg, "MaxVersion", types.Typ[types.Uint16], false),
		types.NewField(token.NoPos, pkg, "ServerName", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Certificates", types.NewSlice(tlsCertType), false),
		types.NewField(token.NoPos, pkg, "NextProtos", types.NewSlice(types.Typ[types.String]), false),
		types.NewField(token.NoPos, pkg, "ClientAuth", clientAuthType, false),
	}, nil)
	configType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Config", nil),
		configStruct, nil)
	scope.Insert(configType.Obj())
	configPtr := types.NewPointer(configType)

	// Config.Clone() *Config
	configType.AddMethod(types.NewFunc(token.NoPos, pkg, "Clone",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", configPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", configPtr)),
			false)))

	// type ConnectionState struct
	connStateStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Version", types.Typ[types.Uint16], false),
		types.NewField(token.NoPos, pkg, "HandshakeComplete", types.Typ[types.Bool], false),
		types.NewField(token.NoPos, pkg, "ServerName", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "NegotiatedProtocol", types.Typ[types.String], false),
	}, nil)
	connStateType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ConnectionState", nil),
		connStateStruct, nil)
	scope.Insert(connStateType.Obj())

	// type Conn struct
	connStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "fd", types.Typ[types.Int], false),
	}, nil)
	connType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Conn", nil),
		connStruct, nil)
	scope.Insert(connType.Obj())
	connPtr := types.NewPointer(connType)

	// Conn methods
	connRecv := types.NewVar(token.NoPos, nil, "c", connPtr)
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(connRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(connRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(connRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "Handshake",
		types.NewSignatureType(connRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "ConnectionState",
		types.NewSignatureType(connRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", connStateType)),
			false)))

	// func Dial(network, addr string, config *Config) (*Conn, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Dial",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "addr", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "config", configPtr)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", connPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func DialWithDialer(dialer interface{}, network, addr string, config *Config) (*Conn, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DialWithDialer",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "dialer", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "addr", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "config", configPtr)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", connPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "LoadX509KeyPair",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "certFile", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "keyFile", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tlsCertType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "X509KeyPair",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "certPEMBlock", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "keyPEMBlock", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tlsCertType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func NewListener(inner interface{}, config *Config) interface{}
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewListener",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "inner", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "config", configPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewInterfaceType(nil, nil))),
			false)))

	// func Listen(network, laddr string, config *Config) (interface{}, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Listen",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "laddr", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "config", configPtr)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Version constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "VersionTLS10", types.Typ[types.Uint16], constant.MakeInt64(0x0301)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "VersionTLS11", types.Typ[types.Uint16], constant.MakeInt64(0x0302)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "VersionTLS12", types.Typ[types.Uint16], constant.MakeInt64(0x0303)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "VersionTLS13", types.Typ[types.Uint16], constant.MakeInt64(0x0304)))

	// VersionSSL30 deprecated but still referenced
	scope.Insert(types.NewConst(token.NoPos, pkg, "VersionSSL30", types.Typ[types.Uint16], constant.MakeInt64(0x0300)))

	// Cipher suite constants
	cipherSuiteType := types.Typ[types.Uint16]
	for _, c := range []struct {
		name string
		val  int64
	}{
		{"TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f},
		{"TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035},
		{"TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c},
		{"TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d},
		{"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009},
		{"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a},
		{"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013},
		{"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014},
		{"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b},
		{"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c},
		{"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f},
		{"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030},
		{"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8},
		{"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9},
		{"TLS_AES_128_GCM_SHA256", 0x1301},
		{"TLS_AES_256_GCM_SHA384", 0x1302},
		{"TLS_CHACHA20_POLY1305_SHA256", 0x1303},
	} {
		scope.Insert(types.NewConst(token.NoPos, pkg, c.name, cipherSuiteType, constant.MakeInt64(c.val)))
	}

	// type CipherSuite struct
	cipherSuiteStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "ID", types.Typ[types.Uint16], false),
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "SupportedVersions", types.NewSlice(types.Typ[types.Uint16]), false),
		types.NewField(token.NoPos, pkg, "Insecure", types.Typ[types.Bool], false),
	}, nil)
	cipherSuiteStructType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "CipherSuite", nil), cipherSuiteStruct, nil)
	scope.Insert(cipherSuiteStructType.Obj())

	// func CipherSuites() []*CipherSuite
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CipherSuites",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.NewPointer(cipherSuiteStructType)))),
			false)))

	// func InsecureCipherSuites() []*CipherSuite
	scope.Insert(types.NewFunc(token.NoPos, pkg, "InsecureCipherSuites",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.NewPointer(cipherSuiteStructType)))),
			false)))

	// Conn.SetDeadline, Conn.SetReadDeadline, Conn.SetWriteDeadline
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetDeadline",
		types.NewSignatureType(connRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "t", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetReadDeadline",
		types.NewSignatureType(connRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "t", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetWriteDeadline",
		types.NewSignatureType(connRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "t", types.Typ[types.Int64])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "CloseWrite",
		types.NewSignatureType(connRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "LocalAddr",
		types.NewSignatureType(connRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))),
			false)))
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "RemoteAddr",
		types.NewSignatureType(connRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))),
			false)))

	// Config additional fields added as methods
	configType.AddMethod(types.NewFunc(token.NoPos, pkg, "BuildNameToCertificate",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "c", configPtr), nil, nil, nil, nil, false)))

	// func Server(conn net.Conn, config *Config) *Conn
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Server",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "conn", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "config", configPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", connPtr)),
			false)))

	// func Client(conn net.Conn, config *Config) *Conn
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Client",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "conn", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "config", configPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", connPtr)),
			false)))

	// type Dialer struct { NetDialer *net.Dialer; Config *Config }
	dialerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "NetDialer", types.NewInterfaceType(nil, nil), false),
		types.NewField(token.NoPos, pkg, "Config", configPtr, false),
	}, nil)
	dialerType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Dialer", nil), dialerStruct, nil)
	scope.Insert(dialerType.Obj())
	dialerPtr := types.NewPointer(dialerType)
	dialerType.AddMethod(types.NewFunc(token.NoPos, pkg, "DialContext",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "d", dialerPtr), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "ctx", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "network", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "addr", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", connPtr),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// type RenegotiationSupport int
	renegotType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "RenegotiationSupport", nil), types.Typ[types.Int], nil)
	scope.Insert(renegotType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "RenegotiateNever", renegotType, constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RenegotiateOnceAsClient", renegotType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "RenegotiateFreelyAsClient", renegotType, constant.MakeInt64(2)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoX509Package creates the type-checked crypto/x509 package stub.
func buildCryptoX509Package() *types.Package {
	pkg := types.NewPackage("crypto/x509", "x509")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// type KeyUsage int
	keyUsageType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "KeyUsage", nil),
		types.Typ[types.Int], nil)
	scope.Insert(keyUsageType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "KeyUsageDigitalSignature", keyUsageType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "KeyUsageContentCommitment", keyUsageType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "KeyUsageKeyEncipherment", keyUsageType, constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "KeyUsageCertSign", keyUsageType, constant.MakeInt64(32)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "KeyUsageCRLSign", keyUsageType, constant.MakeInt64(64)))

	// type ExtKeyUsage int
	extKeyUsageType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ExtKeyUsage", nil),
		types.Typ[types.Int], nil)
	scope.Insert(extKeyUsageType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "ExtKeyUsageAny", extKeyUsageType, constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ExtKeyUsageServerAuth", extKeyUsageType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ExtKeyUsageClientAuth", extKeyUsageType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ExtKeyUsageCodeSigning", extKeyUsageType, constant.MakeInt64(3)))

	// type SignatureAlgorithm int
	sigAlgType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "SignatureAlgorithm", nil),
		types.Typ[types.Int], nil)
	scope.Insert(sigAlgType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "SHA256WithRSA", sigAlgType, constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SHA384WithRSA", sigAlgType, constant.MakeInt64(5)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SHA512WithRSA", sigAlgType, constant.MakeInt64(6)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ECDSAWithSHA256", sigAlgType, constant.MakeInt64(7)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ECDSAWithSHA384", sigAlgType, constant.MakeInt64(8)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ECDSAWithSHA512", sigAlgType, constant.MakeInt64(9)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "PureEd25519", sigAlgType, constant.MakeInt64(16)))

	// type PublicKeyAlgorithm int
	pubKeyAlgType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "PublicKeyAlgorithm", nil),
		types.Typ[types.Int], nil)
	scope.Insert(pubKeyAlgType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "RSA", pubKeyAlgType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "DSA", pubKeyAlgType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ECDSA", pubKeyAlgType, constant.MakeInt64(3)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Ed25519", pubKeyAlgType, constant.MakeInt64(4)))

	certStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Raw", types.NewSlice(types.Typ[types.Byte]), false),
		types.NewField(token.NoPos, pkg, "RawSubject", types.NewSlice(types.Typ[types.Byte]), false),
		types.NewField(token.NoPos, pkg, "RawIssuer", types.NewSlice(types.Typ[types.Byte]), false),
		types.NewField(token.NoPos, pkg, "Subject", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Issuer", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "NotBefore", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "NotAfter", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "KeyUsage", keyUsageType, false),
		types.NewField(token.NoPos, pkg, "ExtKeyUsage", types.NewSlice(extKeyUsageType), false),
		types.NewField(token.NoPos, pkg, "IsCA", types.Typ[types.Bool], false),
		types.NewField(token.NoPos, pkg, "DNSNames", types.NewSlice(types.Typ[types.String]), false),
		types.NewField(token.NoPos, pkg, "SerialNumber", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "SignatureAlgorithm", sigAlgType, false),
		types.NewField(token.NoPos, pkg, "PublicKeyAlgorithm", pubKeyAlgType, false),
		types.NewField(token.NoPos, pkg, "PublicKey", types.NewInterfaceType(nil, nil), false),
	}, nil)
	certType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Certificate", nil),
		certStruct, nil)
	scope.Insert(certType.Obj())
	certPtr := types.NewPointer(certType)

	// Certificate methods
	certRecv := types.NewVar(token.NoPos, nil, "c", certPtr)
	certType.AddMethod(types.NewFunc(token.NoPos, pkg, "Verify",
		types.NewSignatureType(certRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "opts", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.NewSlice(certPtr))),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	certType.AddMethod(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(certRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "other", certPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// type VerifyOptions struct
	verifyOptsStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "DNSName", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "CurrentTime", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "KeyUsages", types.NewSlice(extKeyUsageType), false),
	}, nil)
	verifyOptsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "VerifyOptions", nil),
		verifyOptsStruct, nil)
	scope.Insert(verifyOptsType.Obj())

	poolStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "data", types.Typ[types.Int], false),
	}, nil)
	poolType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CertPool", nil),
		poolStruct, nil)
	scope.Insert(poolType.Obj())
	poolPtr := types.NewPointer(poolType)

	// CertPool methods
	poolRecv := types.NewVar(token.NoPos, nil, "s", poolPtr)
	poolType.AddMethod(types.NewFunc(token.NoPos, pkg, "AppendCertsFromPEM",
		types.NewSignatureType(poolRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "pemCerts", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))
	poolType.AddMethod(types.NewFunc(token.NoPos, pkg, "AddCert",
		types.NewSignatureType(poolRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "cert", certPtr)),
			nil, false)))

	// func NewCertPool() *CertPool
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewCertPool",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", poolPtr)),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseCertificate",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "asn1Data", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", certPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ParseCertificates(asn1Data []byte) ([]*Certificate, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseCertificates",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "asn1Data", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(certPtr)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ParsePKCS1PrivateKey(der []byte) (interface{}, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParsePKCS1PrivateKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "der", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ParsePKCS8PrivateKey(der []byte) (interface{}, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParsePKCS8PrivateKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "der", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ParsePKIXPublicKey(derBytes []byte) (interface{}, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParsePKIXPublicKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "derBytes", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MarshalPKIXPublicKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "pub", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "SystemCertPool",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", poolPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// type CertificateInvalidError struct
	certInvalidErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Cert", certPtr, false),
		types.NewField(token.NoPos, pkg, "Reason", types.Typ[types.Int], false),
	}, nil)
	certInvalidErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CertificateInvalidError", nil),
		certInvalidErrStruct, nil)
	certInvalidErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", certInvalidErrType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(certInvalidErrType.Obj())

	// type UnknownAuthorityError struct
	unknownAuthErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Cert", certPtr, false),
	}, nil)
	unknownAuthErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "UnknownAuthorityError", nil),
		unknownAuthErrStruct, nil)
	unknownAuthErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", unknownAuthErrType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(unknownAuthErrType.Obj())

	// type CertificateRequest struct
	certReqStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Raw", byteSlice, false),
		types.NewField(token.NoPos, pkg, "RawSubject", byteSlice, false),
		types.NewField(token.NoPos, pkg, "Subject", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "DNSNames", types.NewSlice(types.Typ[types.String]), false),
		types.NewField(token.NoPos, pkg, "EmailAddresses", types.NewSlice(types.Typ[types.String]), false),
		types.NewField(token.NoPos, pkg, "SignatureAlgorithm", sigAlgType, false),
		types.NewField(token.NoPos, pkg, "PublicKeyAlgorithm", pubKeyAlgType, false),
		types.NewField(token.NoPos, pkg, "PublicKey", types.NewInterfaceType(nil, nil), false),
	}, nil)
	certReqType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "CertificateRequest", nil), certReqStruct, nil)
	scope.Insert(certReqType.Obj())

	// func CreateCertificate(rand io.Reader, template *Certificate, parent *Certificate, pub interface{}, priv interface{}) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CreateCertificate",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "rand", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "template", certPtr),
				types.NewVar(token.NoPos, pkg, "parent", certPtr),
				types.NewVar(token.NoPos, pkg, "pub", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "priv", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", byteSlice),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv interface{}) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "CreateCertificateRequest",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "rand", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "template", types.NewPointer(certReqType)),
				types.NewVar(token.NoPos, pkg, "priv", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", byteSlice),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseCertificateRequest",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "asn1Data", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewPointer(certReqType)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func MarshalPKCS1PrivateKey(key interface{}) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MarshalPKCS1PrivateKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "key", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func MarshalPKCS8PrivateKey(key interface{}) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MarshalPKCS8PrivateKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "key", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", byteSlice),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func MarshalECPrivateKey(key interface{}) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MarshalECPrivateKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "key", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", byteSlice),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ParseECPrivateKey(der []byte) (interface{}, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseECPrivateKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "der", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Additional Certificate methods
	certType.AddMethod(types.NewFunc(token.NoPos, pkg, "CheckSignatureFrom",
		types.NewSignatureType(certRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "parent", certPtr)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	certType.AddMethod(types.NewFunc(token.NoPos, pkg, "CheckSignature",
		types.NewSignatureType(certRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "algo", sigAlgType),
				types.NewVar(token.NoPos, nil, "signed", byteSlice),
				types.NewVar(token.NoPos, nil, "signature", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	certType.AddMethod(types.NewFunc(token.NoPos, pkg, "VerifyHostname",
		types.NewSignatureType(certRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "h", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// Additional KeyUsage constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "KeyUsageDataEncipherment", keyUsageType, constant.MakeInt64(8)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "KeyUsageKeyAgreement", keyUsageType, constant.MakeInt64(16)))

	// Additional ExtKeyUsage constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "ExtKeyUsageEmailProtection", extKeyUsageType, constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ExtKeyUsageTimeStamping", extKeyUsageType, constant.MakeInt64(8)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "ExtKeyUsageOCSPSigning", extKeyUsageType, constant.MakeInt64(9)))

	pkg.MarkComplete()
	return pkg
}

// buildDatabaseSQLPackage creates the type-checked database/sql package stub.
func buildDatabaseSQLPackage() *types.Package {
	pkg := types.NewPackage("database/sql", "sql")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	anyType := types.Universe.Lookup("any").Type()

	dbStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "fd", types.Typ[types.Int], false),
	}, nil)
	dbType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "DB", nil),
		dbStruct, nil)
	scope.Insert(dbType.Obj())
	dbPtr := types.NewPointer(dbType)

	// type Result interface { LastInsertId() (int64, error); RowsAffected() (int64, error) }
	resultIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "LastInsertId",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64]),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
		types.NewFunc(token.NoPos, nil, "RowsAffected",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64]),
					types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	resultIface.Complete()
	resultType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Result", nil),
		resultIface, nil)
	scope.Insert(resultType.Obj())

	rowStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "data", types.Typ[types.Int], false),
	}, nil)
	rowType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Row", nil),
		rowStruct, nil)
	scope.Insert(rowType.Obj())
	rowPtr := types.NewPointer(rowType)

	scope.Insert(types.NewFunc(token.NoPos, pkg, "Open",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "driverName", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "dataSourceName", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", dbPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "db", dbPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "QueryRow",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "db", dbPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", rowPtr)),
			true)))

	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "Exec",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "db", dbPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", resultType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	rowType.AddMethod(types.NewFunc(token.NoPos, pkg, "Scan",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", rowPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "dest", types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrNoRows", errType))

	// Rows type
	rowsStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "data", types.Typ[types.Int], false),
	}, nil)
	rowsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Rows", nil),
		rowsStruct, nil)
	scope.Insert(rowsType.Obj())
	rowsPtr := types.NewPointer(rowsType)
	rowsRecv := types.NewVar(token.NoPos, nil, "rs", rowsPtr)

	// Rows.Next() bool
	rowsType.AddMethod(types.NewFunc(token.NoPos, pkg, "Next",
		types.NewSignatureType(rowsRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	// Rows.Scan(dest ...any) error
	rowsType.AddMethod(types.NewFunc(token.NoPos, pkg, "Scan",
		types.NewSignatureType(rowsRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "dest", types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			true)))
	// Rows.Close() error
	rowsType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(rowsRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	// Rows.Err() error
	rowsType.AddMethod(types.NewFunc(token.NoPos, pkg, "Err",
		types.NewSignatureType(rowsRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	// Rows.Columns() ([]string, error)
	rowsType.AddMethod(types.NewFunc(token.NoPos, pkg, "Columns",
		types.NewSignatureType(rowsRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.String])),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// Stmt type
	stmtStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "fd", types.Typ[types.Int], false),
	}, nil)
	stmtType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Stmt", nil),
		stmtStruct, nil)
	scope.Insert(stmtType.Obj())
	stmtPtr := types.NewPointer(stmtType)

	// Tx type
	txStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "fd", types.Typ[types.Int], false),
	}, nil)
	txType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Tx", nil),
		txStruct, nil)
	scope.Insert(txType.Obj())
	txPtr := types.NewPointer(txType)

	// TxOptions type
	txOptsStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Isolation", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "ReadOnly", types.Typ[types.Bool], false),
	}, nil)
	txOptsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "TxOptions", nil),
		txOptsStruct, nil)
	scope.Insert(txOptsType.Obj())

	// NullString type
	nullStringStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "String", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Valid", types.Typ[types.Bool], false),
	}, nil)
	nullStringType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "NullString", nil),
		nullStringStruct, nil)
	scope.Insert(nullStringType.Obj())

	// NullInt64 type
	nullInt64Struct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Int64", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "Valid", types.Typ[types.Bool], false),
	}, nil)
	nullInt64Type := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "NullInt64", nil),
		nullInt64Struct, nil)
	scope.Insert(nullInt64Type.Obj())

	// NullBool type
	nullBoolStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Bool", types.Typ[types.Bool], false),
		types.NewField(token.NoPos, pkg, "Valid", types.Typ[types.Bool], false),
	}, nil)
	nullBoolType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "NullBool", nil),
		nullBoolStruct, nil)
	scope.Insert(nullBoolType.Obj())

	// DB.Query(query string, args ...any) (*Rows, error)
	dbRecv := types.NewVar(token.NoPos, nil, "db", dbPtr)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "Query",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", rowsPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// DB.Prepare(query string) (*Stmt, error)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "Prepare",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", stmtPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// DB.Begin() (*Tx, error)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "Begin",
		types.NewSignatureType(dbRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", txPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// DB.BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "BeginTx",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "opts", types.NewPointer(txOptsType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", txPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// DB.Ping() error
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "Ping",
		types.NewSignatureType(dbRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// DB.PingContext(ctx context.Context) error
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "PingContext",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "ctx", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// DB.SetMaxOpenConns(n int)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetMaxOpenConns",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			nil, false)))

	// DB.SetMaxIdleConns(n int)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetMaxIdleConns",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int])),
			nil, false)))

	// DB.SetConnMaxLifetime(d time.Duration)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetConnMaxLifetime",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "d", types.Typ[types.Int64])),
			nil, false)))

	// DB.SetConnMaxIdleTime(d time.Duration)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetConnMaxIdleTime",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "d", types.Typ[types.Int64])),
			nil, false)))

	// Context-aware methods
	ctxType := types.NewInterfaceType(nil, nil)

	// DB.QueryContext(ctx, query, args...) (*Rows, error)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "QueryContext",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", ctxType),
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", rowsPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// DB.ExecContext(ctx, query, args...) (Result, error)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "ExecContext",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", ctxType),
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", resultType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))

	// DB.QueryRowContext(ctx, query, args...) *Row
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "QueryRowContext",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", ctxType),
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", rowPtr)),
			true)))

	// DB.PrepareContext(ctx, query) (*Stmt, error)
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "PrepareContext",
		types.NewSignatureType(dbRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", ctxType),
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", stmtPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// DB.Stats() DBStats
	dbStatsStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "MaxOpenConnections", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "OpenConnections", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "InUse", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Idle", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "WaitCount", types.Typ[types.Int64], false),
	}, nil)
	dbStatsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "DBStats", nil),
		dbStatsStruct, nil)
	scope.Insert(dbStatsType.Obj())
	dbType.AddMethod(types.NewFunc(token.NoPos, pkg, "Stats",
		types.NewSignatureType(dbRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", dbStatsType)),
			false)))

	// NullFloat64, NullInt32, NullInt16, NullByte, NullTime types
	nullFloat64Struct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Float64", types.Typ[types.Float64], false),
		types.NewField(token.NoPos, pkg, "Valid", types.Typ[types.Bool], false),
	}, nil)
	nullFloat64Type := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "NullFloat64", nil),
		nullFloat64Struct, nil)
	scope.Insert(nullFloat64Type.Obj())

	nullInt32Struct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Int32", types.Typ[types.Int32], false),
		types.NewField(token.NoPos, pkg, "Valid", types.Typ[types.Bool], false),
	}, nil)
	nullInt32Type := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "NullInt32", nil),
		nullInt32Struct, nil)
	scope.Insert(nullInt32Type.Obj())

	// IsolationLevel type
	isolationLevelType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "IsolationLevel", nil),
		types.Typ[types.Int], nil)
	scope.Insert(isolationLevelType.Obj())
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelDefault", isolationLevelType, constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelReadUncommitted", isolationLevelType, constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelReadCommitted", isolationLevelType, constant.MakeInt64(2)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelWriteCommitted", isolationLevelType, constant.MakeInt64(3)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelRepeatableRead", isolationLevelType, constant.MakeInt64(4)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelSnapshot", isolationLevelType, constant.MakeInt64(5)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelSerializable", isolationLevelType, constant.MakeInt64(6)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "LevelLinearizable", isolationLevelType, constant.MakeInt64(7)))

	// Tx context-aware methods
	txRecv := types.NewVar(token.NoPos, nil, "tx", txPtr)
	txType.AddMethod(types.NewFunc(token.NoPos, pkg, "QueryContext",
		types.NewSignatureType(txRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", ctxType),
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", rowsPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))
	txType.AddMethod(types.NewFunc(token.NoPos, pkg, "ExecContext",
		types.NewSignatureType(txRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", ctxType),
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", resultType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))
	txType.AddMethod(types.NewFunc(token.NoPos, pkg, "QueryRowContext",
		types.NewSignatureType(txRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "ctx", ctxType),
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", rowPtr)),
			true)))
	txType.AddMethod(types.NewFunc(token.NoPos, pkg, "Exec",
		types.NewSignatureType(txRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", resultType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))
	txType.AddMethod(types.NewFunc(token.NoPos, pkg, "Query",
		types.NewSignatureType(txRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", rowsPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))
	txType.AddMethod(types.NewFunc(token.NoPos, pkg, "QueryRow",
		types.NewSignatureType(txRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", rowPtr)),
			true)))
	txType.AddMethod(types.NewFunc(token.NoPos, pkg, "Prepare",
		types.NewSignatureType(txRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "query", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", stmtPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	txType.AddMethod(types.NewFunc(token.NoPos, pkg, "Stmt",
		types.NewSignatureType(txRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "stmt", stmtPtr)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", stmtPtr)),
			false)))

	// Tx methods
	txType.AddMethod(types.NewFunc(token.NoPos, pkg, "Commit",
		types.NewSignatureType(txRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	txType.AddMethod(types.NewFunc(token.NoPos, pkg, "Rollback",
		types.NewSignatureType(txRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Stmt methods
	stmtRecv := types.NewVar(token.NoPos, nil, "s", stmtPtr)
	stmtType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(stmtRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	stmtType.AddMethod(types.NewFunc(token.NoPos, pkg, "Exec",
		types.NewSignatureType(stmtRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", resultType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))
	stmtType.AddMethod(types.NewFunc(token.NoPos, pkg, "QueryRow",
		types.NewSignatureType(stmtRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", rowPtr)),
			true)))

	// Row.Err() error
	rowType.AddMethod(types.NewFunc(token.NoPos, pkg, "Err",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", rowPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// Conn type
	connStruct := types.NewStruct(nil, nil)
	connType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Conn", nil), connStruct, nil)
	scope.Insert(connType.Obj())

	// ColumnType
	colTypeStruct := types.NewStruct(nil, nil)
	colType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "ColumnType", nil), colTypeStruct, nil)
	scope.Insert(colType.Obj())

	// Named parameter
	namedArgStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Value", anyType, false),
	}, nil)
	namedArgType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "NamedArg", nil), namedArgStruct, nil)
	scope.Insert(namedArgType.Obj())
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Named",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", namedArgType)),
			false)))

	// Scanner interface
	scannerIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Scan",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "src", anyType)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	scannerIface.Complete()
	scannerType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Scanner", nil), scannerIface, nil)
	scope.Insert(scannerType.Obj())

	// var ErrConnDone, ErrTxDone error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrConnDone", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrTxDone", errType))

	// func Register(name string, driver driver.Driver)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Register",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "driver", types.NewInterfaceType(nil, nil))),
			nil, false)))

	// func Drivers() []string
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Drivers",
		types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String]))),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildArchiveZipPackage creates the type-checked archive/zip package stub.
func buildArchiveZipPackage() *types.Package {
	pkg := types.NewPackage("archive/zip", "zip")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	ioReaderIface := types.NewInterfaceType(nil, nil)
	ioReaderIface.Complete()
	ioWriterIface := types.NewInterfaceType(nil, nil)
	ioWriterIface.Complete()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// Compression method constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "Store", types.Typ[types.Uint16], constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "Deflate", types.Typ[types.Uint16], constant.MakeInt64(8)))

	// Error variables
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrFormat", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrAlgorithm", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrChecksum", errType))

	// type FileHeader struct
	fileHeaderStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Comment", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Method", types.Typ[types.Uint16], false),
		types.NewField(token.NoPos, pkg, "CompressedSize64", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "UncompressedSize64", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "ExternalAttrs", types.Typ[types.Uint32], false),
		types.NewField(token.NoPos, pkg, "Extra", byteSlice, false),
	}, nil)
	fileHeaderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FileHeader", nil),
		fileHeaderStruct, nil)
	scope.Insert(fileHeaderType.Obj())

	// type File struct (embeds FileHeader)
	fileStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Comment", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Method", types.Typ[types.Uint16], false),
		types.NewField(token.NoPos, pkg, "CompressedSize64", types.Typ[types.Uint64], false),
		types.NewField(token.NoPos, pkg, "UncompressedSize64", types.Typ[types.Uint64], false),
	}, nil)
	fileType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "File", nil),
		fileStruct, nil)
	scope.Insert(fileType.Obj())
	filePtr := types.NewPointer(fileType)

	// File.Open() (io.ReadCloser, error)
	rcIface := types.NewInterfaceType(nil, nil)
	rcIface.Complete()
	fileType.AddMethod(types.NewFunc(token.NoPos, pkg, "Open",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "f", filePtr), nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", rcIface),
				types.NewVar(token.NoPos, nil, "", errType)), false)))

	// type Reader struct
	readerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "File", types.NewSlice(filePtr), false),
		types.NewField(token.NoPos, pkg, "Comment", types.Typ[types.String], false),
	}, nil)
	readerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Reader", nil),
		readerStruct, nil)
	scope.Insert(readerType.Obj())
	readerPtr := types.NewPointer(readerType)

	// Reader.Close() error
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", readerPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)), false)))

	// type Writer struct
	writerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "w", ioWriterIface, false),
	}, nil)
	writerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Writer", nil),
		writerStruct, nil)
	scope.Insert(writerType.Obj())
	writerPtr := types.NewPointer(writerType)
	writerRecv := types.NewVar(token.NoPos, nil, "w", writerPtr)

	// Writer.Create(name string) (io.Writer, error)
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Create",
		types.NewSignatureType(writerRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", ioWriterIface),
				types.NewVar(token.NoPos, nil, "", errType)), false)))
	// Writer.CreateHeader(fh *FileHeader) (io.Writer, error)
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "CreateHeader",
		types.NewSignatureType(writerRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "fh", types.NewPointer(fileHeaderType))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", ioWriterIface),
				types.NewVar(token.NoPos, nil, "", errType)), false)))
	// Writer.Close() error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(writerRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)), false)))
	// Writer.Flush() error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Flush",
		types.NewSignatureType(writerRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)), false)))
	// Writer.SetComment(comment string) error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetComment",
		types.NewSignatureType(writerRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "comment", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)), false)))

	// func OpenReader(name string) (*ReadCloser, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "OpenReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", readerPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func NewWriter(w io.Writer) *Writer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriterIface)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", writerPtr)),
			false)))

	// func FileInfoHeader(fi os.FileInfo, link string) (*FileHeader, error)
	fiIface := types.NewInterfaceType(nil, nil)
	fiIface.Complete()
	scope.Insert(types.NewFunc(token.NoPos, pkg, "FileInfoHeader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fi", fiIface),
				types.NewVar(token.NoPos, pkg, "link", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewPointer(fileHeaderType)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildArchiveTarPackage creates the type-checked archive/tar package stub.
func buildArchiveTarPackage() *types.Package {
	pkg := types.NewPackage("archive/tar", "tar")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])
	ioReaderIface := types.NewInterfaceType(nil, nil)
	ioReaderIface.Complete()
	ioWriterIface := types.NewInterfaceType(nil, nil)
	ioWriterIface.Complete()

	// Header struct with common fields
	headerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Typeflag", types.Typ[types.Byte], false),
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Linkname", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Size", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "Mode", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "Uid", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Gid", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Uname", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Gname", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Devmajor", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "Devminor", types.Typ[types.Int64], false),
	}, nil)
	headerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Header", nil),
		headerStruct, nil)
	scope.Insert(headerType.Obj())
	headerPtr := types.NewPointer(headerType)

	// Typeflag constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "TypeReg", types.Typ[types.Byte], constant.MakeInt64('0')))
	scope.Insert(types.NewConst(token.NoPos, pkg, "TypeDir", types.Typ[types.Byte], constant.MakeInt64('5')))
	scope.Insert(types.NewConst(token.NoPos, pkg, "TypeSymlink", types.Typ[types.Byte], constant.MakeInt64('2')))
	scope.Insert(types.NewConst(token.NoPos, pkg, "TypeLink", types.Typ[types.Byte], constant.MakeInt64('1')))

	// Error variables
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrHeader", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrWriteTooLong", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrFieldTooLong", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrWriteAfterClose", errType))

	// Reader type
	readerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "r", ioReaderIface, false),
	}, nil)
	readerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Reader", nil),
		readerStruct, nil)
	scope.Insert(readerType.Obj())
	readerPtr := types.NewPointer(readerType)
	readerRecv := types.NewVar(token.NoPos, nil, "tr", readerPtr)

	// Reader.Next() (*Header, error)
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Next",
		types.NewSignatureType(readerRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", headerPtr),
				types.NewVar(token.NoPos, nil, "", errType)), false)))
	// Reader.Read(b []byte) (int, error)
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(readerRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", errType)), false)))

	// Writer type
	writerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "w", ioWriterIface, false),
	}, nil)
	writerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Writer", nil),
		writerStruct, nil)
	scope.Insert(writerType.Obj())
	writerPtr := types.NewPointer(writerType)
	writerRecv := types.NewVar(token.NoPos, nil, "tw", writerPtr)

	// Writer.WriteHeader(hdr *Header) error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteHeader",
		types.NewSignatureType(writerRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "hdr", headerPtr)),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)), false)))
	// Writer.Write(b []byte) (int, error)
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(writerRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "b", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "", errType)), false)))
	// Writer.Flush() error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Flush",
		types.NewSignatureType(writerRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)), false)))
	// Writer.Close() error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(writerRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)), false)))

	// func NewReader(r io.Reader) *Reader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", ioReaderIface)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", readerPtr)),
			false)))

	// func NewWriter(w io.Writer) *Writer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriterIface)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", writerPtr)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildCompressGzipPackage creates the type-checked compress/gzip package stub.
func buildCompressGzipPackage() *types.Package {
	pkg := types.NewPackage("compress/gzip", "gzip")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// type Header struct
	headerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Comment", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Extra", byteSlice, false),
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "OS", types.Typ[types.Byte], false),
	}, nil)
	headerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Header", nil),
		headerStruct, nil)
	scope.Insert(headerType.Obj())

	readerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Header", headerType, false),
	}, nil)
	readerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Reader", nil),
		readerStruct, nil)
	scope.Insert(readerType.Obj())
	readerPtr := types.NewPointer(readerType)

	ioReader := types.NewInterfaceType(nil, nil)
	ioReader.Complete()
	ioWriter := types.NewInterfaceType(nil, nil)
	ioWriter.Complete()

	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", ioReader)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", readerPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Reader methods
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "z", readerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "p", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "z", readerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "z", readerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", ioReader)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Multistream",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "z", readerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "ok", types.Typ[types.Bool])),
			nil, false)))

	writerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Header", headerType, false),
	}, nil)
	writerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Writer", nil),
		writerStruct, nil)
	scope.Insert(writerType.Obj())
	writerPtr := types.NewPointer(writerType)

	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriter)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", writerPtr)),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriterLevel",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", ioWriter),
				types.NewVar(token.NoPos, pkg, "level", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", writerPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Writer methods
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "z", writerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "p", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "z", writerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Flush",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "z", writerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "z", writerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriter)),
			nil, false)))

	// var ErrChecksum, ErrHeader error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrChecksum", errType))
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrHeader", errType))

	// Compression constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "NoCompression", types.Typ[types.Int], constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "BestSpeed", types.Typ[types.Int], constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "BestCompression", types.Typ[types.Int], constant.MakeInt64(9)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "DefaultCompression", types.Typ[types.Int], constant.MakeInt64(-1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "HuffmanOnly", types.Typ[types.Int], constant.MakeInt64(-2)))

	pkg.MarkComplete()
	return pkg
}

// buildCompressFlatePackage creates the type-checked compress/flate package stub.
func buildCompressFlatePackage() *types.Package {
	pkg := types.NewPackage("compress/flate", "flate")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	scope.Insert(types.NewConst(token.NoPos, pkg, "NoCompression", types.Typ[types.Int], constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "BestSpeed", types.Typ[types.Int], constant.MakeInt64(1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "BestCompression", types.Typ[types.Int], constant.MakeInt64(9)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "DefaultCompression", types.Typ[types.Int], constant.MakeInt64(-1)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "HuffmanOnly", types.Typ[types.Int], constant.MakeInt64(-2)))

	ioReader := types.NewInterfaceType(nil, nil)
	ioReader.Complete()
	ioWriter := types.NewInterfaceType(nil, nil)
	ioWriter.Complete()

	// io.ReadCloser interface for NewReader returns
	ioReadCloser := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
		types.NewFunc(token.NoPos, nil, "Close",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	ioReadCloser.Complete()

	// type Reader — io.ReadCloser
	readerIface := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Reader", nil),
		ioReadCloser, nil)
	scope.Insert(readerIface.Obj())

	// Resetter interface
	resetterIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Reset",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "r", ioReader),
					types.NewVar(token.NoPos, nil, "dict", byteSlice)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
				false)),
	}, nil)
	resetterIface.Complete()
	resetterType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Resetter", nil),
		resetterIface, nil)
	scope.Insert(resetterType.Obj())

	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", ioReader)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ioReadCloser)),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReaderDict",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", ioReader),
				types.NewVar(token.NoPos, pkg, "dict", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", ioReadCloser)),
			false)))

	// type Writer struct
	writerStruct := types.NewStruct(nil, nil)
	writerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Writer", nil),
		writerStruct, nil)
	scope.Insert(writerType.Obj())
	writerPtr := types.NewPointer(writerType)

	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", ioWriter),
				types.NewVar(token.NoPos, pkg, "level", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", writerPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriterDict",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "w", ioWriter),
				types.NewVar(token.NoPos, pkg, "level", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "dict", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", writerPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Write",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "data", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Flush",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Reset",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "dst", ioWriter)),
			nil, false)))

	// type CorruptInputError int64
	corruptType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CorruptInputError", nil),
		types.Typ[types.Int64], nil)
	corruptType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", corruptType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(corruptType.Obj())

	// type InternalError string
	internalType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "InternalError", nil),
		types.Typ[types.String], nil)
	internalType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", internalType),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(internalType.Obj())

	pkg.MarkComplete()
	return pkg
}

// buildHTMLPackage creates the type-checked html package stub.
func buildHTMLPackage() *types.Package {
	pkg := types.NewPackage("html", "html")
	scope := pkg.Scope()

	scope.Insert(types.NewFunc(token.NoPos, pkg, "EscapeString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "UnescapeString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildHTMLTemplatePackage creates the type-checked html/template package stub.
func buildHTMLTemplatePackage() *types.Package {
	pkg := types.NewPackage("html/template", "template")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	anyType := types.Universe.Lookup("any").Type()

	tmplStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "name", types.Typ[types.String], false),
	}, nil)
	tmplType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Template", nil),
		tmplStruct, nil)
	scope.Insert(tmplType.Obj())
	tmplPtr := types.NewPointer(tmplType)

	scope.Insert(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))

	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Parse",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "t", tmplPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "text", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// type FuncMap map[string]any
	funcMapType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FuncMap", nil),
		types.NewMap(types.Typ[types.String], anyType), nil)
	scope.Insert(funcMapType.Obj())

	// io.Writer for template Execute
	htmlByteSlice := types.NewSlice(types.Typ[types.Byte])
	htmlWriterIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Write",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", htmlByteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	htmlWriterIface.Complete()

	tmplRecv := types.NewVar(token.NoPos, nil, "t", tmplPtr)
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Execute",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "wr", htmlWriterIface),
				types.NewVar(token.NoPos, pkg, "data", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "ExecuteTemplate",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "wr", htmlWriterIface),
				types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "data", anyType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Funcs",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "funcMap", funcMapType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Name",
		types.NewSignatureType(tmplRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "New",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Lookup",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "name", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Option",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "opt", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			true)))
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Clone",
		types.NewSignatureType(tmplRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "Delims",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "left", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "right", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "ParseFiles",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "filenames", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))
	tmplType.AddMethod(types.NewFunc(token.NoPos, pkg, "ParseGlob",
		types.NewSignatureType(tmplRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// Package-level functions
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Must",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "t", tmplPtr),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", tmplPtr)),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseFiles",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "filenames", types.NewSlice(types.Typ[types.String]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			true)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseGlob",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "pattern", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", tmplPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// HTML escaping functions
	scope.Insert(types.NewFunc(token.NoPos, pkg, "HTMLEscapeString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "HTMLEscaper",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			true)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "JSEscapeString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "JSEscaper",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			true)))
	scope.Insert(types.NewFunc(token.NoPos, pkg, "URLQueryEscaper",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "args", types.NewSlice(anyType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			true)))

	// Content types
	htmlType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "HTML", nil),
		types.Typ[types.String], nil)
	scope.Insert(htmlType.Obj())
	cssType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "CSS", nil),
		types.Typ[types.String], nil)
	scope.Insert(cssType.Obj())
	jsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "JS", nil),
		types.Typ[types.String], nil)
	scope.Insert(jsType.Obj())
	jsStrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "JSStr", nil),
		types.Typ[types.String], nil)
	scope.Insert(jsStrType.Obj())
	urlType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "URL", nil),
		types.Typ[types.String], nil)
	scope.Insert(urlType.Obj())
	srcsetType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Srcset", nil),
		types.Typ[types.String], nil)
	scope.Insert(srcsetType.Obj())
	htmlAttrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "HTMLAttr", nil),
		types.Typ[types.String], nil)
	scope.Insert(htmlAttrType.Obj())

	// type Error struct
	tplErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "ErrorCode", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Node", types.NewInterfaceType(nil, nil), false),
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Line", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Description", types.Typ[types.String], false),
	}, nil)
	tplErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Error", nil),
		tplErrStruct, nil)
	tplErrPtr := types.NewPointer(tplErrType)
	tplErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", tplErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(tplErrType.Obj())

	// ErrorCode constants
	errCodeType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ErrorCode", nil),
		types.Typ[types.Int], nil)
	scope.Insert(errCodeType.Obj())

	pkg.MarkComplete()
	return pkg
}

// buildMIMEPackage creates the type-checked mime package stub.
func buildMIMEPackage() *types.Package {
	pkg := types.NewPackage("mime", "mime")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	scope.Insert(types.NewFunc(token.NoPos, pkg, "TypeByExtension",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "ext", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "ExtensionsByType",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "typ", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.String])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "FormatMediaType",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "t", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "param", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseMediaType",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "v", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "mediatype", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "params", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildMIMEMultipartPackage creates the type-checked mime/multipart package stub.
func buildMIMEMultipartPackage() *types.Package {
	pkg := types.NewPackage("mime/multipart", "multipart")
	scope := pkg.Scope()

	ioWriter := types.NewInterfaceType(nil, nil)
	ioWriter.Complete()
	ioReader := types.NewInterfaceType(nil, nil)
	ioReader.Complete()

	writerStruct := types.NewStruct(nil, nil)
	writerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Writer", nil),
		writerStruct, nil)
	scope.Insert(writerType.Obj())

	// func NewWriter(w io.Writer) *Writer
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "w", ioWriter)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewPointer(writerType))),
			false)))

	readerStruct := types.NewStruct(nil, nil)
	readerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Reader", nil),
		readerStruct, nil)
	scope.Insert(readerType.Obj())

	// func NewReader(r io.Reader, boundary string) *Reader
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "r", ioReader),
				types.NewVar(token.NoPos, pkg, "boundary", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewPointer(readerType))),
			false)))

	errType := types.Universe.Lookup("error").Type()
	writerPtr := types.NewPointer(writerType)
	readerPtr := types.NewPointer(readerType)
	byteSlice := types.NewSlice(types.Typ[types.Byte])
	strSlice := types.NewSlice(types.Typ[types.String])

	// Writer methods
	// func (w *Writer) Boundary() string
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Boundary",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))
	// func (w *Writer) SetBoundary(boundary string) error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "SetBoundary",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "boundary", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	// func (w *Writer) FormDataContentType() string
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "FormDataContentType",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))
	// MIMEHeader stand-in (map[string][]string)
	mimeHeader := types.NewMap(types.Typ[types.String], types.NewSlice(types.Typ[types.String]))

	// func (w *Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "CreatePart",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "header", mimeHeader)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", ioWriter),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	// func (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "CreateFormFile",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fieldname", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "filename", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", ioWriter),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	// func (w *Writer) CreateFormField(fieldname string) (io.Writer, error)
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "CreateFormField",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "fieldname", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", ioWriter),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	// func (w *Writer) WriteField(fieldname, value string) error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "WriteField",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "fieldname", types.Typ[types.String]),
				types.NewVar(token.NoPos, pkg, "value", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	// func (w *Writer) Close() error
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "w", writerPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// type Part struct { Header textproto.MIMEHeader }
	partStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Header", types.Typ[types.Int], false),
	}, nil)
	partType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Part", nil),
		partStruct, nil)
	scope.Insert(partType.Obj())
	partPtr := types.NewPointer(partType)

	// func (p *Part) Read(d []byte) (n int, err error)
	partType.AddMethod(types.NewFunc(token.NoPos, pkg, "Read",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "p", partPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "d", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "n", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))
	// func (p *Part) Close() error
	partType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "p", partPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	// func (p *Part) FileName() string
	partType.AddMethod(types.NewFunc(token.NoPos, pkg, "FileName",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "p", partPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))
	// func (p *Part) FormName() string
	partType.AddMethod(types.NewFunc(token.NoPos, pkg, "FormName",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "p", partPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	// Reader methods
	// func (r *Reader) NextPart() (*Part, error)
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "NextPart",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", partPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))
	// func (r *Reader) NextRawPart() (*Part, error)
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "NextRawPart",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", partPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// type FileHeader struct
	fileHeaderStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Filename", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Header", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Size", types.Typ[types.Int64], false),
	}, nil)
	fileHeaderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "FileHeader", nil),
		fileHeaderStruct, nil)
	scope.Insert(fileHeaderType.Obj())
	fileHeaderPtr := types.NewPointer(fileHeaderType)

	// func (fh *FileHeader) Open() (File, error) — simplified
	fileHeaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Open",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "fh", fileHeaderPtr),
			nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// type Form struct
	formStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Value", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "File", types.Typ[types.Int], false),
	}, nil)
	formType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Form", nil),
		formStruct, nil)
	scope.Insert(formType.Obj())
	formPtr := types.NewPointer(formType)

	// func (f *Form) RemoveAll() error
	formType.AddMethod(types.NewFunc(token.NoPos, pkg, "RemoveAll",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "f", formPtr),
			nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func (r *Reader) ReadForm(maxMemory int64) (*Form, error)
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadForm",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "r", readerPtr),
			nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "maxMemory", types.Typ[types.Int64])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", formPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// var ErrMessageTooLarge error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrMessageTooLarge", errType))

	_ = strSlice

	pkg.MarkComplete()
	return pkg
}

// buildNetMailPackage creates the type-checked net/mail package stub.
func buildNetMailPackage() *types.Package {
	pkg := types.NewPackage("net/mail", "mail")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	ioReaderIface := types.NewInterfaceType(nil, nil)
	ioReaderIface.Complete()

	// type Header map[string][]string
	headerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Header", nil),
		types.NewMap(types.Typ[types.String], types.NewSlice(types.Typ[types.String])), nil)
	scope.Insert(headerType.Obj())

	// Header.Get(key string) string
	headerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Get",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "h", headerType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))
	// Header.Date() (time.Time, error) - simplified as (int64, error)
	headerType.AddMethod(types.NewFunc(token.NoPos, pkg, "Date",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "h", headerType), nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.Int64]),
				types.NewVar(token.NoPos, nil, "", errType)), false)))

	// type Address struct
	addrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
		types.NewField(token.NoPos, pkg, "Address", types.Typ[types.String], false),
	}, nil)
	addrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Address", nil),
		addrStruct, nil)
	scope.Insert(addrType.Obj())
	addrPtr := types.NewPointer(addrType)

	// Address.String() string
	addrType.AddMethod(types.NewFunc(token.NoPos, pkg, "String",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "a", addrPtr), nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])), false)))

	// type Message struct
	msgStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Header", headerType, false),
		types.NewField(token.NoPos, pkg, "Body", ioReaderIface, false),
	}, nil)
	msgType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Message", nil),
		msgStruct, nil)
	scope.Insert(msgType.Obj())

	// func ReadMessage(r io.Reader) (*Message, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ReadMessage",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "r", ioReaderIface)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewPointer(msgType)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ParseAddress(address string) (*Address, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseAddress",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "address", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", addrPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func ParseAddressList(list string) ([]*Address, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "ParseAddressList",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "list", types.Typ[types.String])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(addrPtr)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// var ErrHeaderNotPresent error
	scope.Insert(types.NewVar(token.NoPos, pkg, "ErrHeaderNotPresent", errType))

	pkg.MarkComplete()
	return pkg
}

// buildNetTextprotoPackage creates the type-checked net/textproto package stub.
func buildNetTextprotoPackage() *types.Package {
	pkg := types.NewPackage("net/textproto", "textproto")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	stringSlice := types.NewSlice(types.Typ[types.String])
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// type MIMEHeader map[string][]string
	mimeHeaderType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "MIMEHeader", nil),
		types.NewMap(types.Typ[types.String], stringSlice), nil)
	scope.Insert(mimeHeaderType.Obj())

	mimeRecv := types.NewVar(token.NoPos, nil, "h", mimeHeaderType)
	mimeHeaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Add",
		types.NewSignatureType(mimeRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String])),
			nil, false)))
	mimeHeaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Set",
		types.NewSignatureType(mimeRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "key", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "value", types.Typ[types.String])),
			nil, false)))
	mimeHeaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Get",
		types.NewSignatureType(mimeRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	mimeHeaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Values",
		types.NewSignatureType(mimeRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", stringSlice)),
			false)))
	mimeHeaderType.AddMethod(types.NewFunc(token.NoPos, pkg, "Del",
		types.NewSignatureType(mimeRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "key", types.Typ[types.String])),
			nil, false)))

	// type Error struct { Code int; Msg string }
	tpErrStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Code", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Msg", types.Typ[types.String], false),
	}, nil)
	tpErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Error", nil),
		tpErrStruct, nil)
	tpErrPtr := types.NewPointer(tpErrType)
	tpErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "e", tpErrPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(tpErrType.Obj())

	// type ProtocolError string
	protoErrType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ProtocolError", nil),
		types.Typ[types.String], nil)
	protoErrType.AddMethod(types.NewFunc(token.NoPos, pkg, "Error",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "p", protoErrType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.String])),
			false)))
	scope.Insert(protoErrType.Obj())

	// type Conn struct
	connStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "conn", types.Typ[types.Int], false),
	}, nil)
	connType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Conn", nil),
		connStruct, nil)
	scope.Insert(connType.Obj())
	connPtr := types.NewPointer(connType)
	connRecv := types.NewVar(token.NoPos, nil, "c", connPtr)
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "Close",
		types.NewSignatureType(connRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	connType.AddMethod(types.NewFunc(token.NoPos, pkg, "Cmd",
		types.NewSignatureType(connRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "args", types.NewSlice(types.NewInterfaceType(nil, nil)))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "id", types.Typ[types.Uint]),
				types.NewVar(token.NoPos, nil, "", errType)),
			true)))

	// type Reader struct
	readerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "R", types.Typ[types.Int], false),
	}, nil)
	readerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Reader", nil),
		readerStruct, nil)
	scope.Insert(readerType.Obj())
	readerPtr := types.NewPointer(readerType)
	readerRecv := types.NewVar(token.NoPos, nil, "r", readerPtr)

	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewReader",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "r", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", readerPtr)),
			false)))

	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadLine",
		types.NewSignatureType(readerRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadLineBytes",
		types.NewSignatureType(readerRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", byteSlice),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadContinuedLine",
		types.NewSignatureType(readerRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadContinuedLineBytes",
		types.NewSignatureType(readerRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", byteSlice),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadCodeLine",
		types.NewSignatureType(readerRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "expectCode", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "code", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "message", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadResponse",
		types.NewSignatureType(readerRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "expectCode", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "code", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "message", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "err", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadDotLines",
		types.NewSignatureType(readerRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", stringSlice),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadDotBytes",
		types.NewSignatureType(readerRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", byteSlice),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "ReadMIMEHeader",
		types.NewSignatureType(readerRecv, nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", mimeHeaderType),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	readerType.AddMethod(types.NewFunc(token.NoPos, pkg, "DotReader",
		types.NewSignatureType(readerRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// type Writer struct
	writerStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "W", types.Typ[types.Int], false),
	}, nil)
	writerType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Writer", nil),
		writerStruct, nil)
	scope.Insert(writerType.Obj())
	writerPtr := types.NewPointer(writerType)
	writerRecv := types.NewVar(token.NoPos, nil, "w", writerPtr)

	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewWriter",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "w", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", writerPtr)),
			false)))

	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "PrintfLine",
		types.NewSignatureType(writerRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "format", types.Typ[types.String]),
				types.NewVar(token.NoPos, nil, "args", types.NewSlice(types.NewInterfaceType(nil, nil)))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			true)))
	writerType.AddMethod(types.NewFunc(token.NoPos, pkg, "DotWriter",
		types.NewSignatureType(writerRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))

	// func NewConn(conn io.ReadWriteCloser) *Conn
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewConn",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "conn", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", connPtr)),
			false)))

	// type Pipeline struct
	pipelineStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "data", types.Typ[types.Int], false),
	}, nil)
	pipelineType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "Pipeline", nil),
		pipelineStruct, nil)
	scope.Insert(pipelineType.Obj())
	pipelinePtr := types.NewPointer(pipelineType)
	pipelineRecv := types.NewVar(token.NoPos, nil, "p", pipelinePtr)
	pipelineType.AddMethod(types.NewFunc(token.NoPos, pkg, "Next",
		types.NewSignatureType(pipelineRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Uint])),
			false)))
	pipelineType.AddMethod(types.NewFunc(token.NoPos, pkg, "StartRequest",
		types.NewSignatureType(pipelineRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "id", types.Typ[types.Uint])),
			nil, false)))
	pipelineType.AddMethod(types.NewFunc(token.NoPos, pkg, "EndRequest",
		types.NewSignatureType(pipelineRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "id", types.Typ[types.Uint])),
			nil, false)))
	pipelineType.AddMethod(types.NewFunc(token.NoPos, pkg, "StartResponse",
		types.NewSignatureType(pipelineRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "id", types.Typ[types.Uint])),
			nil, false)))
	pipelineType.AddMethod(types.NewFunc(token.NoPos, pkg, "EndResponse",
		types.NewSignatureType(pipelineRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "id", types.Typ[types.Uint])),
			nil, false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "CanonicalMIMEHeaderKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "TrimString",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "s", types.Typ[types.String])),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.String])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildNetHTTPUtilPackage creates the type-checked net/http/httputil package stub.
func buildNetHTTPUtilPackage() *types.Package {
	pkg := types.NewPackage("net/http/httputil", "httputil")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// io types for BufferPool
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// BufferPool interface
	bufferPoolIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Get", types.NewSignatureType(nil, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)), false)),
		types.NewFunc(token.NoPos, pkg, "Put", types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "buf", byteSlice)), nil, false)),
	}, nil)
	bufferPoolIface.Complete()
	bufferPoolType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "BufferPool", nil),
		bufferPoolIface, nil)
	scope.Insert(bufferPoolType.Obj())

	// ReverseProxy struct - Director, FlushInterval, ErrorLog, BufferPool, Transport
	// Use *http.Request as int (opaque pointer), http.RoundTripper as int, time.Duration as int64
	reverseProxyStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Director", types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "req", types.Typ[types.Int])), nil, false), false),
		types.NewField(token.NoPos, pkg, "Transport", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "FlushInterval", types.Typ[types.Int64], false),
		types.NewField(token.NoPos, pkg, "ErrorLog", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "BufferPool", bufferPoolType, false),
		types.NewField(token.NoPos, pkg, "ModifyResponse", types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "resp", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)), false), false),
		types.NewField(token.NoPos, pkg, "ErrorHandler", types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "rw", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "req", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "err", errType)), nil, false), false),
	}, nil)
	reverseProxyType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "ReverseProxy", nil),
		reverseProxyStruct, nil)
	scope.Insert(reverseProxyType.Obj())

	// ReverseProxy.ServeHTTP(rw, req)
	reverseProxyType.AddMethod(types.NewFunc(token.NoPos, pkg, "ServeHTTP",
		types.NewSignatureType(
			types.NewVar(token.NoPos, pkg, "p", types.NewPointer(reverseProxyType)), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "rw", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "req", types.Typ[types.Int])),
			nil, false)))

	// NewSingleHostReverseProxy(target *url.URL) *ReverseProxy
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewSingleHostReverseProxy",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "target", types.Typ[types.Int])),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewPointer(reverseProxyType))),
			false)))

	// DumpRequest(req *http.Request, body bool) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DumpRequest",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "req", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "body", types.Typ[types.Bool])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", byteSlice),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// DumpRequestOut(req *http.Request, body bool) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DumpRequestOut",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "req", types.Typ[types.Int]),
				types.NewVar(token.NoPos, nil, "body", types.Typ[types.Bool])),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", byteSlice),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// DumpResponse(resp *http.Response, body bool) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DumpResponse",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "resp", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "body", types.Typ[types.Bool])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", byteSlice),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoEllipticPackage creates the type-checked crypto/elliptic package stub.
func buildCryptoEllipticPackage() *types.Package {
	pkg := types.NewPackage("crypto/elliptic", "elliptic")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])
	bigIntType := types.NewInterfaceType(nil, nil) // *big.Int simplified

	// type Curve interface
	curveIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, pkg, "Params",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))), false)),
		types.NewFunc(token.NoPos, pkg, "IsOnCurve",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "x", bigIntType),
					types.NewVar(token.NoPos, nil, "y", bigIntType)),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
	}, nil)
	curveIface.Complete()
	curveType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "Curve", nil), curveIface, nil)
	scope.Insert(curveType.Obj())

	// type CurveParams struct
	curveParamsStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "P", bigIntType, false),
		types.NewField(token.NoPos, pkg, "N", bigIntType, false),
		types.NewField(token.NoPos, pkg, "B", bigIntType, false),
		types.NewField(token.NoPos, pkg, "Gx", bigIntType, false),
		types.NewField(token.NoPos, pkg, "Gy", bigIntType, false),
		types.NewField(token.NoPos, pkg, "BitSize", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Name", types.Typ[types.String], false),
	}, nil)
	curveParamsType := types.NewNamed(types.NewTypeName(token.NoPos, pkg, "CurveParams", nil), curveParamsStruct, nil)
	scope.Insert(curveParamsType.Obj())

	// func P256/P384/P521/P224() Curve
	for _, name := range []string{"P256", "P384", "P521", "P224"} {
		scope.Insert(types.NewFunc(token.NoPos, pkg, name,
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, pkg, "", curveType)), false)))
	}

	// func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "GenerateKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "curve", curveType),
				types.NewVar(token.NoPos, pkg, "rand", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "priv", byteSlice),
				types.NewVar(token.NoPos, pkg, "x", bigIntType),
				types.NewVar(token.NoPos, pkg, "y", bigIntType),
				types.NewVar(token.NoPos, pkg, "err", errType)),
			false)))

	// func Marshal(curve Curve, x, y *big.Int) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Marshal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "curve", curveType),
				types.NewVar(token.NoPos, pkg, "x", bigIntType),
				types.NewVar(token.NoPos, pkg, "y", bigIntType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func MarshalCompressed(curve Curve, x, y *big.Int) []byte
	scope.Insert(types.NewFunc(token.NoPos, pkg, "MarshalCompressed",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "curve", curveType),
				types.NewVar(token.NoPos, pkg, "x", bigIntType),
				types.NewVar(token.NoPos, pkg, "y", bigIntType)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", byteSlice)),
			false)))

	// func Unmarshal(curve Curve, data []byte) (x, y *big.Int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "Unmarshal",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "curve", curveType),
				types.NewVar(token.NoPos, pkg, "data", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", bigIntType),
				types.NewVar(token.NoPos, pkg, "y", bigIntType)),
			false)))

	// func UnmarshalCompressed(curve Curve, data []byte) (x, y *big.Int)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "UnmarshalCompressed",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "curve", curveType),
				types.NewVar(token.NoPos, pkg, "data", byteSlice)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "x", bigIntType),
				types.NewVar(token.NoPos, pkg, "y", bigIntType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoECDSAPackage creates the type-checked crypto/ecdsa package stub.
func buildCryptoECDSAPackage() *types.Package {
	pkg := types.NewPackage("crypto/ecdsa", "ecdsa")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// io.Reader interface
	ioReaderIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioReaderIface.Complete()

	// elliptic.Curve stand-in interface
	curveIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Params",
			types.NewSignatureType(nil, nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))), false)),
		types.NewFunc(token.NoPos, nil, "IsOnCurve",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "x", types.NewInterfaceType(nil, nil)),
					types.NewVar(token.NoPos, nil, "y", types.NewInterfaceType(nil, nil))),
				types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])), false)),
	}, nil)
	curveIface.Complete()

	// type PublicKey struct { Curve elliptic.Curve; X, Y *big.Int }
	pubStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Curve", curveIface, false),
		types.NewField(token.NoPos, pkg, "X", types.NewInterfaceType(nil, nil), false),
		types.NewField(token.NoPos, pkg, "Y", types.NewInterfaceType(nil, nil), false),
	}, nil)
	pubType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "PublicKey", nil),
		pubStruct, nil)
	scope.Insert(pubType.Obj())

	// type PrivateKey struct { PublicKey; D *big.Int }
	privStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "PublicKey", pubType, true), // embedded
		types.NewField(token.NoPos, pkg, "D", types.NewInterfaceType(nil, nil), false),
	}, nil)
	privType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "PrivateKey", nil),
		privStruct, nil)
	scope.Insert(privType.Obj())

	// func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "GenerateKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "c", curveIface),
				types.NewVar(token.NoPos, pkg, "rand", ioReaderIface)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewPointer(privType)),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	privPtr := types.NewPointer(privType)
	pubPtr := types.NewPointer(pubType)

	// PublicKey methods
	pubType.AddMethod(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "pub", pubPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	pubType.AddMethod(types.NewFunc(token.NoPos, pkg, "ECDH",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "pub", pubPtr), nil, nil,
			nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// PrivateKey methods
	privRecv := types.NewVar(token.NoPos, nil, "priv", privPtr)
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "Public",
		types.NewSignatureType(privRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))),
			false)))
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "Sign",
		types.NewSignatureType(privRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "rand", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "digest", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "opts", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(privRecv, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "ECDH",
		types.NewSignatureType(privRecv, nil, nil,
			nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// Package-level functions
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SignASN1",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "rand", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "priv", privPtr),
				types.NewVar(token.NoPos, pkg, "hash", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "VerifyASN1",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "pub", pubPtr),
				types.NewVar(token.NoPos, pkg, "hash", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "sig", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoRSAPackage creates the type-checked crypto/rsa package stub.
func buildCryptoRSAPackage() *types.Package {
	pkg := types.NewPackage("crypto/rsa", "rsa")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()

	// type PublicKey struct { N *big.Int; E int }
	pubStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "N", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "E", types.Typ[types.Int], false),
	}, nil)
	pubType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "PublicKey", nil),
		pubStruct, nil)
	scope.Insert(pubType.Obj())
	pubPtr := types.NewPointer(pubType)

	// PublicKey.Size() int
	pubType.AddMethod(types.NewFunc(token.NoPos, pkg, "Size",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "pub", pubPtr), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Int])),
			false)))
	// PublicKey.Equal(x interface{}) bool
	pubType.AddMethod(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "pub", pubPtr), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// type PrivateKey struct { PublicKey PublicKey; D *big.Int; ... }
	privStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "PublicKey", pubType, false),
		types.NewField(token.NoPos, pkg, "D", types.Typ[types.Int], false),
	}, nil)
	privType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "PrivateKey", nil),
		privStruct, nil)
	scope.Insert(privType.Obj())
	privPtr := types.NewPointer(privType)

	// PrivateKey methods
	privRecv := types.NewVar(token.NoPos, nil, "priv", privPtr)
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "Public",
		types.NewSignatureType(privRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))),
			false)))
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "Sign",
		types.NewSignatureType(privRecv, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "rand", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, nil, "digest", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "opts", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "Validate",
		types.NewSignatureType(privRecv, nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", errType)),
			false)))

	// type PSSOptions struct
	pssOptsStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "SaltLength", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Hash", types.Typ[types.Int], false),
	}, nil)
	pssOptsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "PSSOptions", nil),
		pssOptsStruct, nil)
	scope.Insert(pssOptsType.Obj())

	// type OAEPOptions struct
	oaepOptsStruct := types.NewStruct([]*types.Var{
		types.NewField(token.NoPos, pkg, "Hash", types.Typ[types.Int], false),
		types.NewField(token.NoPos, pkg, "Label", types.NewSlice(types.Typ[types.Byte]), false),
	}, nil)
	oaepOptsType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "OAEPOptions", nil),
		oaepOptsStruct, nil)
	scope.Insert(oaepOptsType.Obj())

	// PSSSaltLengthAuto and PSSSaltLengthEqualsHash constants
	scope.Insert(types.NewConst(token.NoPos, pkg, "PSSSaltLengthAuto", types.Typ[types.Int], constant.MakeInt64(0)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "PSSSaltLengthEqualsHash", types.Typ[types.Int], constant.MakeInt64(-1)))

	// func GenerateKey(random io.Reader, bits int) (*PrivateKey, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "GenerateKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "random", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "bits", types.Typ[types.Int])),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", privPtr),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SignPKCS1v15",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "rand", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "priv", privPtr),
				types.NewVar(token.NoPos, pkg, "hash", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "hashed", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "VerifyPKCS1v15",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "pub", pubPtr),
				types.NewVar(token.NoPos, pkg, "hash", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "hashed", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "sig", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte, opts *PSSOptions) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "SignPSS",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "rand", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "priv", privPtr),
				types.NewVar(token.NoPos, pkg, "hash", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "digest", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "opts", types.NewPointer(pssOptsType))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func VerifyPSS(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *PSSOptions) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "VerifyPSS",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "pub", pubPtr),
				types.NewVar(token.NoPos, pkg, "hash", types.Typ[types.Int]),
				types.NewVar(token.NoPos, pkg, "digest", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "sig", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "opts", types.NewPointer(pssOptsType))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func EncryptOAEP(hash interface{}, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EncryptOAEP",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "hash", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "random", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "pub", pubPtr),
				types.NewVar(token.NoPos, pkg, "msg", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "label", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func DecryptOAEP(hash interface{}, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DecryptOAEP",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "hash", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "random", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "priv", privPtr),
				types.NewVar(token.NoPos, pkg, "ciphertext", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "label", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "EncryptPKCS1v15",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "rand", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "pub", pubPtr),
				types.NewVar(token.NoPos, pkg, "msg", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	// func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) ([]byte, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "DecryptPKCS1v15",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "rand", types.NewInterfaceType(nil, nil)),
				types.NewVar(token.NoPos, pkg, "priv", privPtr),
				types.NewVar(token.NoPos, pkg, "ciphertext", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	pkg.MarkComplete()
	return pkg
}

// buildCryptoEd25519Package creates the type-checked crypto/ed25519 package stub.
func buildCryptoEd25519Package() *types.Package {
	pkg := types.NewPackage("crypto/ed25519", "ed25519")
	scope := pkg.Scope()
	errType := types.Universe.Lookup("error").Type()
	byteSlice := types.NewSlice(types.Typ[types.Byte])

	// io.Reader interface
	ioReaderIface := types.NewInterfaceType([]*types.Func{
		types.NewFunc(token.NoPos, nil, "Read",
			types.NewSignatureType(nil, nil, nil,
				types.NewTuple(types.NewVar(token.NoPos, nil, "p", byteSlice)),
				types.NewTuple(
					types.NewVar(token.NoPos, nil, "n", types.Typ[types.Int]),
					types.NewVar(token.NoPos, nil, "err", errType)),
				false)),
	}, nil)
	ioReaderIface.Complete()

	pubType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "PublicKey", nil),
		types.NewSlice(types.Typ[types.Byte]), nil)
	scope.Insert(pubType.Obj())

	privType := types.NewNamed(
		types.NewTypeName(token.NoPos, pkg, "PrivateKey", nil),
		types.NewSlice(types.Typ[types.Byte]), nil)
	scope.Insert(privType.Obj())

	// func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error)
	scope.Insert(types.NewFunc(token.NoPos, pkg, "GenerateKey",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "rand", ioReaderIface)),
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "", pubType),
				types.NewVar(token.NoPos, pkg, "", privType),
				types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "Sign",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "privateKey", privType),
				types.NewVar(token.NoPos, pkg, "message", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.NewSlice(types.Typ[types.Byte]))),
			false)))

	scope.Insert(types.NewFunc(token.NoPos, pkg, "Verify",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "publicKey", pubType),
				types.NewVar(token.NoPos, pkg, "message", types.NewSlice(types.Typ[types.Byte])),
				types.NewVar(token.NoPos, pkg, "sig", types.NewSlice(types.Typ[types.Byte]))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", types.Typ[types.Bool])),
			false)))

	// PrivateKey methods
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "Public",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "priv", privType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.NewInterfaceType(nil, nil))),
			false)))
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "Seed",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "priv", privType), nil, nil,
			nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "", byteSlice)),
			false)))
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "Sign",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "priv", privType), nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "rand", ioReaderIface),
				types.NewVar(token.NoPos, nil, "message", byteSlice),
				types.NewVar(token.NoPos, nil, "opts", types.NewInterfaceType(nil, nil))),
			types.NewTuple(
				types.NewVar(token.NoPos, nil, "", byteSlice),
				types.NewVar(token.NoPos, nil, "", errType)),
			false)))
	privType.AddMethod(types.NewFunc(token.NoPos, pkg, "Equal",
		types.NewSignatureType(types.NewVar(token.NoPos, nil, "priv", privType), nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, nil, "x", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, nil, "", types.Typ[types.Bool])),
			false)))

	// func NewKeyFromSeed(seed []byte) PrivateKey
	scope.Insert(types.NewFunc(token.NoPos, pkg, "NewKeyFromSeed",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(types.NewVar(token.NoPos, pkg, "seed", byteSlice)),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", privType)),
			false)))

	// func VerifyWithOptions(publicKey PublicKey, message, sig []byte, opts *Options) error
	scope.Insert(types.NewFunc(token.NoPos, pkg, "VerifyWithOptions",
		types.NewSignatureType(nil, nil, nil,
			types.NewTuple(
				types.NewVar(token.NoPos, pkg, "publicKey", pubType),
				types.NewVar(token.NoPos, pkg, "message", byteSlice),
				types.NewVar(token.NoPos, pkg, "sig", byteSlice),
				types.NewVar(token.NoPos, pkg, "opts", types.NewInterfaceType(nil, nil))),
			types.NewTuple(types.NewVar(token.NoPos, pkg, "", errType)),
			false)))

	scope.Insert(types.NewConst(token.NoPos, pkg, "PublicKeySize", types.Typ[types.Int], constant.MakeInt64(32)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "PrivateKeySize", types.Typ[types.Int], constant.MakeInt64(64)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SignatureSize", types.Typ[types.Int], constant.MakeInt64(64)))
	scope.Insert(types.NewConst(token.NoPos, pkg, "SeedSize", types.Typ[types.Int], constant.MakeInt64(32)))

	pkg.MarkComplete()
	return pkg
}
